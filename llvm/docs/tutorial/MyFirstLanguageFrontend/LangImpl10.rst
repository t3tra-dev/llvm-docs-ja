======================================================
Kaleidoscope: 結論とその他の有用なLLVMの情報
======================================================

.. contents::
   :local:

チュートリアルの結論
==================

「 `LLVMを使った言語実装 <index.html>`_」チュートリアルの最終章へようこそ。このチュートリアルの過程で、私たちの小さなKaleidoscope言語を無用なおもちゃから、半分興味深い (しかしおそらく今でも無用な) おもちゃへと成長させました。:)

どこまで来たか、そしていかに少ないコードでそれが達成されたかを見るのは興味深いことです。私たちは完全なlexer、parser、AST、コードジェネレーター、インタラクティブな実行ループ (JIT付き！) を構築し、スタンドアロン実行可能ファイルでデバッグ情報を出力しました。すべて1000行未満の (コメント・空行を除く) コードで実現しました。

私たちの小さな言語はいくつかの興味深い機能をサポートしています: ユーザー定義の二項・単項演算子をサポートし、即座の評価のためにJITコンパイルを使用し、SSA構築を使ったいくつかの制御フロー構成をサポートしています。

このチュートリアルのアイデアの一部は、言語の定義、構築、そして操作がいかに簡単で楽しいものであるかを示すことでした。コンパイラーの構築は恐ろしい神秘的なプロセスである必要はありません！基本的なことを見てきたので、コードを取得してハックしてみることを強くお勧めします。例えば、以下を追加してみてください:

-  **グローバル変数** - グローバル変数は現代のソフトウェア工学において価値が疑問視されていますが、Kaleidoscopeコンパイラー自体のような手軽で小さなハックをまとめる際にはしばしば有用です。幸いなことに、現在のセットアップはグローバル変数の追加を非常に簡単にします: 未解決変数を拒否する前に、その変数がグローバル変数シンボルテーブルにあるかどうかを値の検索でチェックするだけです。新しいグローバル変数を作成するには、LLVM ``GlobalVariable`` クラスのインスタンスを作成してください。
-  **型付き変数** - Kaleidoscopeは現在double型の変数のみをサポートしています。これにより言語に非常に美しいエレガンスが与えられます。なぜなら、1つの型のみをサポートするということは、型を指定する必要がないことを意味するからです。異なる言語はこれを処理するための異なる方法があります。最も簡単な方法は、ユーザーにすべての変数定義で型を指定することを要求し、その Value\* と共に変数の型をシンボルテーブルに記録することです。
-  **配列、構造体、ベクター等** - 型を追加したら、さまざまな興味深い方法で型システムを拡張し始めることができます。シンプルな配列は非常に簡単で、多くの異なるアプリケーションにとって非常に有用です。それらを追加するのは主にLLVM `getelementptr <../../LangRef.html#getelementptr-instruction>`_ 命令がどのように動作するかを学ぶ練習です: それは非常に巧妙で型にはまらないため、 `専用のFAQ <../../GetElementPtr.html>`_ があります！
-  **標準ランタイム** - 現在の言語では、ユーザーが任意の外部関数にアクセスでき、「printd」や「putchard」などにそれを使用しています。高レベルな構成を追加するために言語を拡張する際、これらの構成は言語が提供するランタイムへの呼び出しに低レベル化される場合に最も意味があることが多いです。例えば、言語にハッシュテーブルを追加する場合、それらをすべてインライン化するのではなく、ルーチンをランタイムに追加することがおそらく理に適っているでしょう。
-  **メモリ管理** - 現在、Kaleidoscopeではスタックにのみアクセスできます。標準libc malloc/freeインターフェースへの呼び出しか、ガベージコレクターを使用してヒープメモリを割り当てることができれば有用でしょう。ガベージコレクションを使用したい場合は、LLVMがオブジェクトを移動し、スタックをスキャン/更新する必要があるアルゴリズムを含む `正確なガベージコレクション <../../GarbageCollection.html>`_ を完全にサポートしていることに注意してください。
-  **例外処理サポート** - LLVMは他の言語でコンパイルされたコードと相互運用する `ゼロコスト例外 <../../ExceptionHandling.html>`_ の生成をサポートしています。すべての関数が暗黙的にエラー値を返し、それをチェックするようにコードを生成することもできます。また、setjmp/longjmpを明示的に使用することもできます。ここには多くの異なるアプローチがあります。
-  **オブジェクト指向、ジェネリクス、データベースアクセス、複素数、幾何プログラミング等** - 本当に、言語に追加できるクレイジーな機能に終わりはありません。
-  **特殊なドメイン** - 私たちは多くの人が興味を持つドメイン、つまり特定の言語のコンパイラーの構築にLLVMを適用することについて話してきました。しかし、通常は考慮されないコンパイラー技術を使用できる他の多くのドメインがあります。例えば、LLVMはOpenGLグラフィックスアクセラレーションの実装、C++コードのActionScriptへの変換、その他多くの可愛らしく巧妙なことに使用されてきました。おそらくあなたがLLVMで正規表現インタープリターをネイティブコードにJITコンパイルする最初の人になるかもしれません？

楽しんでください - 何かクレイジーで異常なことを試してみてください。誰もが常に行っているような言語を構築することは、少しクレイジーだったり型にはまらないことを試して結果がどうなるかを見ることよりも、ずっと楽しくありません。行き詰まったり話し合いたい場合は、`LLVMフォーラム <https://discourse.llvm.org>`_ に投稿してください: 言語に興味がある多くの人がいて、しばしば喜んで手助けしてくれます。

このチュートリアルを終了する前に、LLVM IRを生成するための「コツと技」について話したいと思います。これらは明らかでない微妙なもののいくつかですが、LLVMの機能を活用したい場合には非常に有用です。

LLVM IRの性質
==============

LLVM IR形式のコードについていくつかの共通する質問があります。今すぐそれらを片付けてしまいましょうね？

ターゲット独立性
===============

KaleidoscopeはプログラムがKaleidoscopeで書かれた場合、それが動作するあらゆるターゲット上で同じように動作する「ポータブル言語」の例です。他の多くの言語にもこの性質があります。例: lisp、java、haskell、javascript、pythonなど (これらの言語はポータブルですが、すべてのライブラリがそうではないことに注意してください)。

LLVMの素晴らしい側面の1つは、IRでターゲット独立性を保持できることが多いことです: KaleidoscopeでコンパイルされたプログラムのLLVM IRを取得して、LLVMがサポートするあらゆるターゲットで実行できます。LLVMがネイティブサポートしないターゲットでCコードを生成してコンパイルすることさえ可能です。Kaleidoscopeコンパイラーがターゲット独立コードを生成することは自明に分かります。なぜなら、コード生成時にターゲット固有の情報について決してクエリを行わないからです。

LLVMがコードのコンパクトなターゲット独立表現を提供するという事実は、多くの人を興奮させます。残念ながら、これらの人々は通常、言語の移植性に関する質問をするときC またはCファミリーの言語について考えています。これを「残念」と言うのは、 (完全に一般的な) Cコードをポータブルにする方法が、ソースコードを周りに持ち運ぶ以外に実際にはないからです (もちろん、Cのソースコードも一般的には実際にはポータブルではありません - 本当に古いアプリケーションを32ビットから64ビットに移植したことはありますか？)。

Cの問題 (再び、完全な一般性において) は、ターゲット固有の前提に重くのしかかっていることです。1つのシンプルな例として、プリプロセッサーが入力テキストを処理する際に、コードからターゲット独立性を破壊的に除去することがよくあります:

.. code-block:: c

    #ifdef __i386__
      int X = 1;
    #else
      int X = 42;
    #endif

このような問題により複雑な解決策を工夫することは可能ですが、実際のソースコードを持ち運ぶよりも良い方法で完全な一般性において解決することはできません。

とは言え、ポータブルにできるCの興味深いサブセットがあります。プリミティブ型を固定サイズに固定し (int = 32ビット、long = 64ビットなど)、既存のバイナリとのABI互換性を気にせず、その他のいくつかのマイナーな機能を諦めることをいとわないのであれば、ポータブルなコードを持つことができます。これは、カーネル内言語などの特殊なドメインには意味があります。

安全性保証
---------

上記の言語の多くは「安全な」言語でもあります: Javaで書かれたプログラムがそのアドレス空間を破損させてプロセスをクラッシュさせることは不可能です (JVMにバグがないと仮定して)。安全性は、言語設計、ランタイムサポート、そしてしばしばオペレーティングシステムサポートの組み合わせを必要とする興味深い性質です。

LLVMで安全な言語を実装することは確実に可能ですが、LLVM IR自体は安全性を保証しません。LLVM IRは危険なポインターキャスト、解放後使用のバグ、バッファオーバーラン、その他様々な問題を許可します。安全性はLLVMの上のレイヤーとして実装される必要があり、都合よく、いくつかのグループがこれを調査しています。詳細に興味がある場合は、 `LLVMフォーラム <https://discourse.llvm.org>`_ で質問してください。

言語固有の最適化
===============

LLVMについて多くの人を失望させることの1つは、1つのシステムで世界のすべての問題を解決しないということです。1つの具体的な苦情は、人々がLLVMを高レベル言語固有の最適化を実行できないと認識していることです: LLVMは「あまりにも多くの情報を失う」のです。これについてのいくつかの観察があります:

第一に、LLVMが情報を失うということは正しいです。例えば、この記事を書いている時点では、LLVM IRでSSA値がILP32マシン上のC「int」から来たのかC「long」から来たのかを区別する方法はありません (デバッグ情報以外)。両方とも「i32」値にコンパイルダウンされ、それがどこから来たかに関する情報は失われます。ここでのより一般的な問題は、LLVM型システムが「名前同等性」ではなく「構造同等性」を使用することです。これが人々を驚かせるもう1つの場所は、高レベル言語で同じ構造を持つ2つの型がある場合です (例: 単一のintフィールドを持つ2つの異なる構造体): これらの型は単一のLLVM型にコンパイルダウンされ、それがどこから来たかを判断することが不可能になります。

第二に、LLVMは情報を失う一方で、LLVMは固定的なターゲットではありません: 私たちは多くの異なる方法で継続的に拡張・改善しています。新機能の追加に加えて (LLVMは常に例外やデバッグ情報をサポートしていたわけではありません)、最適化のための重要な情報を捕捉するためにIRを拡張もします (例: 引数が符号拡張かゼロ拡張かどうか、ポインターのエイリアシング情報など)。拡張の多くはユーザー主導です: 人々がLLVMに特定の機能を含めることを望むため、先に進んで拡張します。

第三に、言語固有の最適化を追加することは*可能で簡単*であり、それを行う方法について多くの選択肢があります。1つの自明な例として、言語用にコンパイルされたコードについて物事を「知っている」言語固有の最適化パスを追加することは簡単です。Cファミリーの場合、標準Cライブラリ関数について「知っている」最適化パスがあります。main()で「exit(0)」を呼び出すと、Cが「exit」関数の動作を指定しているため、それを「return 0;」に最適化することが安全であることを認識します。

シンプルなライブラリ知識に加えて、他の様々な言語固有情報をLLVM IRに埋め込むことが可能です。特定の必要性があり、壁にぶつかった場合は、llvm-devリストでそのトピックを提起してください。最悪の場合でも、LLVMを「愚かなコードジェネレーター」として扱い、言語固有のASTでフロントエンドで望む高レベル最適化を実装することが常に可能です。

コツと技
========

LLVMに取り組んだり、LLVMと一緒に作業をした後に知ることになる有用なコツと技の数々があり、それらは一見しただけでは明らかではありません。皆がそれらを再発見するのを待つのではなく、このセクションではこれらの問題のいくつかについて説明します。

ポータブルなoffsetof/sizeofの実装
------------------------------

コンパイラーが生成するコードを「ターゲット独立」に保とうとする場合に出てくる興味深いことの1つは、LLVM型のサイズやllvm構造体のあるフィールドのオフセットを知る必要があることが多いということです。例えば、メモリを割り当てる関数に型のサイズを渡す必要があるかもしれません。

残念ながら、これはターゲット間で大きく異なる可能性があります: 例えば、ポインターの幅は自明にターゲット固有です。しかし、これをポータブルな方法で計算することを可能にする `getelementptr命令の巧妙な使用方法 <http://nondot.org/sabre/LLVMNotes/SizeOf-OffsetOf-VariableSizedStructs.txt>`_ があります。

ガベージコレクトされるスタックフレーム
--------------------------------------

一部の言語は、ガベージコレクトされるように、またはクロージャの簡単な実装を可能にするために、スタックフレームを明示的に管理したいと考えます。明示的なスタックフレームよりもこれらの機能を実装するより良い方法がしばしばありますが、希望するなら、 `LLVMはそれらをサポートします <http://nondot.org/sabre/LLVMNotes/ExplicitlyManagedStackFrames.txt>`_。これにはフロントエンドがコードを `継続渡しスタイル <http://en.wikipedia.org/wiki/Continuation-passing_style>`_ と末尾呼び出しの使用 (LLVMもサポートしています) に変換することが必要です。

