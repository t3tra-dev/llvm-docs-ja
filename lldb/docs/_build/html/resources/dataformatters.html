<!doctype html>
<html class="no-js" lang="en" data-content_root="../">
  <head><meta charset="utf-8"/>
    <meta name="viewport" content="width=device-width,initial-scale=1"/>
    <meta name="color-scheme" content="light dark"><meta name="viewport" content="width=device-width, initial-scale=1" />
<link rel="index" title="Index" href="../genindex.html" /><link rel="search" title="Search" href="../search.html" /><link rel="next" title="Formatter Bytecode" href="formatterbytecode.html" /><link rel="prev" title="Scripting Bridge API" href="sbapi.html" />

    <!-- Generated with Sphinx 7.2.6 and Furo 2024.01.29 -->
        <title>Data Formatters - üêõ LLDB</title>
      <link rel="stylesheet" type="text/css" href="../_static/pygments.css?v=d75fae25" />
    <link rel="stylesheet" type="text/css" href="../_static/styles/furo.css?v=135e06be" />
    <link rel="stylesheet" type="text/css" href="../_static/styles/furo-extensions.css?v=36a5483c" />
    
    


<style>
  body {
    --color-code-background: #f0f0f0;
  --color-code-foreground: black;
  
  }
  @media not print {
    body[data-theme="dark"] {
      --color-code-background: #202020;
  --color-code-foreground: #d0d0d0;
  
    }
    @media (prefers-color-scheme: dark) {
      body:not([data-theme="light"]) {
        --color-code-background: #202020;
  --color-code-foreground: #d0d0d0;
  
      }
    }
  }
</style></head>
  <body>
    
    <script>
      document.body.dataset.theme = localStorage.getItem("theme") || "auto";
    </script>
    

<svg xmlns="http://www.w3.org/2000/svg" style="display: none;">
  <symbol id="svg-toc" viewBox="0 0 24 24">
    <title>Contents</title>
    <svg stroke="currentColor" fill="currentColor" stroke-width="0" viewBox="0 0 1024 1024">
      <path d="M408 442h480c4.4 0 8-3.6 8-8v-56c0-4.4-3.6-8-8-8H408c-4.4 0-8 3.6-8 8v56c0 4.4 3.6 8 8 8zm-8 204c0 4.4 3.6 8 8 8h480c4.4 0 8-3.6 8-8v-56c0-4.4-3.6-8-8-8H408c-4.4 0-8 3.6-8 8v56zm504-486H120c-4.4 0-8 3.6-8 8v56c0 4.4 3.6 8 8 8h784c4.4 0 8-3.6 8-8v-56c0-4.4-3.6-8-8-8zm0 632H120c-4.4 0-8 3.6-8 8v56c0 4.4 3.6 8 8 8h784c4.4 0 8-3.6 8-8v-56c0-4.4-3.6-8-8-8zM115.4 518.9L271.7 642c5.8 4.6 14.4.5 14.4-6.9V388.9c0-7.4-8.5-11.5-14.4-6.9L115.4 505.1a8.74 8.74 0 0 0 0 13.8z"/>
    </svg>
  </symbol>
  <symbol id="svg-menu" viewBox="0 0 24 24">
    <title>Menu</title>
    <svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 24 24" fill="none" stroke="currentColor"
      stroke-width="2" stroke-linecap="round" stroke-linejoin="round" class="feather-menu">
      <line x1="3" y1="12" x2="21" y2="12"></line>
      <line x1="3" y1="6" x2="21" y2="6"></line>
      <line x1="3" y1="18" x2="21" y2="18"></line>
    </svg>
  </symbol>
  <symbol id="svg-arrow-right" viewBox="0 0 24 24">
    <title>Expand</title>
    <svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 24 24" fill="none" stroke="currentColor"
      stroke-width="2" stroke-linecap="round" stroke-linejoin="round" class="feather-chevron-right">
      <polyline points="9 18 15 12 9 6"></polyline>
    </svg>
  </symbol>
  <symbol id="svg-sun" viewBox="0 0 24 24">
    <title>Light mode</title>
    <svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 24 24" fill="none" stroke="currentColor"
      stroke-width="1.5" stroke-linecap="round" stroke-linejoin="round" class="feather-sun">
      <circle cx="12" cy="12" r="5"></circle>
      <line x1="12" y1="1" x2="12" y2="3"></line>
      <line x1="12" y1="21" x2="12" y2="23"></line>
      <line x1="4.22" y1="4.22" x2="5.64" y2="5.64"></line>
      <line x1="18.36" y1="18.36" x2="19.78" y2="19.78"></line>
      <line x1="1" y1="12" x2="3" y2="12"></line>
      <line x1="21" y1="12" x2="23" y2="12"></line>
      <line x1="4.22" y1="19.78" x2="5.64" y2="18.36"></line>
      <line x1="18.36" y1="5.64" x2="19.78" y2="4.22"></line>
    </svg>
  </symbol>
  <symbol id="svg-moon" viewBox="0 0 24 24">
    <title>Dark mode</title>
    <svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 24 24" fill="none" stroke="currentColor"
      stroke-width="1.5" stroke-linecap="round" stroke-linejoin="round" class="icon-tabler-moon">
      <path stroke="none" d="M0 0h24v24H0z" fill="none" />
      <path d="M12 3c.132 0 .263 0 .393 0a7.5 7.5 0 0 0 7.92 12.446a9 9 0 1 1 -8.313 -12.454z" />
    </svg>
  </symbol>
  <symbol id="svg-sun-half" viewBox="0 0 24 24">
    <title>Auto light/dark mode</title>
    <svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 24 24" fill="none" stroke="currentColor"
      stroke-width="1.5" stroke-linecap="round" stroke-linejoin="round" class="icon-tabler-shadow">
      <path stroke="none" d="M0 0h24v24H0z" fill="none"/>
      <circle cx="12" cy="12" r="9" />
      <path d="M13 12h5" />
      <path d="M13 15h4" />
      <path d="M13 18h1" />
      <path d="M13 9h4" />
      <path d="M13 6h1" />
    </svg>
  </symbol>
</svg>

<input type="checkbox" class="sidebar-toggle" name="__navigation" id="__navigation">
<input type="checkbox" class="sidebar-toggle" name="__toc" id="__toc">
<label class="overlay sidebar-overlay" for="__navigation">
  <div class="visually-hidden">Hide navigation sidebar</div>
</label>
<label class="overlay toc-overlay" for="__toc">
  <div class="visually-hidden">Hide table of contents sidebar</div>
</label>



<div class="page">
  <header class="mobile-header">
    <div class="header-left">
      <label class="nav-overlay-icon" for="__navigation">
        <div class="visually-hidden">Toggle site navigation sidebar</div>
        <i class="icon"><svg><use href="#svg-menu"></use></svg></i>
      </label>
    </div>
    <div class="header-center">
      <a href="../index.html"><div class="brand">üêõ LLDB</div></a>
    </div>
    <div class="header-right">
      <div class="theme-toggle-container theme-toggle-header">
        <button class="theme-toggle">
          <div class="visually-hidden">Toggle Light / Dark / Auto color theme</div>
          <svg class="theme-icon-when-auto"><use href="#svg-sun-half"></use></svg>
          <svg class="theme-icon-when-dark"><use href="#svg-moon"></use></svg>
          <svg class="theme-icon-when-light"><use href="#svg-sun"></use></svg>
        </button>
      </div>
      <label class="toc-overlay-icon toc-header-icon" for="__toc">
        <div class="visually-hidden">Toggle table of contents sidebar</div>
        <i class="icon"><svg><use href="#svg-toc"></use></svg></i>
      </label>
    </div>
  </header>
  <aside class="sidebar-drawer">
    <div class="sidebar-container">
      
      <div class="sidebar-sticky"><a class="sidebar-brand" href="../index.html">
  
  
  <span class="sidebar-brand-text">üêõ LLDB</span>
  
</a><form class="sidebar-search-container" method="get" action="../search.html" role="search">
  <input class="sidebar-search" placeholder="Search" name="q" aria-label="Search">
  <input type="hidden" name="check_keywords" value="yes">
  <input type="hidden" name="area" value="default">
</form>
<div id="searchbox"></div><div class="sidebar-scroll"><div class="sidebar-tree">
  <p class="caption" role="heading"><span class="caption-text">Using LLDB</span></p>
<ul>
<li class="toctree-l1"><a class="reference internal" href="../use/tutorial.html">Tutorial</a></li>
<li class="toctree-l1"><a class="reference internal" href="../use/map.html">GDB to LLDB command map</a></li>
<li class="toctree-l1"><a class="reference internal" href="../use/formatting.html">Frame and Thread Format</a></li>
<li class="toctree-l1"><a class="reference internal" href="../use/variable.html">Variable Formatting</a></li>
<li class="toctree-l1"><a class="reference internal" href="../use/symbolication.html">Symbolication</a></li>
<li class="toctree-l1"><a class="reference internal" href="../use/symbols.html">Symbols on macOS</a></li>
<li class="toctree-l1"><a class="reference internal" href="../use/remote.html">Remote Debugging</a></li>
<li class="toctree-l1"><a class="reference internal" href="../use/intel_pt.html">Tracing with Intel Processor Trace</a></li>
<li class="toctree-l1"><a class="reference internal" href="../use/ondemand.html">On Demand Symbols</a></li>
<li class="toctree-l1"><a class="reference internal" href="../use/aarch64-linux.html">Using LLDB On AArch64 Linux</a></li>
<li class="toctree-l1"><a class="reference internal" href="../use/symbolfilejson.html">JSON Symbol File Format</a></li>
<li class="toctree-l1"><a class="reference internal" href="../use/mcp.html">Model Context Protocol (MCP)</a></li>
<li class="toctree-l1"><a class="reference internal" href="../use/troubleshooting.html">Troubleshooting</a></li>
<li class="toctree-l1"><a class="reference internal" href="../use/links.html">Links</a></li>
<li class="toctree-l1"><a class="reference internal" href="../man/lldb.html">Man Page</a></li>
</ul>
<p class="caption" role="heading"><span class="caption-text">Scripting LLDB</span></p>
<ul>
<li class="toctree-l1"><a class="reference internal" href="../use/python.html">Python Scripting</a></li>
<li class="toctree-l1"><a class="reference internal" href="../use/python-reference.html">Python Reference</a></li>
<li class="toctree-l1"><a class="reference internal" href="../python_api.html">Python API</a></li>
<li class="toctree-l1"><a class="reference internal" href="../python_extensions.html">Python Extensions</a></li>
</ul>
<p class="caption" role="heading"><span class="caption-text">Developing LLDB</span></p>
<ul class="current">
<li class="toctree-l1"><a class="reference internal" href="overview.html">Overview</a></li>
<li class="toctree-l1"><a class="reference internal" href="contributing.html">Contributing</a></li>
<li class="toctree-l1"><a class="reference internal" href="build.html">Building</a></li>
<li class="toctree-l1"><a class="reference internal" href="test.html">Testing</a></li>
<li class="toctree-l1"><a class="reference internal" href="qemu-testing.html">Testing LLDB using QEMU</a></li>
<li class="toctree-l1"><a class="reference internal" href="debugging.html">Debugging</a></li>
<li class="toctree-l1"><a class="reference internal" href="fuzzing.html">Fuzzing</a></li>
<li class="toctree-l1"><a class="reference internal" href="sbapi.html">Scripting Bridge API</a></li>
<li class="toctree-l1 current current-page"><a class="current reference internal" href="#">Data Formatters</a></li>
<li class="toctree-l1"><a class="reference internal" href="formatterbytecode.html">Formatter Bytecode</a></li>
<li class="toctree-l1"><a class="reference internal" href="extensions.html">DWARF Extensions</a></li>
<li class="toctree-l1"><a class="reference internal" href="lldbgdbremote.html">GDB Remote Protocol Extensions</a></li>
<li class="toctree-l1"><a class="reference internal" href="lldbplatformpackets.html">LLDB Platform Packets</a></li>
<li class="toctree-l1"><a class="reference internal" href="caveats.html">Caveats</a></li>
<li class="toctree-l1"><a class="reference internal" href="projects.html">Open Projects</a></li>
<li class="toctree-l1"><a class="reference internal" href="lldbdap.html">Contributing to LLDB-DAP</a></li>
<li class="toctree-l1"><a class="reference internal" href="addinglanguagesupport.html">Adding Programming Language Support</a></li>
<li class="toctree-l1"><a class="reference external" href="https://lldb.llvm.org/cpp_reference/namespacelldb.html">Public C++ API</a></li>
<li class="toctree-l1"><a class="reference external" href="https://lldb.llvm.org/cpp_reference/index.html">Private C++ API</a></li>
</ul>
<p class="caption" role="heading"><span class="caption-text">External Links</span></p>
<ul>
<li class="toctree-l1"><a class="reference external" href="https://github.com/llvm/llvm-project">Source Code</a></li>
<li class="toctree-l1"><a class="reference external" href="https://github.com/llvm/llvm-project/releases">Releases</a></li>
<li class="toctree-l1"><a class="reference external" href="https://discord.gg/xS7Z362">Join the Discord</a></li>
<li class="toctree-l1"><a class="reference external" href="https://discord.com/channels/636084430946959380/636732809708306432">Discord Channel</a></li>
<li class="toctree-l1"><a class="reference external" href="https://discourse.llvm.org/c/subprojects/lldb/8">Discussion Forums</a></li>
<li class="toctree-l1"><a class="reference external" href="https://llvm.org/docs/DeveloperPolicy.html">Developer Policy</a></li>
<li class="toctree-l1"><a class="reference external" href="https://github.com/llvm/llvm-project/issues?q=is%3Aissue+label%3Alldb+is%3Aopen">Bug Reports</a></li>
<li class="toctree-l1"><a class="reference external" href="https://github.com/llvm/llvm-project/pulls?q=is%3Apr+label%3Alldb+is%3Aopen">Code Reviews</a></li>
</ul>

</div>
</div>

      </div>
      
    </div>
  </aside>
  <div class="main">
    <div class="content">
      <div class="article-container">
        <a href="#" class="back-to-top muted-link">
          <svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 24 24">
            <path d="M13 20h-2V8l-5.5 5.5-1.42-1.42L12 4.16l7.92 7.92-1.42 1.42L13 8v12z"></path>
          </svg>
          <span>Back to top</span>
        </a>
        <div class="content-icon-container">
          <div class="edit-this-page">
  <a class="muted-link" href="https://github.com/llvm/llvm-project/edit/main/lldb/docs/resources/dataformatters.rst" title="Edit this page">
    <svg aria-hidden="true" viewBox="0 0 24 24" stroke-width="1.5" stroke="currentColor" fill="none" stroke-linecap="round" stroke-linejoin="round">
      <path stroke="none" d="M0 0h24v24H0z" fill="none"/>
      <path d="M4 20h4l10.5 -10.5a1.5 1.5 0 0 0 -4 -4l-10.5 10.5v4" />
      <line x1="13.5" y1="6.5" x2="17.5" y2="10.5" />
    </svg>
    <span class="visually-hidden">Edit this page</span>
  </a>
</div><div class="theme-toggle-container theme-toggle-content">
            <button class="theme-toggle">
              <div class="visually-hidden">Toggle Light / Dark / Auto color theme</div>
              <svg class="theme-icon-when-auto"><use href="#svg-sun-half"></use></svg>
              <svg class="theme-icon-when-dark"><use href="#svg-moon"></use></svg>
              <svg class="theme-icon-when-light"><use href="#svg-sun"></use></svg>
            </button>
          </div>
          <label class="toc-overlay-icon toc-content-icon" for="__toc">
            <div class="visually-hidden">Toggle table of contents sidebar</div>
            <i class="icon"><svg><use href="#svg-toc"></use></svg></i>
          </label>
        </div>
        <article role="main">
          <section id="data-formatters">
<h1>Data Formatters<a class="headerlink" href="#data-formatters" title="Link to this heading">#</a></h1>
<p>This page is an introduction to the design of the LLDB data formatters
subsystem. The intended target audience are people interested in understanding
or modifying the formatters themselves rather than writing a specific data
formatter. For the latter, refer to <a class="reference internal" href="../use/variable.html"><span class="doc">Variable Formatting</span></a>.</p>
<p>This page also highlights some open areas for improvement to the general
subsystem, and more evolutions not anticipated here are certainly possible.</p>
<section id="overview">
<h2>Overview<a class="headerlink" href="#overview" title="Link to this heading">#</a></h2>
<p>The LLDB data formatters subsystem is used to allow the debugger as well as the
end-users to customize the way their variables look upon inspection in the user
interface (be it the command line tool, or one of the several GUIs that are
backed by LLDB).</p>
<p>To this aim, they are hooked into the <code class="docutils literal notranslate"><span class="pre">ValueObjects</span></code> model, in order to
provide entry points through which such customization questions can be
answered. For example: What format should this number be printed as? How many
child elements does this <code class="docutils literal notranslate"><span class="pre">std::vector</span></code> have?</p>
<p>The architecture of the subsystem is layered, with the highest level layer
being the user visible interaction features (e.g. the <code class="docutils literal notranslate"><span class="pre">type</span> <span class="pre">***</span></code> commands,
the SB classes, ‚Ä¶). Other layers of interest that will be analyzed in this
document include:</p>
<ul class="simple">
<li><p>Classes implementing individual data formatter types</p></li>
<li><p>Classes implementing formatters navigation, discovery and categorization</p></li>
<li><p>The <code class="docutils literal notranslate"><span class="pre">FormatManager</span></code> layer</p></li>
<li><p>The <code class="docutils literal notranslate"><span class="pre">DataVisualization</span></code> layer</p></li>
<li><p>The SWIG &lt;&gt; LLDB communication layer</p></li>
</ul>
</section>
<section id="data-formatter-types">
<h2>Data Formatter Types<a class="headerlink" href="#data-formatter-types" title="Link to this heading">#</a></h2>
<p>As described in the user documentation, there are four types of formatters:</p>
<ul class="simple">
<li><p>Formats</p></li>
<li><p>Summaries</p></li>
<li><p>Filters</p></li>
<li><p>Synthetic children</p></li>
</ul>
<p>Formatters have descriptor classes, <code class="docutils literal notranslate"><span class="pre">Type*Impl</span></code>, which contain at least a
‚ÄúFlags‚Äù nested object, which contains both rules to be used by the matching
algorithm (e.g. should the formatter for type Foo apply to a Foo*?) or rules to
be used by the formatter itself (e.g. is this summary a oneliner?).</p>
<p>Individual formatter descriptor classes then also contain data items useful to
them for performing their functionality. For instance <code class="docutils literal notranslate"><span class="pre">TypeFormatImpl</span></code>
(backing formats) contains an <code class="docutils literal notranslate"><span class="pre">lldb::Format</span></code> that is the format to then be
applied were this formatter to be selected. Upon issuing a <code class="docutils literal notranslate"><span class="pre">type</span> <span class="pre">format</span> <span class="pre">add</span></code>
a new <code class="docutils literal notranslate"><span class="pre">TypeFormatImpl</span></code> is created that wraps the user-specified format, and
matching options:</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="n">entry</span><span class="o">.</span><span class="n">reset</span><span class="p">(</span><span class="n">new</span> <span class="n">TypeFormatImpl</span><span class="p">(</span>
    <span class="nb">format</span><span class="p">,</span> <span class="n">TypeFormatImpl</span><span class="p">::</span><span class="n">Flags</span><span class="p">()</span>
                <span class="o">.</span><span class="n">SetCascades</span><span class="p">(</span><span class="n">m_command_options</span><span class="o">.</span><span class="n">m_cascade</span><span class="p">)</span>
                <span class="o">.</span><span class="n">SetSkipPointers</span><span class="p">(</span><span class="n">m_command_options</span><span class="o">.</span><span class="n">m_skip_pointers</span><span class="p">)</span>
                <span class="o">.</span><span class="n">SetSkipReferences</span><span class="p">(</span><span class="n">m_command_options</span><span class="o">.</span><span class="n">m_skip_references</span><span class="p">)));</span>
</pre></div>
</div>
<p>While formats are fairly simple and only implemented by one class, the other
formatter types are backed by a class hierarchy.</p>
<p>Summaries, for instance, can exist in one of three ‚Äúflavors‚Äù:</p>
<ul class="simple">
<li><p>Summary strings</p></li>
<li><p>Python script</p></li>
<li><p>Native C++</p></li>
</ul>
<p>The base class for summaries, <code class="docutils literal notranslate"><span class="pre">TypeSummaryImpl</span></code>, is a pure virtual class that
wraps, again, the Flags, and exports among others:</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="n">virtual</span> <span class="nb">bool</span> <span class="n">FormatObject</span> <span class="p">(</span><span class="n">ValueObject</span> <span class="o">*</span><span class="n">valobj</span><span class="p">,</span> <span class="n">std</span><span class="p">::</span><span class="n">string</span><span class="o">&amp;</span> <span class="n">dest</span><span class="p">)</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
</pre></div>
</div>
<p>This is the core entry point, which allows subclasses to specify their mode of
operation.</p>
<p><code class="docutils literal notranslate"><span class="pre">StringSummaryFormat</span></code>, which is the class that implements summary strings,
does a check as to whether the summary is a one-liner, and if not, then uses
its stored summary string to call into <code class="docutils literal notranslate"><span class="pre">Debugger::FormatPrompt</span></code>, and obtain a
string back, which it returns in <code class="docutils literal notranslate"><span class="pre">dest</span></code> as the resulting summary.</p>
<p>For a Python summary, implemented in <code class="docutils literal notranslate"><span class="pre">ScriptSummaryFormat</span></code>,
<code class="docutils literal notranslate"><span class="pre">FormatObject()</span></code> calls into the <code class="docutils literal notranslate"><span class="pre">ScriptInterpreter</span></code> which is supposed to
hold the knowledge on how to bridge back and forth with the scripting language
(Python in the case of LLDB) in order to produce a valid string. Implementors
of new <code class="docutils literal notranslate"><span class="pre">ScriptInterpreters</span></code> for other languages are expected to provide a
<code class="docutils literal notranslate"><span class="pre">GetScriptedSummary()</span></code> entry point for this purpose, if they desire to allow
users to provide formatters in the new language</p>
<p>Lastly, C++ summaries (<code class="docutils literal notranslate"><span class="pre">CXXFunctionSummaryFormat</span></code>), wrap a function pointer
and call into it to execute their duty. It should be noted that there are no
facilities for users to interact with C++ formatters, and as such they are
extremely opaque, effectively being a thin wrapper between plain function
pointers and the LLDB formatters subsystem.</p>
<p>Also, dynamic loading of C++ formatters in LLDB is currently not implemented,
and as such it is safe and reasonable for these formatters to deal with
internal <code class="docutils literal notranslate"><span class="pre">ValueObjects</span></code> instances instead of public <code class="docutils literal notranslate"><span class="pre">SBValue</span></code> objects.</p>
<p>An interesting data point is that summaries are expected to be stateless. While
at the Python layer they are handed an <code class="docutils literal notranslate"><span class="pre">SBValue</span></code> (since nothing else could be
visible for scripts), it is not expected that the <code class="docutils literal notranslate"><span class="pre">SBValue</span></code> should be cached
and reused - any and all caching occurs on the LLDB side, completely
transparent to the formatter itself.</p>
<p>The design of synthetic children is somewhat more intricate, due to them being
stateful objects. The core idea of the design is that synthetic children act
like a two-tier model, in which there is a backend dataset (the underlying
unformatted <code class="docutils literal notranslate"><span class="pre">ValueObject</span></code>), and an higher level view (frontend) which vends
the computed representation.</p>
<p>To implement a new type of synthetic children one would implement a subclass of
<code class="docutils literal notranslate"><span class="pre">SyntheticChildren</span></code>, which akin to the <code class="docutils literal notranslate"><span class="pre">TypeFormatImpl</span></code>, contains Flags for
matching, and data items to be used for formatting. For instance,
<code class="docutils literal notranslate"><span class="pre">TypeFilterImpl</span></code> (which implements filters), stores the list of expression
paths of the children to be displayed.</p>
<p>Filters are themselves synthetic children. Since all they do is provide child
values for a <code class="docutils literal notranslate"><span class="pre">ValueObject</span></code>, it does not truly matter whether these come from the
real set of children or are crafted through some intricate algorithm. As such,
they perfectly fit within the realm of synthetic children and are only shown as
separate entities for user friendliness (to a user, picking a subset of
elements to be shown with relative ease is a valuable task, and they should not
be concerned with writing scripts to do so).</p>
<p>Once the descriptor of the synthetic children has been coded, in order to hook
it up, one has to implement a subclass of <code class="docutils literal notranslate"><span class="pre">SyntheticChildrenFrontEnd</span></code>. For a
given type of synthetic children, there is a deep coupling with the matching
front-end class, given that the front-end usually needs data stored in the
descriptor (e.g. a filter needs the list of child elements).</p>
<p>The front-end answers the interesting questions that are the true raison d‚Äô√™tre
of synthetic children:</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="n">virtual</span> <span class="n">size_t</span> <span class="n">CalculateNumChildren</span> <span class="p">()</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
<span class="n">virtual</span> <span class="n">lldb</span><span class="p">::</span><span class="n">ValueObjectSP</span> <span class="n">GetChildAtIndex</span> <span class="p">(</span><span class="n">size_t</span> <span class="n">idx</span><span class="p">)</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
<span class="n">virtual</span> <span class="n">size_t</span> <span class="n">GetIndexOfChildWithName</span> <span class="p">(</span><span class="n">const</span> <span class="n">ConstString</span> <span class="o">&amp;</span><span class="n">name</span><span class="p">)</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
<span class="n">virtual</span> <span class="nb">bool</span> <span class="n">Update</span> <span class="p">()</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
<span class="n">virtual</span> <span class="nb">bool</span> <span class="n">MightHaveChildren</span> <span class="p">()</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
</pre></div>
</div>
<p>Synthetic children providers (their front-ends) will be queried by LLDB for a
number of children, and then for each of them as necessary, they should be
prepared to return a <code class="docutils literal notranslate"><span class="pre">ValueObject</span></code> describing the child. They might also be
asked to provide a name-to-index mapping (e.g. to allow LLDB to resolve queries
like <code class="docutils literal notranslate"><span class="pre">myFoo.myChild</span></code>).</p>
<p><code class="docutils literal notranslate"><span class="pre">Update()</span></code> and <code class="docutils literal notranslate"><span class="pre">MightHaveChildren()</span></code> are described in the user
documentation, and they mostly serve bookkeeping purposes.</p>
<p>LLDB provides three kinds of synthetic children: filters, scripted synthetics,
and the native C++ providers Filters are implemented by
<code class="docutils literal notranslate"><span class="pre">TypeFilterImpl::FrontEnd</span></code>.</p>
<p>Scripted synthetics are implemented by <code class="docutils literal notranslate"><span class="pre">ScriptedSyntheticChildren::FrontEnd</span></code>,
plus a set of callbacks provided by the <code class="docutils literal notranslate"><span class="pre">ScriptInterpteter</span></code> infrastructure to
allow LLDB to pass the front-end queries down to the scripting languages.</p>
<p>As for C++ native synthetics, there is a <code class="docutils literal notranslate"><span class="pre">CXXSyntheticChildren</span></code>, but no
corresponding <code class="docutils literal notranslate"><span class="pre">FrontEnd</span></code> class. The reason for this design is that
<code class="docutils literal notranslate"><span class="pre">CXXSyntheticChildren</span></code> store a callback to a creator function, which is
responsible for providing a <code class="docutils literal notranslate"><span class="pre">FrontEnd</span></code>. Each individual formatter (e.g.
<code class="docutils literal notranslate"><span class="pre">LibstdcppMapIteratorSyntheticFrontEnd</span></code>) is a standalone frontend, and once
created retains to relation to its underlying <code class="docutils literal notranslate"><span class="pre">SyntheticChildren</span></code> object.</p>
<p>On a <code class="docutils literal notranslate"><span class="pre">ValueObject</span></code> level, upon being asked to generate synthetic children for
a <code class="docutils literal notranslate"><span class="pre">ValueObject</span></code>, LLDB spawns a ValueObjectSynthetic object which is a
subclass of <code class="docutils literal notranslate"><span class="pre">ValueObject</span></code>. Building upon the <code class="docutils literal notranslate"><span class="pre">ValueObject</span></code> infrastructure,
it stores a backend, and a shared pointer to the <code class="docutils literal notranslate"><span class="pre">SyntheticChildren</span></code>. Upon
being asked queries about children, it will use the <code class="docutils literal notranslate"><span class="pre">SyntheticChildren</span></code> to
generate a front-end for itself and will let the front-end answer questions.
The reason for not storing the <code class="docutils literal notranslate"><span class="pre">FrontEnd</span></code> itself is that there is no
guarantee that across updates, the same <code class="docutils literal notranslate"><span class="pre">FrontEnd</span></code> will be used over and over
(e.g. a <code class="docutils literal notranslate"><span class="pre">SyntheticChildren</span></code> object could serve an entire class hierarchy and
vend different frontends for different subclasses).</p>
</section>
<section id="formatters-matching">
<h2>Formatters Matching<a class="headerlink" href="#formatters-matching" title="Link to this heading">#</a></h2>
<p>The problem of formatters matching is going from ‚ÄúI have a <code class="docutils literal notranslate"><span class="pre">ValueObject</span></code>‚Äù to
‚Äúthese are the formatters to be used for it.‚Äù</p>
<p>There is a rather intricate set of user rules that are involved, and a rather
intricate implementation of this model. All of these relate to the type of the
<code class="docutils literal notranslate"><span class="pre">ValueObject</span></code>. It is assumed that types are a strong enough contract that it
is possible to format an object entirely depending on its type. If this turns
out to not be correct, then the existing model will have to be changed fairly
deeply.</p>
<p>The basic building block is that formatters can match by exact type name or by
regular expressions, i.e. one can describe matching by saying things like ‚Äúthis
formatters matches type <code class="docutils literal notranslate"><span class="pre">__NSDictionaryI</span></code>‚Äù, or ‚Äúthis formatter matches all
type names like <code class="docutils literal notranslate"><span class="pre">^std::__1::vector&lt;.+&gt;((</span> <span class="pre">)?&amp;)?$</span></code>.‚Äù</p>
<p>This match happens in class <code class="docutils literal notranslate"><span class="pre">FormattersContainer</span></code>. For exact matches, this
goes straight to the <code class="docutils literal notranslate"><span class="pre">FormatMap</span></code> (the actual storage area for formatters),
whereas for regular expression matches the regular expression is matched
against the provided candidate type name. If one were to introduce a new type
of matching (say, match against number of <code class="docutils literal notranslate"><span class="pre">$</span></code> signs present in the typename,
<code class="docutils literal notranslate"><span class="pre">FormattersContainer</span></code> is the place where such a change would have to be
introduced).</p>
<p>It should be noted that this code involves template specialization, and as such
is somewhat trickier than other formatters code to update.</p>
<p>On top of the string matching mechanism (exact or regex), there are a set of
more advanced rules implemented by the <code class="docutils literal notranslate"><span class="pre">FormattersContainer</span></code>, with the aid of the
<code class="docutils literal notranslate"><span class="pre">FormattersMatchCandidate</span></code>. Namely, it is assumed that any formatter class will
have flags to say whether it allows cascading (i.e. seeing through typedefs),
allowing pointers-to-object and reference-to-object to be formatted. Upon
verifying that a formatter would be a textual match, the Flags are checked, and
if they do not allow the formatter to be used (e.g. pointers are not allowed,
and one is looking at a Foo*), then the formatter is rejected and the search
continues. If the flags also match, then the formatter is returned upstream and
the search is over.</p>
<p>One relevant fact to notice is that this entire mechanism is not dependent on
the kind of formatter to be returned, which makes it easier to devise new types
of formatters as the lowest layers of the system. The demands on individual
formatters are that they define a few typedefs, and export a Flags object, and
then they can be freely matched against types as needed.</p>
<p>This mechanism is replicated across a number of categories. A category is a
named bucket where formatters are grouped on some basis. The most common reason
for a category to exist is a library (e.g. <code class="docutils literal notranslate"><span class="pre">libcxx</span></code> formatters vs. <code class="docutils literal notranslate"><span class="pre">libstdcpp</span></code>
formatters). Categories can be enabled or disabled, and they have a priority
number, called position. The priority sets a strong order among enabled
categories. A category named ‚Äúdefault‚Äù is always the highest priority one and
it‚Äôs the category where all formatters that do not ask for a category of their
own end up (e.g. <code class="docutils literal notranslate"><span class="pre">type</span> <span class="pre">summary</span> <span class="pre">add</span> <span class="pre">....</span></code> without a <code class="docutils literal notranslate"><span class="pre">w</span> <span class="pre">somecategory</span></code> flag
passed) The algorithm inquires each category, in the order of their priorities,
for a formatter for a type, and upon receiving a positive answer from a
category, ends the search. Of course, no search occurs in disabled categories.</p>
<p>At the individual category level, there is the first dependence on the type of
formatter to be returned. Since both filters and synthetic children proper are
implemented through the same backing store, the matching code needs to ensure
that, were both a synthetic children provider and a filter to match a type,
only the most recently added one is actually used. The details of the algorithm
used are to be found in <code class="docutils literal notranslate"><span class="pre">TypeCategoryImpl::Get()</span></code>.</p>
<p>It is quite obvious, even to a casual reader, that there are a number of
complexities involved in this algorithm. For starters, the entire search
process has to be repeated for every variable. Moreover, for each category, one
has to repeat the entire process of crawling the types (go to pointee, ‚Ä¶).
This is exactly the algorithm initially implemented by LLDB. Over the course of
the life of the formatters subsystem, two main evolutions have been made to the
matching mechanism:</p>
<ul class="simple">
<li><p>A caching mechanism</p></li>
<li><p>A pregeneration of all possible type matches</p></li>
</ul>
<p>The cache is a layer that sits between the <code class="docutils literal notranslate"><span class="pre">FormatManager</span></code> and the
<code class="docutils literal notranslate"><span class="pre">TypeCategoryMap</span></code>. Upon being asked to figure out a formatter, the <code class="docutils literal notranslate"><span class="pre">FormatManager</span></code>
will first query the cache layer, and only if that fails, will the categories
be queried using the full search algorithm. The result of that full search will
then be stored in the cache. Even a negative answer (no formatter) gets stored.
The negative answer is actually the most beneficial to cache as obtaining it
requires traversing all possible formatters in all categories just to get a
no-op back.</p>
<p>Of course, once an answer is cached, getting it will be much quicker than going
to a full category search, as the cached answers are of the form ‚Äútype foo‚Äù ‚Äì&gt;
‚Äúformatter bar‚Äù. But given how formatters can be edited or removed by the user,
either at the command line or via the API, there needs to be a way to
invalidate the cache.</p>
<p>This happens through the <code class="docutils literal notranslate"><span class="pre">FormatManager::Changed()</span></code> method. In general, anything
that changes the formatters causes <code class="docutils literal notranslate"><span class="pre">FormatManager::Changed()</span></code> to be called
through the <code class="docutils literal notranslate"><span class="pre">IFormatChangeListener</span></code> interface. This call increases the
<code class="docutils literal notranslate"><span class="pre">FormatManager</span></code>‚Äôs revision and clears the cache. The revision number is a
monotonically increasing integer counter that essentially corresponds to the
number of changes made to the formatters throughout the current LLDB session.
This counter is used by <code class="docutils literal notranslate"><span class="pre">ValueObjects</span></code> to know when their formatters are out of
date. Since a search is a potentially expensive operation, before caching was
introduced, individual <code class="docutils literal notranslate"><span class="pre">ValueObjects</span></code> remembered which revision of the
<code class="docutils literal notranslate"><span class="pre">FormatManager</span></code> they used to search for their formatter, and stored it, so that
they would not repeat the search unless a change in the formatters had
occurred. While caching has made this less critical of an optimization, it is
still sensible and thus is kept.</p>
<p>Lastly, as a side note, it is worth highlighting that any change in the
formatters invalidates the entire cache. It would likely not be impossible to
be smarter and figure out a subset of cache entries to be deleted, letting
others persist, instead of having to rebuild the entire cache from scratch.
However, given that formatters are not that frequently changed during a debug
session, and the algorithmic complexity to ‚Äúget it right‚Äù seems larger than the
potential benefit to be had from doing it, the full cache invalidation is the
chosen policy. The algorithm to selectively invalidate entries is probably one
of the major areas for improvements in formatters performance.</p>
<p>The second major optimization, introduced fairly recently, is the pregeneration
of type matches. The original algorithm was based upon the notion of a
<code class="docutils literal notranslate"><span class="pre">FormatNavigator</span></code> as a smart object, aware of all the intricacies of the
matching rules. For each category, the <code class="docutils literal notranslate"><span class="pre">FormatNavigator</span></code> would generate the
possible matches (e.g. dynamic type, pointee type, ‚Ä¶), and check each one,
one at a time. If that failed for a category, the next one would again generate
the same matches.</p>
<p>This worked well, but was of course inefficient. The
<code class="docutils literal notranslate"><span class="pre">FormattersMatchCandidate</span></code> is the solution to this performance issue. In
top-of-tree LLDB, the <code class="docutils literal notranslate"><span class="pre">FormatManager</span></code> has the centralized notion of the
matching rules, and the former <code class="docutils literal notranslate"><span class="pre">FormatNavigators</span></code> are now
<code class="docutils literal notranslate"><span class="pre">FormattersContainers</span></code>, whose only job is to guarantee a centralized storage
of formatters, and thread-safe access to such storage.</p>
<p><code class="docutils literal notranslate"><span class="pre">FormatManager::GetPossibleMatches()</span></code> fills a vector of possible matches. The
way it works is by applying each rule, generating the corresponding typename,
and storing the typename, plus the required Flags for that rule to be accepted
as a match candidate (e.g. if the match comes by fetching the pointee type, a
formatter that matches will have to allow pointees as part of its Flags
object). The <code class="docutils literal notranslate"><span class="pre">TypeCategoryMap</span></code>, when tasked with finding a formatter for a
type, generates all possible matches and passes them down to each category. In
this model, the type system only does its (expensive) job once, and textual or
regex matches are the core of the work.</p>
</section>
<section id="formatmanager-and-datavisualization">
<h2>FormatManager and DataVisualization<a class="headerlink" href="#formatmanager-and-datavisualization" title="Link to this heading">#</a></h2>
<p>There are two main entry points in the data formatters: the <code class="docutils literal notranslate"><span class="pre">FormatManager</span></code> and
the <code class="docutils literal notranslate"><span class="pre">DataVisualization</span></code>.</p>
<p>The <code class="docutils literal notranslate"><span class="pre">FormatManager</span></code> is the internal such entry point. In this context,
internal refers to data formatters code itself, compared to other parts of
LLDB. For other components of the debugger, the <code class="docutils literal notranslate"><span class="pre">DataVisualization</span></code> provides
a more stable entry point. On the other hand, the <code class="docutils literal notranslate"><span class="pre">FormatManager</span></code> is an
aggregator of all moving parts, and as such is less stable in the face of
refactoring.</p>
<p>People involved in the data formatters code itself, however, will most likely
have to confront the <code class="docutils literal notranslate"><span class="pre">FormatManager</span></code> for significant architecture changes.</p>
<p>The <code class="docutils literal notranslate"><span class="pre">FormatManager</span></code> wraps a <code class="docutils literal notranslate"><span class="pre">TypeCategoryMap</span></code> (the list of all existing
categories, enabled and not), the <code class="docutils literal notranslate"><span class="pre">FormatCache</span></code>, and several utility objects.
Plus, it is the repository of named summaries, since these don‚Äôt logically
belong anywhere else.</p>
<p>It is also responsible for creating all builtin formatters upon the launch of
LLDB. It does so through a bunch of methods <code class="docutils literal notranslate"><span class="pre">Load***Formatters()</span></code>, invoked as
part of its constructor. The original design of data formatters anticipated
that individual libraries would load their formatters as part of their debug
information. This work however has largely been left unattended in practice,
and as such core system libraries (mostly those for masOS/iOS development as of
today) load their formatters in an hardcoded fashion.</p>
<p>For performance reasons, the <code class="docutils literal notranslate"><span class="pre">FormatManager</span></code> is constructed upon being first
required. This happens through the <code class="docutils literal notranslate"><span class="pre">DataVisualization</span></code> layer. Upon first
being inquired for anything formatters, <code class="docutils literal notranslate"><span class="pre">DataVisualization</span></code> calls its own
local static function <code class="docutils literal notranslate"><span class="pre">GetFormatManager()</span></code>, which in turns constructs and
returns a local static <code class="docutils literal notranslate"><span class="pre">FormatManager</span></code>.</p>
<p>Unlike most things in LLDB, the lifetime of the <code class="docutils literal notranslate"><span class="pre">FormatManager</span></code> is the same
as the entire session, rather than a specific <code class="docutils literal notranslate"><span class="pre">Debugger</span></code> or <code class="docutils literal notranslate"><span class="pre">Target</span></code>
instance. This is an area to be improved, but as of now it has not caused
enough grief to warrant action. If this work were to be undertaken, one could
conceivably devise a per-architecture-triple model, upon the assumption that an
OS and CPU combination are a good enough key to decide which formatters apply
(e.g. Linux i386 is probably different from masOS x86_64, but two macOS x86_64
targets will probably have the same formatters; of course versioning of the
underlying OS is also to be considered, but experience with OSX has shown that
formatters can take care of that internally in most cases of interest).</p>
<p>The public entry point is the <code class="docutils literal notranslate"><span class="pre">DataVisualization</span></code> layer.
<code class="docutils literal notranslate"><span class="pre">DataVisualization</span></code> is a static class on which questions can be asked in a
relatively refactoring-safe manner.</p>
<p>The main question asked of it is to obtain formatters for <code class="docutils literal notranslate"><span class="pre">ValueObjects</span></code> (or
typenames). One can also query <code class="docutils literal notranslate"><span class="pre">DataVisualization</span></code> for named summaries or
individual categories, but of course those queries delve deeper in the internal
object model.</p>
<p>As said, the <code class="docutils literal notranslate"><span class="pre">FormatManager</span></code> holds a notion of revision number, which changes
every time formatters are edited (added, deleted, categories enabled or
disabled, ‚Ä¶). Through <code class="docutils literal notranslate"><span class="pre">DataVisualization::ForceUpdate()</span></code> one can cause the
same effects of a formatters edit to happen without it actually having
happened.</p>
<p>The main reason for this feature is that formatters can be dynamically created
in Python, and one can then enter the <code class="docutils literal notranslate"><span class="pre">ScriptInterpreter</span></code> and edit the
formatter function or class. If formatters were not updated, one could find
them to be out of sync with the new definitions of these objects. To avoid the
issue, whenever the user exits the scripting mode, formatters force an update
to make sure new potential definitions are reloaded on demand.</p>
</section>
<section id="the-swig-layer">
<h2>The SWIG Layer<a class="headerlink" href="#the-swig-layer" title="Link to this heading">#</a></h2>
<p>In order to implement formatters written in Python, LLDB requires that
<code class="docutils literal notranslate"><span class="pre">ScriptInterpreter</span></code> implementations provide a set of functions that one can call
to ask formatting questions of scripts.</p>
<p>For instance, in order to obtain a scripting summary, LLDB calls:</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="n">virtual</span> <span class="nb">bool</span>
<span class="n">GetScriptedSummary</span><span class="p">(</span><span class="n">const</span> <span class="n">char</span> <span class="o">*</span><span class="n">function_name</span><span class="p">,</span> <span class="n">llldb</span><span class="p">::</span><span class="n">ValueObjectSP</span> <span class="n">valobj</span><span class="p">,</span>
                   <span class="n">lldb</span><span class="p">::</span><span class="n">ScriptInterpreterObjectSP</span> <span class="o">&amp;</span><span class="n">callee_wrapper_sp</span><span class="p">,</span>
                   <span class="n">std</span><span class="p">::</span><span class="n">string</span> <span class="o">&amp;</span><span class="n">retval</span><span class="p">)</span>
</pre></div>
</div>
<p>For Python, this function is implemented by first checking if the
<code class="docutils literal notranslate"><span class="pre">callee_wrapper_sp</span></code> is valid. If so, LLDB knows that it does not need to
search a function with the passed name, and can directly call the wrapped
Python function object. Either way, the call is routed to a global callback
<code class="docutils literal notranslate"><span class="pre">g_swig_typescript_callback</span></code>.</p>
<p>This callback pointer points to <code class="docutils literal notranslate"><span class="pre">LLDBSwigPythonCallTypeScript</span></code>. The details
of the implementation require familiarity with the Python C API, plus a few
utility objects defined by LLDB to ease the burden of dealing with the
scripting world. However, as a sketch of what happens, the code tries to find a
Python function object with the given name (i.e. if you say <code class="docutils literal notranslate"><span class="pre">type</span> <span class="pre">summary</span> <span class="pre">add</span>
<span class="pre">-F</span> <span class="pre">module.function</span></code> LLDB will scan for the <code class="docutils literal notranslate"><span class="pre">module</span></code> module, and then for a
function named <code class="docutils literal notranslate"><span class="pre">function</span></code> inside the module‚Äôs namespace). If the function
object is found, it is wrapped in a <code class="docutils literal notranslate"><span class="pre">PyCallable</span></code>, which is an LLDB utility class
that wraps the callable and allows for easier calling. The callable gets
invoked, and the return value, if any, is cast into a string. Originally, if a
non-string object was returned, LLDB would refuse to use it. This disallowed
such simple construct as:</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="k">def</span><span class="w"> </span><span class="nf">getSummary</span><span class="p">(</span><span class="n">value</span><span class="p">,</span><span class="o">*</span><span class="n">args</span><span class="p">):</span>
  <span class="k">return</span> <span class="mi">1</span>
</pre></div>
</div>
<p>Similar considerations apply to other formatter (and non-formatter related)
scripting callbacks.</p>
</section>
</section>

        </article>
      </div>
      <footer>
        
        <div class="related-pages">
          <a class="next-page" href="formatterbytecode.html">
              <div class="page-info">
                <div class="context">
                  <span>Next</span>
                </div>
                <div class="title">Formatter Bytecode</div>
              </div>
              <svg class="furo-related-icon"><use href="#svg-arrow-right"></use></svg>
            </a>
          <a class="prev-page" href="sbapi.html">
              <svg class="furo-related-icon"><use href="#svg-arrow-right"></use></svg>
              <div class="page-info">
                <div class="context">
                  <span>Previous</span>
                </div>
                
                <div class="title">Scripting Bridge API</div>
                
              </div>
            </a>
        </div>
        <div class="bottom-of-page">
          <div class="left-details">
            <div class="copyright">
                Copyright &#169; 2007-2025, The LLDB Team
            </div>
            Made with <a href="https://www.sphinx-doc.org/">Sphinx</a> and <a class="muted-link" href="https://pradyunsg.me">@pradyunsg</a>'s
            
            <a href="https://github.com/pradyunsg/furo">Furo</a>
            <div class="last-updated">
              Last updated on Aug 13, 2025</div>
          </div>
          <div class="right-details">
            
          </div>
        </div>
        
      </footer>
    </div>
    <aside class="toc-drawer">
      
      
      <div class="toc-sticky toc-scroll">
        <div class="toc-title-container">
          <span class="toc-title">
            On this page
          </span>
        </div>
        <div class="toc-tree-container">
          <div class="toc-tree">
            <ul>
<li><a class="reference internal" href="#">Data Formatters</a><ul>
<li><a class="reference internal" href="#overview">Overview</a></li>
<li><a class="reference internal" href="#data-formatter-types">Data Formatter Types</a></li>
<li><a class="reference internal" href="#formatters-matching">Formatters Matching</a></li>
<li><a class="reference internal" href="#formatmanager-and-datavisualization">FormatManager and DataVisualization</a></li>
<li><a class="reference internal" href="#the-swig-layer">The SWIG Layer</a></li>
</ul>
</li>
</ul>

          </div>
        </div>
      </div>
      
      
    </aside>
  </div>
</div><script src="../_static/documentation_options.js?v=7f41d439"></script>
    <script src="../_static/doctools.js?v=888ff710"></script>
    <script src="../_static/sphinx_highlight.js?v=dc90522c"></script>
    <script src="../_static/scripts/furo.js?v=32e29ea5"></script>
    </body>
</html>