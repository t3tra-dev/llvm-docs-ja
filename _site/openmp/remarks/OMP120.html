<!DOCTYPE html>

<html lang="en" data-content_root="../">
  <head>
    <meta charset="utf-8" />
    <meta name="viewport" content="width=device-width, initial-scale=1.0" /><meta name="viewport" content="width=device-width, initial-scale=1" />

    <title>Transformed generic-mode kernel to SPMD-mode [OMP120] &#8212; LLVM/OpenMP  documentation</title>
    <link rel="stylesheet" type="text/css" href="../_static/pygments.css?v=d75fae25" />
    <link rel="stylesheet" type="text/css" href="../_static/agogo.css?v=a323ad78" />
    <script src="../_static/documentation_options.js?v=7f41d439"></script>
    <script src="../_static/doctools.js?v=888ff710"></script>
    <script src="../_static/sphinx_highlight.js?v=dc90522c"></script>
    <link rel="index" title="Index" href="../genindex.html" />
    <link rel="search" title="Search" href="../search.html" />
    <link rel="next" title="Value has potential side effects preventing SPMD-mode execution. Add [[omp::assume(&#34;ompx_spmd_amenable&#34;)]] to the called function to override. [OMP121]" href="OMP121.html" />
    <link rel="prev" title="Could not move globalized variable to the stack. Variable is potentially captured in call. Mark parameter as __attribute__((noescape)) to override. [OMP113]" href="OMP113.html" />
<style type="text/css">
  table.right { float: right; margin-left: 20px; }
  table.right td { border: 1px solid #ccc; }
</style>

  </head><body>
    <div class="header-wrapper" role="banner">
      <div class="header">
        <div class="headertitle"><a
          href="../index.html">LLVM/OpenMP  documentation</a></div>
        <div class="rel" role="navigation" aria-label="related navigation">
          <a href="../index.html" title="LLVM OpenMP Documentation">HOME</a>
           |
          <a href="OMP113.html" title="Could not move globalized variable to the stack. Variable is potentially captured in call. Mark parameter as __attribute__((noescape)) to override. [OMP113]"
             accesskey="P">previous</a> |
          <a href="OMP121.html" title="Value has potential side effects preventing SPMD-mode execution. Add [[omp::assume(&#34;ompx_spmd_amenable&#34;)]] to the called function to override. [OMP121]"
             accesskey="N">next</a> |
          <a href="../genindex.html" title="General Index"
             accesskey="I">index</a>
        </div>
       </div>
    </div>

    <div class="content-wrapper">
      <div class="content">
        <div class="document">
            
      <div class="documentwrapper">
        <div class="bodywrapper">
          <div class="body" role="main">
            
  <section id="transformed-generic-mode-kernel-to-spmd-mode-omp120">
<span id="omp120"></span><h1>Transformed generic-mode kernel to SPMD-mode [OMP120]<a class="headerlink" href="#transformed-generic-mode-kernel-to-spmd-mode-omp120" title="Link to this heading">¶</a></h1>
<p>This optimization remark indicates that the execution strategy for the OpenMP
target offloading kernel was changed. Generic-mode kernels are executed by a
single thread that schedules parallel worker threads using a state machine. This
code transformation can move a kernel that was initially generated in generic
mode to SPMD-mode where all threads are active at the same time with no state
machine. This execution strategy is closer to how the threads are actually
executed on a GPU target. This is only possible if the instructions previously
executed by a single thread have no side-effects or can be guarded. If the
instructions have no side-effects they are simply recomputed by each thread.</p>
<p>Generic-mode is often considerably slower than SPMD-mode because of the extra
overhead required to separately schedule worker threads and pass data between
them.This optimization allows users to use generic-mode semantics while
achieving the performance of SPMD-mode. This can be helpful when defining shared
memory between the threads using <a class="reference internal" href="OMP111.html#omp111"><span class="std std-ref">OMP111</span></a>.</p>
<section id="examples">
<h2>Examples<a class="headerlink" href="#examples" title="Link to this heading">¶</a></h2>
<p>Normally, any kernel that contains split OpenMP target and parallel regions will
be executed in generic-mode. Sometimes it is easier to use generic-mode
semantics to define shared memory, or more tightly control the distribution of
the threads. This shows a naive matrix-matrix multiplication that contains code
that will need to be guarded.</p>
<div class="highlight-c++ notranslate"><div class="highlight"><pre><span></span><span class="kt">void</span><span class="w"> </span><span class="nf">matmul</span><span class="p">(</span><span class="kt">int</span><span class="w"> </span><span class="n">M</span><span class="p">,</span><span class="w"> </span><span class="kt">int</span><span class="w"> </span><span class="n">N</span><span class="p">,</span><span class="w"> </span><span class="kt">int</span><span class="w"> </span><span class="n">K</span><span class="p">,</span><span class="w"> </span><span class="kt">double</span><span class="w"> </span><span class="o">*</span><span class="n">A</span><span class="p">,</span><span class="w"> </span><span class="kt">double</span><span class="w"> </span><span class="o">*</span><span class="n">B</span><span class="p">,</span><span class="w"> </span><span class="kt">double</span><span class="w"> </span><span class="o">*</span><span class="n">C</span><span class="p">)</span><span class="w"> </span><span class="p">{</span>
<span class="cp">#pragma omp target teams distribute collapse(2) \</span>
<span class="cp">  map(to:A[0: M*K]) map(to:B[0: K*N]) map(tofrom:C[0 : M*N])</span>
<span class="w">  </span><span class="k">for</span><span class="w"> </span><span class="p">(</span><span class="kt">int</span><span class="w"> </span><span class="n">i</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="mi">0</span><span class="p">;</span><span class="w"> </span><span class="n">i</span><span class="w"> </span><span class="o">&lt;</span><span class="w"> </span><span class="n">M</span><span class="p">;</span><span class="w"> </span><span class="n">i</span><span class="o">++</span><span class="p">)</span><span class="w"> </span><span class="p">{</span>
<span class="w">    </span><span class="k">for</span><span class="w"> </span><span class="p">(</span><span class="kt">int</span><span class="w"> </span><span class="n">j</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="mi">0</span><span class="p">;</span><span class="w"> </span><span class="n">j</span><span class="w"> </span><span class="o">&lt;</span><span class="w"> </span><span class="n">N</span><span class="p">;</span><span class="w"> </span><span class="n">j</span><span class="o">++</span><span class="p">)</span><span class="w"> </span><span class="p">{</span>
<span class="w">      </span><span class="kt">double</span><span class="w"> </span><span class="n">sum</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="mf">0.0</span><span class="p">;</span>

<span class="cp">#pragma omp parallel for reduction(+:sum) default(firstprivate)</span>
<span class="w">      </span><span class="k">for</span><span class="w"> </span><span class="p">(</span><span class="kt">int</span><span class="w"> </span><span class="n">k</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="mi">0</span><span class="p">;</span><span class="w"> </span><span class="n">k</span><span class="w"> </span><span class="o">&lt;</span><span class="w"> </span><span class="n">K</span><span class="p">;</span><span class="w"> </span><span class="n">k</span><span class="o">++</span><span class="p">)</span>
<span class="w">        </span><span class="n">sum</span><span class="w"> </span><span class="o">+=</span><span class="w"> </span><span class="n">A</span><span class="p">[</span><span class="n">i</span><span class="o">*</span><span class="n">K</span><span class="w"> </span><span class="o">+</span><span class="w"> </span><span class="n">k</span><span class="p">]</span><span class="w"> </span><span class="o">*</span><span class="w"> </span><span class="n">B</span><span class="p">[</span><span class="n">k</span><span class="o">*</span><span class="n">N</span><span class="w"> </span><span class="o">+</span><span class="w"> </span><span class="n">j</span><span class="p">];</span>

<span class="w">      </span><span class="n">C</span><span class="p">[</span><span class="n">i</span><span class="o">*</span><span class="n">N</span><span class="w"> </span><span class="o">+</span><span class="w"> </span><span class="n">j</span><span class="p">]</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">sum</span><span class="p">;</span>
<span class="w">    </span><span class="p">}</span>
<span class="w">  </span><span class="p">}</span>
<span class="p">}</span>
</pre></div>
</div>
<div class="highlight-console notranslate"><div class="highlight"><pre><span></span><span class="gp">$ </span>clang++<span class="w"> </span>-fopenmp<span class="w"> </span>-fopenmp-targets<span class="o">=</span>nvptx64<span class="w"> </span>-fopenmp-version<span class="o">=</span><span class="m">51</span><span class="w"> </span>-O2<span class="w"> </span>-Rpass<span class="o">=</span>openmp-opt<span class="w"> </span>omp120.cpp
<span class="go">omp120.cpp:6:14: remark: Replaced globalized variable with 8 bytes of shared memory. [OMP111]</span>
<span class="go">     double sum = 0.0;</span>
<span class="go">            ^</span>
<span class="go">omp120.cpp:2:1: remark: Transformed generic-mode kernel to SPMD-mode. [OMP120]</span>
<span class="gp">#</span>pragma<span class="w"> </span>omp<span class="w"> </span>target<span class="w"> </span>teams<span class="w"> </span>distribute<span class="w"> </span>collapse<span class="o">(</span><span class="m">2</span><span class="o">)</span><span class="w"> </span><span class="se">\</span>
^
</pre></div>
</div>
<p>This requires guarding the store to the shared variable <code class="docutils literal notranslate"><span class="pre">sum</span></code> and the store to
the matrix <code class="docutils literal notranslate"><span class="pre">C</span></code>. This can be thought of as generating the code below.</p>
<div class="highlight-c++ notranslate"><div class="highlight"><pre><span></span><span class="kt">void</span><span class="w"> </span><span class="nf">matmul</span><span class="p">(</span><span class="kt">int</span><span class="w"> </span><span class="n">M</span><span class="p">,</span><span class="w"> </span><span class="kt">int</span><span class="w"> </span><span class="n">N</span><span class="p">,</span><span class="w"> </span><span class="kt">int</span><span class="w"> </span><span class="n">K</span><span class="p">,</span><span class="w"> </span><span class="kt">double</span><span class="w"> </span><span class="o">*</span><span class="n">A</span><span class="p">,</span><span class="w"> </span><span class="kt">double</span><span class="w"> </span><span class="o">*</span><span class="n">B</span><span class="p">,</span><span class="w"> </span><span class="kt">double</span><span class="w"> </span><span class="o">*</span><span class="n">C</span><span class="p">)</span><span class="w"> </span><span class="p">{</span>
<span class="cp">#pragma omp target teams distribute collapse(2) \</span>
<span class="cp">  map(to:A[0: M*K]) map(to:B[0: K*N]) map(tofrom:C[0 : M*N])</span>
<span class="w">  </span><span class="k">for</span><span class="w"> </span><span class="p">(</span><span class="kt">int</span><span class="w"> </span><span class="n">i</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="mi">0</span><span class="p">;</span><span class="w"> </span><span class="n">i</span><span class="w"> </span><span class="o">&lt;</span><span class="w"> </span><span class="n">M</span><span class="p">;</span><span class="w"> </span><span class="n">i</span><span class="o">++</span><span class="p">)</span><span class="w"> </span><span class="p">{</span>
<span class="w">    </span><span class="k">for</span><span class="w"> </span><span class="p">(</span><span class="kt">int</span><span class="w"> </span><span class="n">j</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="mi">0</span><span class="p">;</span><span class="w"> </span><span class="n">j</span><span class="w"> </span><span class="o">&lt;</span><span class="w"> </span><span class="n">N</span><span class="p">;</span><span class="w"> </span><span class="n">j</span><span class="o">++</span><span class="p">)</span><span class="w"> </span><span class="p">{</span>
<span class="w">    </span><span class="kt">double</span><span class="w"> </span><span class="n">sum</span><span class="p">;</span>
<span class="cp">#pragma omp parallel default(firstprivate) shared(sum)</span>
<span class="w">    </span><span class="p">{</span>
<span class="w">    </span><span class="cp">#pragma omp barrier</span>
<span class="w">    </span><span class="k">if</span><span class="w"> </span><span class="p">(</span><span class="n">omp_get_thread_num</span><span class="p">()</span><span class="w"> </span><span class="o">==</span><span class="w"> </span><span class="mi">0</span><span class="p">)</span>
<span class="w">      </span><span class="n">sum</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="mf">0.0</span><span class="p">;</span>
<span class="w">    </span><span class="cp">#pragma omp barrier</span>

<span class="cp">#pragma omp for reduction(+:sum)</span>
<span class="w">      </span><span class="k">for</span><span class="w"> </span><span class="p">(</span><span class="kt">int</span><span class="w"> </span><span class="n">k</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="mi">0</span><span class="p">;</span><span class="w"> </span><span class="n">k</span><span class="w"> </span><span class="o">&lt;</span><span class="w"> </span><span class="n">K</span><span class="p">;</span><span class="w"> </span><span class="n">k</span><span class="o">++</span><span class="p">)</span>
<span class="w">        </span><span class="n">sum</span><span class="w"> </span><span class="o">+=</span><span class="w"> </span><span class="n">A</span><span class="p">[</span><span class="n">i</span><span class="o">*</span><span class="n">K</span><span class="w"> </span><span class="o">+</span><span class="w"> </span><span class="n">k</span><span class="p">]</span><span class="w"> </span><span class="o">*</span><span class="w"> </span><span class="n">B</span><span class="p">[</span><span class="n">k</span><span class="o">*</span><span class="n">N</span><span class="w"> </span><span class="o">+</span><span class="w"> </span><span class="n">j</span><span class="p">];</span>

<span class="w">    </span><span class="cp">#pragma omp barrier</span>
<span class="w">    </span><span class="k">if</span><span class="w"> </span><span class="p">(</span><span class="n">omp_get_thread_num</span><span class="p">()</span><span class="w"> </span><span class="o">==</span><span class="w"> </span><span class="mi">0</span><span class="p">)</span>
<span class="w">      </span><span class="n">C</span><span class="p">[</span><span class="n">i</span><span class="o">*</span><span class="n">N</span><span class="w"> </span><span class="o">+</span><span class="w"> </span><span class="n">j</span><span class="p">]</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">sum</span><span class="p">;</span>
<span class="w">    </span><span class="cp">#pragma omp barrier</span>
<span class="w">    </span><span class="p">}</span>
<span class="w">    </span><span class="p">}</span>
<span class="w">  </span><span class="p">}</span>
<span class="p">}</span>
</pre></div>
</div>
</section>
<section id="diagnostic-scope">
<h2>Diagnostic Scope<a class="headerlink" href="#diagnostic-scope" title="Link to this heading">¶</a></h2>
<p>OpenMP target offloading optimization remark.</p>
</section>
</section>


            <div class="clearer"></div>
          </div>
        </div>
      </div>
        </div>
        <div class="sidebar">
          
          <h3>Table of Contents</h3>
          <ul>
<li class="toctree-l1"><a class="reference internal" href="../index.html">LLVM/OpenMP Documentation</a></li>
</ul>
<ul>
<li class="toctree-l1"><a class="reference internal" href="../design/Overview.html">OpenMP in LLVM — Design Overview</a></li>
</ul>
<ul>
<li class="toctree-l1"><a class="reference internal" href="../openacc/Overview.html">OpenACC Support</a></li>
</ul>
<ul>
<li class="toctree-l1"><a class="reference internal" href="../optimizations/Overview.html">OpenMP Optimizations in LLVM</a></li>
</ul>
<ul class="current">
<li class="toctree-l1 current"><a class="reference internal" href="OptimizationRemarks.html">OpenMP Optimization Remarks</a><ul class="current">
<li class="toctree-l2"><a class="reference internal" href="OMP100.html">Potentially unknown OpenMP target region caller <cite>[OMP100]</cite></a></li>
<li class="toctree-l2"><a class="reference internal" href="OMP101.html">Parallel region is used in unknown / unexpected ways. Will not attempt to rewrite the state machine. [OMP101]</a></li>
<li class="toctree-l2"><a class="reference internal" href="OMP102.html">Parallel region is not called from a unique kernel. Will not attempt to rewrite the state machine. [OMP102]</a></li>
<li class="toctree-l2"><a class="reference internal" href="OMP110.html">Moving globalized variable to the stack. [OMP110]</a></li>
<li class="toctree-l2"><a class="reference internal" href="OMP111.html">Replaced globalized variable with X bytes of shared memory. [OMP111]</a></li>
<li class="toctree-l2"><a class="reference internal" href="OMP112.html">Found thread data sharing on the GPU. Expect degraded performance due to data globalization. [OMP112]</a></li>
<li class="toctree-l2"><a class="reference internal" href="OMP113.html">Could not move globalized variable to the stack. Variable is potentially captured in call. Mark parameter as <cite>__attribute__((noescape))</cite> to override. [OMP113]</a></li>
<li class="toctree-l2 current"><a class="current reference internal" href="#">Transformed generic-mode kernel to SPMD-mode [OMP120]</a></li>
<li class="toctree-l2"><a class="reference internal" href="OMP121.html">Value has potential side effects preventing SPMD-mode execution. Add <cite>[[omp::assume(&quot;ompx_spmd_amenable&quot;)]]</cite> to the called function to override. [OMP121]</a></li>
<li class="toctree-l2"><a class="reference internal" href="OMP130.html">Removing unused state machine from generic-mode kernel. [OMP130]</a></li>
<li class="toctree-l2"><a class="reference internal" href="OMP131.html">Rewriting generic-mode kernel with a customized state machine. [OMP131]</a></li>
<li class="toctree-l2"><a class="reference internal" href="OMP132.html">Generic-mode kernel is executed with a customized state machine that requires a fallback. [OMP132]</a></li>
<li class="toctree-l2"><a class="reference internal" href="OMP133.html">Call may contain unknown parallel regions. Use <cite>[[omp::assume(“omp_no_parallelism”)]]</cite> to override. [OMP133]</a></li>
<li class="toctree-l2"><a class="reference internal" href="OMP140.html">Could not internalize function. Some optimizations may not be possible. [OMP140]</a></li>
<li class="toctree-l2"><a class="reference internal" href="OMP150.html">Parallel region merged with parallel region at &lt;location&gt;. [OMP150]</a></li>
<li class="toctree-l2"><a class="reference internal" href="OMP160.html">Removing parallel region with no side-effects. [OMP160]</a></li>
<li class="toctree-l2"><a class="reference internal" href="OMP170.html">OpenMP runtime call &lt;call&gt; deduplicated. [OMP170]</a></li>
<li class="toctree-l2"><a class="reference internal" href="OMP180.html">Replacing OpenMP runtime call &lt;call&gt; with &lt;value&gt;.</a></li>
<li class="toctree-l2"><a class="reference internal" href="OMP190.html">Redundant barrier eliminated. (device only)</a></li>
</ul>
</li>
</ul>
<ul>
<li class="toctree-l1"><a class="reference internal" href="../CommandLineArgumentReference.html">OpenMP Command-Line Argument Reference</a></li>
</ul>
<ul>
<li class="toctree-l1"><a class="reference internal" href="../SupportAndFAQ.html">Support, Getting Involved, and FAQ</a></li>
</ul>
<ul>
<li class="toctree-l1"><a class="reference internal" href="../ReleaseNotes.html">In-Progress ReleaseNotes</a></li>
</ul>

          <div role="search">
            <h3 style="margin-top: 1.5em;">Search</h3>
            <form class="search" action="../search.html" method="get">
                <input type="text" name="q" />
                <input type="submit" value="Go" />
            </form>
          </div>

        </div>
        <div class="clearer"></div>
      </div>
    </div>

    <div class="footer-wrapper">
      <div class="footer">
        <div class="left">
          <div role="navigation" aria-label="related navigaton">
            <a href="../index.html" title="LLVM OpenMP Documentation">HOME</a>
             |
            <a href="OMP113.html" title="Could not move globalized variable to the stack. Variable is potentially captured in call. Mark parameter as __attribute__((noescape)) to override. [OMP113]"
              >previous</a> |
            <a href="OMP121.html" title="Value has potential side effects preventing SPMD-mode execution. Add [[omp::assume(&#34;ompx_spmd_amenable&#34;)]] to the called function to override. [OMP121]"
              >next</a> |
            <a href="../genindex.html" title="General Index"
              >index</a>
          </div>
          <div role="note" aria-label="source link">
          </div>
        </div>

        <div class="right">
          
    <div class="footer" role="contentinfo">
    &#169; Copyright 2013-2025, LLVM/OpenMP.
      Last updated on 2025-08-13.
      Created using <a href="https://www.sphinx-doc.org/">Sphinx</a> 7.2.6.
    </div>
        </div>
        <div class="clearer"></div>
      </div>
    </div>

  </body>
</html>