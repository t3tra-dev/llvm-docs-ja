<!doctype html>
<html class="no-js" lang="en" data-content_root="../">
  <head><meta charset="utf-8"/>
    <meta name="viewport" content="width=device-width,initial-scale=1"/>
    <meta name="color-scheme" content="light dark"><meta name="viewport" content="width=device-width, initial-scale=1" />
<link rel="index" title="Index" href="../genindex.html" /><link rel="search" title="Search" href="../search.html" /><link rel="next" title="Symbolication" href="symbolication.html" /><link rel="prev" title="Frame and Thread Format" href="formatting.html" />

    <!-- Generated with Sphinx 7.2.6 and Furo 2024.01.29 -->
        <title>Variable Formatting - üêõ LLDB</title>
      <link rel="stylesheet" type="text/css" href="../_static/pygments.css?v=d75fae25" />
    <link rel="stylesheet" type="text/css" href="../_static/styles/furo.css?v=135e06be" />
    <link rel="stylesheet" type="text/css" href="../_static/styles/furo-extensions.css?v=36a5483c" />
    
    


<style>
  body {
    --color-code-background: #f0f0f0;
  --color-code-foreground: black;
  
  }
  @media not print {
    body[data-theme="dark"] {
      --color-code-background: #202020;
  --color-code-foreground: #d0d0d0;
  
    }
    @media (prefers-color-scheme: dark) {
      body:not([data-theme="light"]) {
        --color-code-background: #202020;
  --color-code-foreground: #d0d0d0;
  
      }
    }
  }
</style></head>
  <body>
    
    <script>
      document.body.dataset.theme = localStorage.getItem("theme") || "auto";
    </script>
    

<svg xmlns="http://www.w3.org/2000/svg" style="display: none;">
  <symbol id="svg-toc" viewBox="0 0 24 24">
    <title>Contents</title>
    <svg stroke="currentColor" fill="currentColor" stroke-width="0" viewBox="0 0 1024 1024">
      <path d="M408 442h480c4.4 0 8-3.6 8-8v-56c0-4.4-3.6-8-8-8H408c-4.4 0-8 3.6-8 8v56c0 4.4 3.6 8 8 8zm-8 204c0 4.4 3.6 8 8 8h480c4.4 0 8-3.6 8-8v-56c0-4.4-3.6-8-8-8H408c-4.4 0-8 3.6-8 8v56zm504-486H120c-4.4 0-8 3.6-8 8v56c0 4.4 3.6 8 8 8h784c4.4 0 8-3.6 8-8v-56c0-4.4-3.6-8-8-8zm0 632H120c-4.4 0-8 3.6-8 8v56c0 4.4 3.6 8 8 8h784c4.4 0 8-3.6 8-8v-56c0-4.4-3.6-8-8-8zM115.4 518.9L271.7 642c5.8 4.6 14.4.5 14.4-6.9V388.9c0-7.4-8.5-11.5-14.4-6.9L115.4 505.1a8.74 8.74 0 0 0 0 13.8z"/>
    </svg>
  </symbol>
  <symbol id="svg-menu" viewBox="0 0 24 24">
    <title>Menu</title>
    <svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 24 24" fill="none" stroke="currentColor"
      stroke-width="2" stroke-linecap="round" stroke-linejoin="round" class="feather-menu">
      <line x1="3" y1="12" x2="21" y2="12"></line>
      <line x1="3" y1="6" x2="21" y2="6"></line>
      <line x1="3" y1="18" x2="21" y2="18"></line>
    </svg>
  </symbol>
  <symbol id="svg-arrow-right" viewBox="0 0 24 24">
    <title>Expand</title>
    <svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 24 24" fill="none" stroke="currentColor"
      stroke-width="2" stroke-linecap="round" stroke-linejoin="round" class="feather-chevron-right">
      <polyline points="9 18 15 12 9 6"></polyline>
    </svg>
  </symbol>
  <symbol id="svg-sun" viewBox="0 0 24 24">
    <title>Light mode</title>
    <svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 24 24" fill="none" stroke="currentColor"
      stroke-width="1.5" stroke-linecap="round" stroke-linejoin="round" class="feather-sun">
      <circle cx="12" cy="12" r="5"></circle>
      <line x1="12" y1="1" x2="12" y2="3"></line>
      <line x1="12" y1="21" x2="12" y2="23"></line>
      <line x1="4.22" y1="4.22" x2="5.64" y2="5.64"></line>
      <line x1="18.36" y1="18.36" x2="19.78" y2="19.78"></line>
      <line x1="1" y1="12" x2="3" y2="12"></line>
      <line x1="21" y1="12" x2="23" y2="12"></line>
      <line x1="4.22" y1="19.78" x2="5.64" y2="18.36"></line>
      <line x1="18.36" y1="5.64" x2="19.78" y2="4.22"></line>
    </svg>
  </symbol>
  <symbol id="svg-moon" viewBox="0 0 24 24">
    <title>Dark mode</title>
    <svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 24 24" fill="none" stroke="currentColor"
      stroke-width="1.5" stroke-linecap="round" stroke-linejoin="round" class="icon-tabler-moon">
      <path stroke="none" d="M0 0h24v24H0z" fill="none" />
      <path d="M12 3c.132 0 .263 0 .393 0a7.5 7.5 0 0 0 7.92 12.446a9 9 0 1 1 -8.313 -12.454z" />
    </svg>
  </symbol>
  <symbol id="svg-sun-half" viewBox="0 0 24 24">
    <title>Auto light/dark mode</title>
    <svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 24 24" fill="none" stroke="currentColor"
      stroke-width="1.5" stroke-linecap="round" stroke-linejoin="round" class="icon-tabler-shadow">
      <path stroke="none" d="M0 0h24v24H0z" fill="none"/>
      <circle cx="12" cy="12" r="9" />
      <path d="M13 12h5" />
      <path d="M13 15h4" />
      <path d="M13 18h1" />
      <path d="M13 9h4" />
      <path d="M13 6h1" />
    </svg>
  </symbol>
</svg>

<input type="checkbox" class="sidebar-toggle" name="__navigation" id="__navigation">
<input type="checkbox" class="sidebar-toggle" name="__toc" id="__toc">
<label class="overlay sidebar-overlay" for="__navigation">
  <div class="visually-hidden">Hide navigation sidebar</div>
</label>
<label class="overlay toc-overlay" for="__toc">
  <div class="visually-hidden">Hide table of contents sidebar</div>
</label>



<div class="page">
  <header class="mobile-header">
    <div class="header-left">
      <label class="nav-overlay-icon" for="__navigation">
        <div class="visually-hidden">Toggle site navigation sidebar</div>
        <i class="icon"><svg><use href="#svg-menu"></use></svg></i>
      </label>
    </div>
    <div class="header-center">
      <a href="../index.html"><div class="brand">üêõ LLDB</div></a>
    </div>
    <div class="header-right">
      <div class="theme-toggle-container theme-toggle-header">
        <button class="theme-toggle">
          <div class="visually-hidden">Toggle Light / Dark / Auto color theme</div>
          <svg class="theme-icon-when-auto"><use href="#svg-sun-half"></use></svg>
          <svg class="theme-icon-when-dark"><use href="#svg-moon"></use></svg>
          <svg class="theme-icon-when-light"><use href="#svg-sun"></use></svg>
        </button>
      </div>
      <label class="toc-overlay-icon toc-header-icon" for="__toc">
        <div class="visually-hidden">Toggle table of contents sidebar</div>
        <i class="icon"><svg><use href="#svg-toc"></use></svg></i>
      </label>
    </div>
  </header>
  <aside class="sidebar-drawer">
    <div class="sidebar-container">
      
      <div class="sidebar-sticky"><a class="sidebar-brand" href="../index.html">
  
  
  <span class="sidebar-brand-text">üêõ LLDB</span>
  
</a><form class="sidebar-search-container" method="get" action="../search.html" role="search">
  <input class="sidebar-search" placeholder="Search" name="q" aria-label="Search">
  <input type="hidden" name="check_keywords" value="yes">
  <input type="hidden" name="area" value="default">
</form>
<div id="searchbox"></div><div class="sidebar-scroll"><div class="sidebar-tree">
  <p class="caption" role="heading"><span class="caption-text">Using LLDB</span></p>
<ul class="current">
<li class="toctree-l1"><a class="reference internal" href="tutorial.html">Tutorial</a></li>
<li class="toctree-l1"><a class="reference internal" href="map.html">GDB to LLDB command map</a></li>
<li class="toctree-l1"><a class="reference internal" href="formatting.html">Frame and Thread Format</a></li>
<li class="toctree-l1 current current-page"><a class="current reference internal" href="#">Variable Formatting</a></li>
<li class="toctree-l1"><a class="reference internal" href="symbolication.html">Symbolication</a></li>
<li class="toctree-l1"><a class="reference internal" href="symbols.html">Symbols on macOS</a></li>
<li class="toctree-l1"><a class="reference internal" href="remote.html">Remote Debugging</a></li>
<li class="toctree-l1"><a class="reference internal" href="intel_pt.html">Tracing with Intel Processor Trace</a></li>
<li class="toctree-l1"><a class="reference internal" href="ondemand.html">On Demand Symbols</a></li>
<li class="toctree-l1"><a class="reference internal" href="aarch64-linux.html">Using LLDB On AArch64 Linux</a></li>
<li class="toctree-l1"><a class="reference internal" href="symbolfilejson.html">JSON Symbol File Format</a></li>
<li class="toctree-l1"><a class="reference internal" href="mcp.html">Model Context Protocol (MCP)</a></li>
<li class="toctree-l1"><a class="reference internal" href="troubleshooting.html">Troubleshooting</a></li>
<li class="toctree-l1"><a class="reference internal" href="links.html">Links</a></li>
<li class="toctree-l1"><a class="reference internal" href="../man/lldb.html">Man Page</a></li>
</ul>
<p class="caption" role="heading"><span class="caption-text">Scripting LLDB</span></p>
<ul>
<li class="toctree-l1"><a class="reference internal" href="python.html">Python Scripting</a></li>
<li class="toctree-l1"><a class="reference internal" href="python-reference.html">Python Reference</a></li>
<li class="toctree-l1"><a class="reference internal" href="../python_api.html">Python API</a></li>
<li class="toctree-l1"><a class="reference internal" href="../python_extensions.html">Python Extensions</a></li>
</ul>
<p class="caption" role="heading"><span class="caption-text">Developing LLDB</span></p>
<ul>
<li class="toctree-l1"><a class="reference internal" href="../resources/overview.html">Overview</a></li>
<li class="toctree-l1"><a class="reference internal" href="../resources/contributing.html">Contributing</a></li>
<li class="toctree-l1"><a class="reference internal" href="../resources/build.html">Building</a></li>
<li class="toctree-l1"><a class="reference internal" href="../resources/test.html">Testing</a></li>
<li class="toctree-l1"><a class="reference internal" href="../resources/qemu-testing.html">Testing LLDB using QEMU</a></li>
<li class="toctree-l1"><a class="reference internal" href="../resources/debugging.html">Debugging</a></li>
<li class="toctree-l1"><a class="reference internal" href="../resources/fuzzing.html">Fuzzing</a></li>
<li class="toctree-l1"><a class="reference internal" href="../resources/sbapi.html">Scripting Bridge API</a></li>
<li class="toctree-l1"><a class="reference internal" href="../resources/dataformatters.html">Data Formatters</a></li>
<li class="toctree-l1"><a class="reference internal" href="../resources/formatterbytecode.html">Formatter Bytecode</a></li>
<li class="toctree-l1"><a class="reference internal" href="../resources/extensions.html">DWARF Extensions</a></li>
<li class="toctree-l1"><a class="reference internal" href="../resources/lldbgdbremote.html">GDB Remote Protocol Extensions</a></li>
<li class="toctree-l1"><a class="reference internal" href="../resources/lldbplatformpackets.html">LLDB Platform Packets</a></li>
<li class="toctree-l1"><a class="reference internal" href="../resources/caveats.html">Caveats</a></li>
<li class="toctree-l1"><a class="reference internal" href="../resources/projects.html">Open Projects</a></li>
<li class="toctree-l1"><a class="reference internal" href="../resources/lldbdap.html">Contributing to LLDB-DAP</a></li>
<li class="toctree-l1"><a class="reference internal" href="../resources/addinglanguagesupport.html">Adding Programming Language Support</a></li>
<li class="toctree-l1"><a class="reference external" href="https://lldb.llvm.org/cpp_reference/namespacelldb.html">Public C++ API</a></li>
<li class="toctree-l1"><a class="reference external" href="https://lldb.llvm.org/cpp_reference/index.html">Private C++ API</a></li>
</ul>
<p class="caption" role="heading"><span class="caption-text">External Links</span></p>
<ul>
<li class="toctree-l1"><a class="reference external" href="https://github.com/llvm/llvm-project">Source Code</a></li>
<li class="toctree-l1"><a class="reference external" href="https://github.com/llvm/llvm-project/releases">Releases</a></li>
<li class="toctree-l1"><a class="reference external" href="https://discord.gg/xS7Z362">Join the Discord</a></li>
<li class="toctree-l1"><a class="reference external" href="https://discord.com/channels/636084430946959380/636732809708306432">Discord Channel</a></li>
<li class="toctree-l1"><a class="reference external" href="https://discourse.llvm.org/c/subprojects/lldb/8">Discussion Forums</a></li>
<li class="toctree-l1"><a class="reference external" href="https://llvm.org/docs/DeveloperPolicy.html">Developer Policy</a></li>
<li class="toctree-l1"><a class="reference external" href="https://github.com/llvm/llvm-project/issues?q=is%3Aissue+label%3Alldb+is%3Aopen">Bug Reports</a></li>
<li class="toctree-l1"><a class="reference external" href="https://github.com/llvm/llvm-project/pulls?q=is%3Apr+label%3Alldb+is%3Aopen">Code Reviews</a></li>
</ul>

</div>
</div>

      </div>
      
    </div>
  </aside>
  <div class="main">
    <div class="content">
      <div class="article-container">
        <a href="#" class="back-to-top muted-link">
          <svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 24 24">
            <path d="M13 20h-2V8l-5.5 5.5-1.42-1.42L12 4.16l7.92 7.92-1.42 1.42L13 8v12z"></path>
          </svg>
          <span>Back to top</span>
        </a>
        <div class="content-icon-container">
          <div class="edit-this-page">
  <a class="muted-link" href="https://github.com/llvm/llvm-project/edit/main/lldb/docs/use/variable.rst" title="Edit this page">
    <svg aria-hidden="true" viewBox="0 0 24 24" stroke-width="1.5" stroke="currentColor" fill="none" stroke-linecap="round" stroke-linejoin="round">
      <path stroke="none" d="M0 0h24v24H0z" fill="none"/>
      <path d="M4 20h4l10.5 -10.5a1.5 1.5 0 0 0 -4 -4l-10.5 10.5v4" />
      <line x1="13.5" y1="6.5" x2="17.5" y2="10.5" />
    </svg>
    <span class="visually-hidden">Edit this page</span>
  </a>
</div><div class="theme-toggle-container theme-toggle-content">
            <button class="theme-toggle">
              <div class="visually-hidden">Toggle Light / Dark / Auto color theme</div>
              <svg class="theme-icon-when-auto"><use href="#svg-sun-half"></use></svg>
              <svg class="theme-icon-when-dark"><use href="#svg-moon"></use></svg>
              <svg class="theme-icon-when-light"><use href="#svg-sun"></use></svg>
            </button>
          </div>
          <label class="toc-overlay-icon toc-content-icon" for="__toc">
            <div class="visually-hidden">Toggle table of contents sidebar</div>
            <i class="icon"><svg><use href="#svg-toc"></use></svg></i>
          </label>
        </div>
        <article role="main">
          <section id="variable-formatting">
<h1>Variable Formatting<a class="headerlink" href="#variable-formatting" title="Link to this heading">#</a></h1>
<p>LLDB has a data formatters subsystem that allows users to define custom display
options for their variables.</p>
<p>Usually, when you type <code class="docutils literal notranslate"><span class="pre">frame</span> <span class="pre">variable</span></code> or run some expression LLDB will
automatically choose the way to display your results on a per-type basis, as in
the following example:</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="p">(</span><span class="n">lldb</span><span class="p">)</span> <span class="n">frame</span> <span class="n">variable</span>
<span class="p">(</span><span class="n">uint8_t</span><span class="p">)</span> <span class="n">x</span> <span class="o">=</span> <span class="s1">&#39;a&#39;</span>
<span class="p">(</span><span class="n">intptr_t</span><span class="p">)</span> <span class="n">y</span> <span class="o">=</span> <span class="mi">124752287</span>
</pre></div>
</div>
<p>Note: <code class="docutils literal notranslate"><span class="pre">frame</span> <span class="pre">variable</span></code> without additional arguments prints the list of
variables of the current frame.</p>
<p>However, in certain cases, you may want to associate a different style to the
display for certain datatypes. To do so, you need to give hints to the debugger
as to how variables should be displayed. The LLDB type command allows you to do
just that.</p>
<p>Using it you can change your visualization to look like this:</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="p">(</span><span class="n">lldb</span><span class="p">)</span> <span class="n">frame</span> <span class="n">variable</span>
<span class="p">(</span><span class="n">uint8_t</span><span class="p">)</span> <span class="n">x</span> <span class="o">=</span> <span class="nb">chr</span><span class="o">=</span><span class="s1">&#39;a&#39;</span> <span class="n">dec</span><span class="o">=</span><span class="mi">65</span> <span class="nb">hex</span><span class="o">=</span><span class="mh">0x41</span>
<span class="p">(</span><span class="n">intptr_t</span><span class="p">)</span> <span class="n">y</span> <span class="o">=</span> <span class="mh">0x76f919f</span>
</pre></div>
</div>
<p>In addition, some data structures can encode their data in a way that is not
easily readable to the user, in which case a data formatter can be used to
show the data in a human readable way. For example, without a formatter,
printing a <code class="docutils literal notranslate"><span class="pre">std::deque&lt;int&gt;</span></code> with the elements <code class="docutils literal notranslate"><span class="pre">{2,</span> <span class="pre">3,</span> <span class="pre">4,</span> <span class="pre">5,</span> <span class="pre">6}</span></code> would
result in something like:</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span>(lldb) frame variable a_deque
(std::deque&lt;Foo, std::allocator&lt;int&gt; &gt;) $0 = {
   std::_Deque_base&lt;Foo, std::allocator&lt;int&gt; &gt; = {
      _M_impl = {
         _M_map = 0x000000000062ceb0
         _M_map_size = 8
         _M_start = {
            _M_cur = 0x000000000062cf00
            _M_first = 0x000000000062cf00
            _M_last = 0x000000000062d2f4
            _M_node = 0x000000000062cec8
         }
         _M_finish = {
            _M_cur = 0x000000000062d300
            _M_first = 0x000000000062d300
            _M_last = 0x000000000062d6f4
            _M_node = 0x000000000062ced0
         }
      }
   }
}
</pre></div>
</div>
<p>which is very hard to make sense of.</p>
<p>Note: <code class="docutils literal notranslate"><span class="pre">frame</span> <span class="pre">variable</span> <span class="pre">&lt;var&gt;</span></code> prints out the variable <code class="docutils literal notranslate"><span class="pre">&lt;var&gt;</span></code> in the current
frame.</p>
<p>On the other hand, a proper formatter is able to produce the following output:</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span>(lldb) frame variable a_deque
(std::deque&lt;Foo, std::allocator&lt;int&gt; &gt;) $0 = size=5 {
   [0] = 2
   [1] = 3
   [2] = 4
   [3] = 5
   [4] = 6
}
</pre></div>
</div>
<p>which is what the user would expect from a good debugger.</p>
<p>Note: you can also use <code class="docutils literal notranslate"><span class="pre">v</span> <span class="pre">&lt;var&gt;</span></code> instead of <code class="docutils literal notranslate"><span class="pre">frame</span> <span class="pre">variable</span> <span class="pre">&lt;var&gt;</span></code>.</p>
<p>It‚Äôs worth mentioning that the <code class="docutils literal notranslate"><span class="pre">size=5</span></code> string is produced by a summary
provider and the list of children is produced by a synthetic child provider.
More information about these providers is available later in this document.</p>
<p>There are several features related to data visualization: formats, summaries,
filters, synthetic children.</p>
<p>To reflect this, the type command has five subcommands:</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="nb">type</span> <span class="nb">format</span>
<span class="nb">type</span> <span class="n">summary</span>
<span class="nb">type</span> <span class="nb">filter</span>
<span class="nb">type</span> <span class="n">synthetic</span>
<span class="nb">type</span> <span class="n">category</span>
</pre></div>
</div>
<p>These commands are meant to bind printing options to types. When variables are
printed, LLDB will first check if custom printing options have been associated
to a variable‚Äôs type and, if so, use them instead of picking the default
choices.</p>
<p>Each of the commands (except <code class="docutils literal notranslate"><span class="pre">type</span> <span class="pre">category</span></code>) has four subcommands available:</p>
<ul class="simple">
<li><p><code class="docutils literal notranslate"><span class="pre">add</span></code>: associates a new printing option to one or more types</p></li>
<li><p><code class="docutils literal notranslate"><span class="pre">delete</span></code>: deletes an existing association</p></li>
<li><p><code class="docutils literal notranslate"><span class="pre">list</span></code>: provides a listing of all associations</p></li>
<li><p><code class="docutils literal notranslate"><span class="pre">clear</span></code>: deletes all associations</p></li>
</ul>
<section id="type-format">
<h2>Type Format<a class="headerlink" href="#type-format" title="Link to this heading">#</a></h2>
<p>Type formats enable you to quickly override the default format for displaying
primitive types (the usual basic C/C++/ObjC types: int, float, char, ‚Ä¶).</p>
<p>If for some reason you want all int variables in your program to print out as
hex, you can add a format to the int type.</p>
<p>This is done by typing</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="p">(</span><span class="n">lldb</span><span class="p">)</span> <span class="nb">type</span> <span class="nb">format</span> <span class="n">add</span> <span class="o">--</span><span class="nb">format</span> <span class="nb">hex</span> <span class="nb">int</span>
</pre></div>
</div>
<p>at the LLDB command line.</p>
<p>The <code class="docutils literal notranslate"><span class="pre">--format</span></code> (which you can shorten to -f) option accepts a <a class="reference internal" href="#format-name">format
name</a>. Then, you provide one or more types to which you want the
new format applied.</p>
<p>A frequent scenario is that your program has a typedef for a numeric type that
you know represents something that must be printed in a certain way. Again, you
can add a format just to that typedef by using type format add with the name
alias.</p>
<p>But things can quickly get hierarchical. Let‚Äôs say you have a situation like
the following:</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="n">typedef</span> <span class="nb">int</span> <span class="n">A</span><span class="p">;</span>
<span class="n">typedef</span> <span class="n">A</span> <span class="n">B</span><span class="p">;</span>
<span class="n">typedef</span> <span class="n">B</span> <span class="n">C</span><span class="p">;</span>
<span class="n">typedef</span> <span class="n">C</span> <span class="n">D</span><span class="p">;</span>
</pre></div>
</div>
<p>and you want to show all A‚Äôs as hex, all C‚Äôs as byte arrays and leave the
defaults untouched for other types (albeit its contrived look, the example is
far from unrealistic in large software systems).</p>
<p>If you simply type</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="p">(</span><span class="n">lldb</span><span class="p">)</span> <span class="nb">type</span> <span class="nb">format</span> <span class="n">add</span> <span class="o">-</span><span class="n">f</span> <span class="nb">hex</span> <span class="n">A</span>
<span class="p">(</span><span class="n">lldb</span><span class="p">)</span> <span class="nb">type</span> <span class="nb">format</span> <span class="n">add</span> <span class="o">-</span><span class="n">f</span> <span class="n">uint8_t</span><span class="p">[]</span> <span class="n">C</span>
</pre></div>
</div>
<p>values of type B will be shown as hex and values of type D as byte arrays, as in:</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="p">(</span><span class="n">lldb</span><span class="p">)</span> <span class="n">frame</span> <span class="n">variable</span> <span class="o">-</span><span class="n">T</span>
<span class="p">(</span><span class="n">A</span><span class="p">)</span> <span class="n">a</span> <span class="o">=</span> <span class="mh">0x00000001</span>
<span class="p">(</span><span class="n">B</span><span class="p">)</span> <span class="n">b</span> <span class="o">=</span> <span class="mh">0x00000002</span>
<span class="p">(</span><span class="n">C</span><span class="p">)</span> <span class="n">c</span> <span class="o">=</span> <span class="p">{</span><span class="mh">0x03</span> <span class="mh">0x00</span> <span class="mh">0x00</span> <span class="mh">0x00</span><span class="p">}</span>
<span class="p">(</span><span class="n">D</span><span class="p">)</span> <span class="n">d</span> <span class="o">=</span> <span class="p">{</span><span class="mh">0x04</span> <span class="mh">0x00</span> <span class="mh">0x00</span> <span class="mh">0x00</span><span class="p">}</span>
</pre></div>
</div>
<p>This is because by default LLDB cascades formats through typedef chains. In
order to avoid that you can use the option -C no to prevent cascading, thus
making the two commands required to achieve your goal:</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="p">(</span><span class="n">lldb</span><span class="p">)</span> <span class="nb">type</span> <span class="nb">format</span> <span class="n">add</span> <span class="o">-</span><span class="n">C</span> <span class="n">no</span> <span class="o">-</span><span class="n">f</span> <span class="nb">hex</span> <span class="n">A</span>
<span class="p">(</span><span class="n">lldb</span><span class="p">)</span> <span class="nb">type</span> <span class="nb">format</span> <span class="n">add</span> <span class="o">-</span><span class="n">C</span> <span class="n">no</span> <span class="o">-</span><span class="n">f</span> <span class="n">uint8_t</span><span class="p">[]</span> <span class="n">C</span>
</pre></div>
</div>
<p>which provides the desired output:</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="p">(</span><span class="n">lldb</span><span class="p">)</span> <span class="n">frame</span> <span class="n">variable</span> <span class="o">-</span><span class="n">T</span>
<span class="p">(</span><span class="n">A</span><span class="p">)</span> <span class="n">a</span> <span class="o">=</span> <span class="mh">0x00000001</span>
<span class="p">(</span><span class="n">B</span><span class="p">)</span> <span class="n">b</span> <span class="o">=</span> <span class="mi">2</span>
<span class="p">(</span><span class="n">C</span><span class="p">)</span> <span class="n">c</span> <span class="o">=</span> <span class="p">{</span><span class="mh">0x03</span> <span class="mh">0x00</span> <span class="mh">0x00</span> <span class="mh">0x00</span><span class="p">}</span>
<span class="p">(</span><span class="n">D</span><span class="p">)</span> <span class="n">d</span> <span class="o">=</span> <span class="mi">4</span>
</pre></div>
</div>
<p>Note, that qualifiers such as const and volatile will be stripped when matching types for example:</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="p">(</span><span class="n">lldb</span><span class="p">)</span> <span class="n">frame</span> <span class="n">var</span> <span class="n">x</span> <span class="n">y</span> <span class="n">z</span>
<span class="p">(</span><span class="nb">int</span><span class="p">)</span> <span class="n">x</span> <span class="o">=</span> <span class="mi">1</span>
<span class="p">(</span><span class="n">const</span> <span class="nb">int</span><span class="p">)</span> <span class="n">y</span> <span class="o">=</span> <span class="mi">2</span>
<span class="p">(</span><span class="n">volatile</span> <span class="nb">int</span><span class="p">)</span> <span class="n">z</span> <span class="o">=</span> <span class="mi">4</span>
<span class="p">(</span><span class="n">lldb</span><span class="p">)</span> <span class="nb">type</span> <span class="nb">format</span> <span class="n">add</span> <span class="o">-</span><span class="n">f</span> <span class="nb">hex</span> <span class="nb">int</span>
<span class="p">(</span><span class="n">lldb</span><span class="p">)</span> <span class="n">frame</span> <span class="n">var</span> <span class="n">x</span> <span class="n">y</span> <span class="n">z</span>
<span class="p">(</span><span class="nb">int</span><span class="p">)</span> <span class="n">x</span> <span class="o">=</span> <span class="mh">0x00000001</span>
<span class="p">(</span><span class="n">const</span> <span class="nb">int</span><span class="p">)</span> <span class="n">y</span> <span class="o">=</span> <span class="mh">0x00000002</span>
<span class="p">(</span><span class="n">volatile</span> <span class="nb">int</span><span class="p">)</span> <span class="n">z</span> <span class="o">=</span> <span class="mh">0x00000004</span>
</pre></div>
</div>
<p>Two additional options that you will want to look at are ‚Äìskip-pointers (-p)
and ‚Äìskip-references (-r). These two options prevent LLDB from applying a
format for type T to values of type T* and T&amp; respectively.</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="p">(</span><span class="n">lldb</span><span class="p">)</span> <span class="nb">type</span> <span class="nb">format</span> <span class="n">add</span> <span class="o">-</span><span class="n">f</span> <span class="n">float32</span><span class="p">[]</span> <span class="nb">int</span>
<span class="p">(</span><span class="n">lldb</span><span class="p">)</span> <span class="n">frame</span> <span class="n">variable</span> <span class="n">pointer</span> <span class="o">*</span><span class="n">pointer</span> <span class="o">-</span><span class="n">T</span>
<span class="p">(</span><span class="nb">int</span> <span class="o">*</span><span class="p">)</span> <span class="n">pointer</span> <span class="o">=</span> <span class="p">{</span><span class="mf">1.46991e-39</span> <span class="mf">1.4013e-45</span><span class="p">}</span>
<span class="p">(</span><span class="nb">int</span><span class="p">)</span> <span class="o">*</span><span class="n">pointer</span> <span class="o">=</span> <span class="p">{</span><span class="mf">1.53302e-42</span><span class="p">}</span>
<span class="p">(</span><span class="n">lldb</span><span class="p">)</span> <span class="nb">type</span> <span class="nb">format</span> <span class="n">add</span> <span class="o">-</span><span class="n">f</span> <span class="n">float32</span><span class="p">[]</span> <span class="nb">int</span> <span class="o">-</span><span class="n">p</span>
<span class="p">(</span><span class="n">lldb</span><span class="p">)</span> <span class="n">frame</span> <span class="n">variable</span> <span class="n">pointer</span> <span class="o">*</span><span class="n">pointer</span> <span class="o">-</span><span class="n">T</span>
<span class="p">(</span><span class="nb">int</span> <span class="o">*</span><span class="p">)</span> <span class="n">pointer</span> <span class="o">=</span> <span class="mh">0x0000000100100180</span>
<span class="p">(</span><span class="nb">int</span><span class="p">)</span> <span class="o">*</span><span class="n">pointer</span> <span class="o">=</span> <span class="p">{</span><span class="mf">1.53302e-42</span><span class="p">}</span>
</pre></div>
</div>
<p>While they can be applied to pointers and references, formats will make no
attempt to dereference the pointer and extract the value before applying the
format, which means you are effectively formatting the address stored in the
pointer rather than the pointee value. For this reason, you may want to use the
-p option when defining formats.</p>
<p>If you need to delete a custom format simply type type format delete followed
by the name of the type to which the format applies.Even if you defined the
same format for multiple types on the same command, type format delete will
only remove the format for the type name passed as argument.</p>
<p>To delete ALL formats, use <code class="docutils literal notranslate"><span class="pre">type</span> <span class="pre">format</span> <span class="pre">clear</span></code>. To see all the formats
defined, use type format list.</p>
<p>If all you need to do, however, is display one variable in a custom format,
while leaving the others of the same type untouched, you can simply type:</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="p">(</span><span class="n">lldb</span><span class="p">)</span> <span class="n">frame</span> <span class="n">variable</span> <span class="n">counter</span> <span class="o">-</span><span class="n">f</span> <span class="nb">hex</span>
</pre></div>
</div>
<p>This has the effect of displaying the value of counter as an hexadecimal
number, and will keep showing it this way until you either pick a different
format or till you let your program run again.</p>
<p>Finally, this is a list of formatting options available out of which you can
pick:</p>
<div class="table-wrapper docutils container" id="format-name">
<table class="docutils align-default" id="format-name">
<tbody>
<tr class="row-odd"><td><p><strong>Format name</strong></p></td>
<td><p><strong>Abbreviation</strong></p></td>
<td><p><strong>Description</strong></p></td>
</tr>
<tr class="row-even"><td><p><code class="docutils literal notranslate"><span class="pre">default</span></code></p></td>
<td></td>
<td><p>the default LLDB algorithm is used to pick a format</p></td>
</tr>
<tr class="row-odd"><td><p><code class="docutils literal notranslate"><span class="pre">boolean</span></code></p></td>
<td><p>B</p></td>
<td><p>show this as a true/false boolean, using the customary rule that 0 is
false and everything else is true</p></td>
</tr>
<tr class="row-even"><td><p><code class="docutils literal notranslate"><span class="pre">binary</span></code></p></td>
<td><p>b</p></td>
<td><p>show this as a sequence of bits</p></td>
</tr>
<tr class="row-odd"><td><p><code class="docutils literal notranslate"><span class="pre">bytes</span></code></p></td>
<td><p>y</p></td>
<td><p>show the bytes one after the other</p></td>
</tr>
<tr class="row-even"><td><p><code class="docutils literal notranslate"><span class="pre">bytes</span> <span class="pre">with</span> <span class="pre">ASCII</span></code></p></td>
<td><p>Y</p></td>
<td><p>show the bytes, but try to display them as ASCII characters as well</p></td>
</tr>
<tr class="row-odd"><td><p><code class="docutils literal notranslate"><span class="pre">character</span></code></p></td>
<td><p>c</p></td>
<td><p>show the bytes as ASCII characters</p></td>
</tr>
<tr class="row-even"><td><p><code class="docutils literal notranslate"><span class="pre">printable</span> <span class="pre">character</span></code></p></td>
<td><p>C</p></td>
<td><p>show the bytes as printable ASCII characters</p></td>
</tr>
<tr class="row-odd"><td><p><code class="docutils literal notranslate"><span class="pre">complex</span> <span class="pre">float</span></code></p></td>
<td><p>F</p></td>
<td><p>interpret this value as the real and imaginary part of a complex
floating-point number</p></td>
</tr>
<tr class="row-even"><td><p><code class="docutils literal notranslate"><span class="pre">c-string</span></code></p></td>
<td><p>s</p></td>
<td><p>show this as a 0-terminated C string</p></td>
</tr>
<tr class="row-odd"><td><p><code class="docutils literal notranslate"><span class="pre">decimal</span></code></p></td>
<td><p>d</p></td>
<td><p>show this as a signed integer number (this does not perform a cast, it
simply shows the bytes as  an integer with sign)</p></td>
</tr>
<tr class="row-even"><td><p><code class="docutils literal notranslate"><span class="pre">enumeration</span></code></p></td>
<td><p>E</p></td>
<td><p>show this as an enumeration, printing the
value‚Äôs name if available or the integer value otherwise</p></td>
</tr>
<tr class="row-odd"><td><p><code class="docutils literal notranslate"><span class="pre">hex</span></code></p></td>
<td><p>x</p></td>
<td><p>show this as in hexadecimal notation (this does
not perform a cast, it simply shows the bytes as hex)</p></td>
</tr>
<tr class="row-even"><td><p><code class="docutils literal notranslate"><span class="pre">float</span></code></p></td>
<td><p>f</p></td>
<td><p>show this as a floating-point number (this does not perform a cast, it
simply interprets the bytes as an IEEE754 floating-point value)</p></td>
</tr>
<tr class="row-odd"><td><p><code class="docutils literal notranslate"><span class="pre">octal</span></code></p></td>
<td><p>o</p></td>
<td><p>show this in octal notation</p></td>
</tr>
<tr class="row-even"><td><p><code class="docutils literal notranslate"><span class="pre">OSType</span></code></p></td>
<td><p>O</p></td>
<td><p>show this as a MacOS OSType</p></td>
</tr>
<tr class="row-odd"><td><p><code class="docutils literal notranslate"><span class="pre">unicode16</span></code></p></td>
<td><p>U</p></td>
<td><p>show this as UTF-16 characters</p></td>
</tr>
<tr class="row-even"><td><p><code class="docutils literal notranslate"><span class="pre">unicode32</span></code></p></td>
<td></td>
<td><p>show this as UTF-32 characters</p></td>
</tr>
<tr class="row-odd"><td><p><code class="docutils literal notranslate"><span class="pre">unsigned</span> <span class="pre">decimal</span></code></p></td>
<td><p>u</p></td>
<td><p>show this as an unsigned integer number (this does not perform a cast,
it simply shows the bytes as unsigned integer)</p></td>
</tr>
<tr class="row-even"><td><p><code class="docutils literal notranslate"><span class="pre">pointer</span></code></p></td>
<td><p>p</p></td>
<td><p>show this as a native pointer (unless this is really a pointer, the
resulting address will probably be invalid)</p></td>
</tr>
<tr class="row-odd"><td><p><code class="docutils literal notranslate"><span class="pre">char[]</span></code></p></td>
<td></td>
<td><p>show this as an array of characters</p></td>
</tr>
<tr class="row-even"><td><p><code class="docutils literal notranslate"><span class="pre">int8_t[],</span> <span class="pre">uint8_t[]</span></code>
<code class="docutils literal notranslate"><span class="pre">int16_t[],</span> <span class="pre">uint16_t[]</span></code>
<code class="docutils literal notranslate"><span class="pre">int32_t[],</span> <span class="pre">uint32_t[]</span></code>
<code class="docutils literal notranslate"><span class="pre">int64_t[],</span> <span class="pre">uint64_t[]</span></code>
<code class="docutils literal notranslate"><span class="pre">uint128_t[]</span></code></p></td>
<td></td>
<td><p>show this as an array of the corresponding integer type</p></td>
</tr>
<tr class="row-odd"><td><p><code class="docutils literal notranslate"><span class="pre">float32[],</span> <span class="pre">float64[]</span></code></p></td>
<td></td>
<td><dl class="simple">
<dt>show this as an array of the corresponding</dt><dd><p>floating-point type</p>
</dd>
</dl>
</td>
</tr>
<tr class="row-even"><td><p><code class="docutils literal notranslate"><span class="pre">complex</span> <span class="pre">integer</span></code></p></td>
<td><p>I</p></td>
<td><p>interpret this value as the real and imaginary part of a complex integer
number</p></td>
</tr>
<tr class="row-odd"><td><p><code class="docutils literal notranslate"><span class="pre">character</span> <span class="pre">array</span></code></p></td>
<td><p>a</p></td>
<td><p>show this as a character array</p></td>
</tr>
<tr class="row-even"><td><p><code class="docutils literal notranslate"><span class="pre">address</span></code></p></td>
<td><p>A</p></td>
<td><p>show this as an address target (symbol/file/line + offset), possibly
also the string this address is pointing to</p></td>
</tr>
<tr class="row-odd"><td><p><code class="docutils literal notranslate"><span class="pre">hex</span> <span class="pre">float</span></code></p></td>
<td></td>
<td><p>show this as hexadecimal floating point</p></td>
</tr>
<tr class="row-even"><td><p><code class="docutils literal notranslate"><span class="pre">instruction</span></code></p></td>
<td><p>i</p></td>
<td><p>show this as an disassembled opcode</p></td>
</tr>
<tr class="row-odd"><td><p><code class="docutils literal notranslate"><span class="pre">void</span></code></p></td>
<td><p>v</p></td>
<td><p>don‚Äôt show anything</p></td>
</tr>
</tbody>
</table>
</div>
</section>
<section id="type-summary">
<h2>Type Summary<a class="headerlink" href="#type-summary" title="Link to this heading">#</a></h2>
<p>Type formats work by showing a different kind of display for the value of a
variable. However, they only work for basic types. When you want to display a
class or struct in a custom format, you cannot do that using formats.</p>
<p>A different feature, type summaries, works by extracting information from
classes, structures, ‚Ä¶ (aggregate types) and arranging it in a user-defined
format, as in the following example:</p>
<p>before adding a summary‚Ä¶</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="p">(</span><span class="n">lldb</span><span class="p">)</span> <span class="n">frame</span> <span class="n">variable</span> <span class="o">-</span><span class="n">T</span> <span class="n">one</span>
<span class="p">(</span><span class="n">i_am_cool</span><span class="p">)</span> <span class="n">one</span> <span class="o">=</span> <span class="p">{</span>
   <span class="p">(</span><span class="nb">int</span><span class="p">)</span> <span class="n">x</span> <span class="o">=</span> <span class="mi">3</span>
   <span class="p">(</span><span class="nb">float</span><span class="p">)</span> <span class="n">y</span> <span class="o">=</span> <span class="mf">3.14159</span>
   <span class="p">(</span><span class="n">char</span><span class="p">)</span> <span class="n">z</span> <span class="o">=</span> <span class="s1">&#39;E&#39;</span>
<span class="p">}</span>
</pre></div>
</div>
<p>after adding a summary‚Ä¶</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="p">(</span><span class="n">lldb</span><span class="p">)</span> <span class="n">frame</span> <span class="n">variable</span> <span class="n">one</span>
<span class="p">(</span><span class="n">i_am_cool</span><span class="p">)</span> <span class="n">one</span> <span class="o">=</span> <span class="nb">int</span> <span class="o">=</span> <span class="mi">3</span><span class="p">,</span> <span class="nb">float</span> <span class="o">=</span> <span class="mf">3.14159</span><span class="p">,</span> <span class="n">char</span> <span class="o">=</span> <span class="mi">69</span>
</pre></div>
</div>
<p>There are two ways to use type summaries: the first one is to bind a summary
string to the type; the second is to write a Python script that returns the
string to be used as summary. Both options are enabled by the type summary add
command.</p>
<p>The command to obtain the output shown in the example is:</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="p">(</span><span class="n">lldb</span><span class="p">)</span> <span class="nb">type</span> <span class="n">summary</span> <span class="n">add</span> <span class="o">--</span><span class="n">summary</span><span class="o">-</span><span class="n">string</span> <span class="s2">&quot;int = $</span><span class="si">{var.x}</span><span class="s2">, float = $</span><span class="si">{var.y}</span><span class="s2">, char = ${var.z</span><span class="si">%u</span><span class="s2">}&quot;</span> <span class="n">i_am_cool</span>
</pre></div>
</div>
<p>Initially, we will focus on summary strings, and then describe the Python
binding mechanism.</p>
</section>
<section id="summary-format-matching-on-pointers">
<h2>Summary Format Matching On Pointers<a class="headerlink" href="#summary-format-matching-on-pointers" title="Link to this heading">#</a></h2>
<p>A summary formatter for a type <code class="docutils literal notranslate"><span class="pre">T</span></code> might or might not be appropriate to use
for pointers to that type. If the formatter is only appropriate for the type and
not its pointers, use the <code class="docutils literal notranslate"><span class="pre">-p</span></code> option to restrict it to match SBValues of type
<code class="docutils literal notranslate"><span class="pre">T</span></code>. If you want the formatter to also match pointers to the type, you can use
the <code class="docutils literal notranslate"><span class="pre">-d</span></code> option to specify how many pointer layers the formatter should match.
The default value is 1, so if you don‚Äôt specify <code class="docutils literal notranslate"><span class="pre">-p</span></code> or <code class="docutils literal notranslate"><span class="pre">-d</span></code>, your formatter
will be used on SBValues of type <code class="docutils literal notranslate"><span class="pre">T</span></code> and <code class="docutils literal notranslate"><span class="pre">T*</span></code>. If you want to also match
<code class="docutils literal notranslate"><span class="pre">T**</span></code> set <code class="docutils literal notranslate"><span class="pre">-d</span></code> to 2, etc. In all cases, the SBValue passed to the summary
formatter will be the matched ValueObject. lldb doesn‚Äôt dereference the matched
value down to the SBValue of type <code class="docutils literal notranslate"><span class="pre">T</span></code> before passing it to your formatter.</p>
</section>
<section id="summary-strings">
<h2>Summary Strings<a class="headerlink" href="#summary-strings" title="Link to this heading">#</a></h2>
<p>Summary strings are written using a simple control language, exemplified by the
snippet above. A summary string contains a sequence of tokens that are
processed by LLDB to generate the summary.</p>
<p>Summary strings can contain plain text, control characters and special
variables that have access to information about the current object and the
overall program state.</p>
<p>Plain text is any sequence of characters that doesn‚Äôt contain a <code class="docutils literal notranslate"><span class="pre">{</span></code>, <code class="docutils literal notranslate"><span class="pre">}</span></code>, <code class="docutils literal notranslate"><span class="pre">$</span></code>,
or <code class="docutils literal notranslate"><span class="pre">\</span></code> character, which are the syntax control characters.</p>
<p>The special variables are found in between a ‚Äú${‚Äù prefix, and end with a ‚Äú}‚Äù
suffix. Variables can be a simple name or they can refer to complex objects
that have subitems themselves. In other words, a variable looks like
<code class="docutils literal notranslate"><span class="pre">${object}</span></code> or <code class="docutils literal notranslate"><span class="pre">${object.child.otherchild}</span></code>. A variable can also be
prefixed or suffixed with other symbols meant to change the way its value is
handled. An example is <code class="docutils literal notranslate"><span class="pre">${*var.int_pointer[0-3]}</span></code>.</p>
<p>Basically, the syntax is the same one described Frame and Thread Formatting
plus additional symbols specific for summary strings. The main of them is
${var, which is used refer to the variable that a summary is being created for.</p>
<p>The simplest thing you can do is grab a member variable of a class or structure
by typing its expression path. In the previous example, the expression path for
the field float y is simply .y. Thus, to ask the summary string to display y
you would type ${var.y}.</p>
<p>If you have code like the following:</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="n">struct</span> <span class="n">A</span> <span class="p">{</span>
   <span class="nb">int</span> <span class="n">x</span><span class="p">;</span>
   <span class="nb">int</span> <span class="n">y</span><span class="p">;</span>
<span class="p">};</span>
<span class="n">struct</span> <span class="n">B</span> <span class="p">{</span>
   <span class="n">A</span> <span class="n">x</span><span class="p">;</span>
   <span class="n">A</span> <span class="n">y</span><span class="p">;</span>
   <span class="nb">int</span> <span class="o">*</span><span class="n">z</span><span class="p">;</span>
<span class="p">};</span>
</pre></div>
</div>
<p>the expression path for the y member of the x member of an object of type B
would be .x.y and you would type <code class="docutils literal notranslate"><span class="pre">${var.x.y}</span></code> to display it in a summary
string for type B.</p>
<p>By default, a summary defined for type T, also works for types T* and T&amp; (you
can disable this behavior if desired). For this reason, expression paths do not
differentiate between . and -&gt;, and the above expression path .x.y would be
just as good if you were displaying a B*, or even if the actual definition of B
were:</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="n">struct</span> <span class="n">B</span> <span class="p">{</span>
   <span class="n">A</span> <span class="o">*</span><span class="n">x</span><span class="p">;</span>
   <span class="n">A</span> <span class="n">y</span><span class="p">;</span>
   <span class="nb">int</span> <span class="o">*</span><span class="n">z</span><span class="p">;</span>
<span class="p">};</span>
</pre></div>
</div>
<p>This is unlike the behavior of frame variable which, on the contrary, will
enforce the distinction. As hinted above, the rationale for this choice is that
waiving this distinction enables you to write a summary string once for type T
and use it for both T and T* instances. As a summary string is mostly about
extracting nested members‚Äô information, a pointer to an object is just as good
as the object itself for the purpose.</p>
<p>If you need to access the value of the integer pointed to by B::z, you cannot
simply say ${var.z} because that symbol refers to the pointer z. In order to
dereference it and get the pointed value, you should say <code class="docutils literal notranslate"><span class="pre">${*var.z}</span></code>. The
<code class="docutils literal notranslate"><span class="pre">${*var</span></code> tells LLDB to get the object that the expression paths leads to, and
then dereference it. In this example is it equivalent to <code class="docutils literal notranslate"><span class="pre">*(bObject.z)</span></code> in
C/C++ syntax. Because <code class="docutils literal notranslate"><span class="pre">.</span></code> and <code class="docutils literal notranslate"><span class="pre">-&gt;</span></code> operators can both be used, there is no
need to have dereferences in the middle of an expression path (e.g. you do not
need to type <code class="docutils literal notranslate"><span class="pre">${*(var.x).x}</span></code>) to read A::x as contained in <code class="docutils literal notranslate"><span class="pre">*(B::x)</span></code>. To
achieve that effect you can simply write <code class="docutils literal notranslate"><span class="pre">${var.x-&gt;x}</span></code>, or even
<code class="docutils literal notranslate"><span class="pre">${var.x.x}</span></code>. The <code class="docutils literal notranslate"><span class="pre">*</span></code> operator only binds to the result of the whole
expression path, rather than piecewise, and there is no way to use parentheses
to change that behavior.</p>
<p>Of course, a summary string can contain more than one ${var specifier, and can
use <code class="docutils literal notranslate"><span class="pre">${var</span></code> and <code class="docutils literal notranslate"><span class="pre">${*var</span></code> specifiers together.</p>
</section>
<section id="formatting-summary-elements">
<h2>Formatting Summary Elements<a class="headerlink" href="#formatting-summary-elements" title="Link to this heading">#</a></h2>
<p>An expression path can include formatting codes. Much like the type formats
discussed previously, you can also customize the way variables are displayed in
summary strings, regardless of the format they have applied to their types. To
do that, you can use %format inside an expression path, as in ${var.x-&gt;x%u},
which would display the value of x as an unsigned integer.</p>
<p>Additionally, custom output can be achieved by using an LLVM format string,
commencing with the <code class="docutils literal notranslate"><span class="pre">:</span></code> marker. To illustrate, compare <code class="docutils literal notranslate"><span class="pre">${var.byte%x}</span></code> and
<code class="docutils literal notranslate"><span class="pre">${var.byte:x-}</span></code>. The former uses lldb‚Äôs builtin hex formatting (<code class="docutils literal notranslate"><span class="pre">x</span></code>),
which unconditionally inserts a <code class="docutils literal notranslate"><span class="pre">0x</span></code> prefix, and also zero pads the value to
match the size of the type. The latter uses <code class="docutils literal notranslate"><span class="pre">llvm::formatv</span></code> formatting
(<code class="docutils literal notranslate"><span class="pre">:x-</span></code>), and will print only the hex value, with no <code class="docutils literal notranslate"><span class="pre">0x</span></code> prefix, and no
padding. This raw control is useful when composing multiple pieces into a
larger whole.</p>
<p>You can also use some other special format markers, not available for formats
themselves, but which carry a special meaning when used in this context:</p>
<div class="table-wrapper docutils container">
<table class="docutils align-default">
<tbody>
<tr class="row-odd"><td><p><strong>Symbol</strong></p></td>
<td><p><strong>Description</strong></p></td>
</tr>
<tr class="row-even"><td><p><code class="docutils literal notranslate"><span class="pre">Symbol</span></code></p></td>
<td><p><code class="docutils literal notranslate"><span class="pre">Description</span></code></p></td>
</tr>
<tr class="row-odd"><td><p><code class="docutils literal notranslate"><span class="pre">%S</span></code></p></td>
<td><p>Use this object‚Äôs summary (the default for aggregate types)</p></td>
</tr>
<tr class="row-even"><td><p><code class="docutils literal notranslate"><span class="pre">%V</span></code></p></td>
<td><p>Use this object‚Äôs value (the default for non-aggregate types)</p></td>
</tr>
<tr class="row-odd"><td><p><code class="docutils literal notranslate"><span class="pre">%&#64;</span></code></p></td>
<td><dl class="simple">
<dt>Use a language-runtime specific description (for C++ this does nothing,</dt><dd><p>for Objective-C it calls the NSPrintForDebugger API)</p>
</dd>
</dl>
</td>
</tr>
<tr class="row-even"><td><p><code class="docutils literal notranslate"><span class="pre">%L</span></code></p></td>
<td><p>Use this object‚Äôs location (memory address, register name, ‚Ä¶)</p></td>
</tr>
<tr class="row-odd"><td><p><code class="docutils literal notranslate"><span class="pre">%#</span></code></p></td>
<td><p>Use the count of the children of this object</p></td>
</tr>
<tr class="row-even"><td><p><code class="docutils literal notranslate"><span class="pre">%T</span></code></p></td>
<td><p>Use this object‚Äôs datatype name</p></td>
</tr>
<tr class="row-odd"><td><p><code class="docutils literal notranslate"><span class="pre">%N</span></code></p></td>
<td><p>Print the variable‚Äôs basename</p></td>
</tr>
<tr class="row-even"><td><p><code class="docutils literal notranslate"><span class="pre">%&gt;</span></code></p></td>
<td><p>Print the expression path for this item</p></td>
</tr>
</tbody>
</table>
</div>
<p>Since lldb 3.7.0, you can also specify <code class="docutils literal notranslate"><span class="pre">${script.var:pythonFuncName}</span></code>.</p>
<p>It is expected that the function name you use specifies a function whose
signature is the same as a Python summary function. The return string from the
function will be placed verbatim in the output.</p>
<p>You cannot use element access, or formatting symbols, in combination with this
syntax. For example the following:</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span>${script.var.element[0]:myFunctionName%@}
</pre></div>
</div>
<p>is not valid and will cause the summary to fail to evaluate.</p>
</section>
<section id="element-inlining">
<h2>Element Inlining<a class="headerlink" href="#element-inlining" title="Link to this heading">#</a></h2>
<p>Option ‚Äìinline-children (-c) to type summary add tells LLDB not to look for a summary string, but instead to just print a listing of all the object‚Äôs children on one line.</p>
<p>As an example, given a type pair:</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="p">(</span><span class="n">lldb</span><span class="p">)</span> <span class="n">frame</span> <span class="n">variable</span> <span class="o">--</span><span class="n">show</span><span class="o">-</span><span class="n">types</span> <span class="n">a_pair</span>
<span class="p">(</span><span class="n">pair</span><span class="p">)</span> <span class="n">a_pair</span> <span class="o">=</span> <span class="p">{</span>
   <span class="p">(</span><span class="nb">int</span><span class="p">)</span> <span class="n">first</span> <span class="o">=</span> <span class="mi">1</span><span class="p">;</span>
   <span class="p">(</span><span class="nb">int</span><span class="p">)</span> <span class="n">second</span> <span class="o">=</span> <span class="mi">2</span><span class="p">;</span>
<span class="p">}</span>
</pre></div>
</div>
<p>If one types the following commands:</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="p">(</span><span class="n">lldb</span><span class="p">)</span> <span class="nb">type</span> <span class="n">summary</span> <span class="n">add</span> <span class="o">--</span><span class="n">inline</span><span class="o">-</span><span class="n">children</span> <span class="n">pair</span>
</pre></div>
</div>
<p>the output becomes:</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="p">(</span><span class="n">lldb</span><span class="p">)</span> <span class="n">frame</span> <span class="n">variable</span> <span class="n">a_pair</span>
<span class="p">(</span><span class="n">pair</span><span class="p">)</span> <span class="n">a_pair</span> <span class="o">=</span> <span class="p">(</span><span class="n">first</span><span class="o">=</span><span class="mi">1</span><span class="p">,</span> <span class="n">second</span><span class="o">=</span><span class="mi">2</span><span class="p">)</span>
</pre></div>
</div>
<p>Of course, one can obtain the same effect by typing</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="p">(</span><span class="n">lldb</span><span class="p">)</span> <span class="nb">type</span> <span class="n">summary</span> <span class="n">add</span> <span class="n">pair</span> <span class="o">--</span><span class="n">summary</span><span class="o">-</span><span class="n">string</span> <span class="s2">&quot;(first=$</span><span class="si">{var.first}</span><span class="s2">, second=$</span><span class="si">{var.second}</span><span class="s2">)&quot;</span>
</pre></div>
</div>
<p>While the final result is the same, using ‚Äìinline-children can often save
time. If one does not need to see the names of the variables, but just their
values, the option ‚Äìomit-names (-O, uppercase letter o), can be combined with
‚Äìinline-children to obtain:</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="p">(</span><span class="n">lldb</span><span class="p">)</span> <span class="n">frame</span> <span class="n">variable</span> <span class="n">a_pair</span>
<span class="p">(</span><span class="n">pair</span><span class="p">)</span> <span class="n">a_pair</span> <span class="o">=</span> <span class="p">(</span><span class="mi">1</span><span class="p">,</span> <span class="mi">2</span><span class="p">)</span>
</pre></div>
</div>
<p>which is of course the same as typing</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="p">(</span><span class="n">lldb</span><span class="p">)</span> <span class="nb">type</span> <span class="n">summary</span> <span class="n">add</span> <span class="n">pair</span> <span class="o">--</span><span class="n">summary</span><span class="o">-</span><span class="n">string</span> <span class="s2">&quot;($</span><span class="si">{var.first}</span><span class="s2">, $</span><span class="si">{var.second}</span><span class="s2">)&quot;</span>
</pre></div>
</div>
</section>
<section id="bitfields-and-array-syntax">
<h2>Bitfields And Array Syntax<a class="headerlink" href="#bitfields-and-array-syntax" title="Link to this heading">#</a></h2>
<p>Sometimes, a basic type‚Äôs value actually represents several different values
packed together in a bitfield.</p>
<p>With the classical view, there is no way to look at them. Hexadecimal display
can help, but if the bits actually span nibble boundaries, the help is limited.</p>
<p>Binary view would show it all without ambiguity, but is often too detailed and
hard to read for real-life scenarios.</p>
<p>To cope with the issue, LLDB supports native bitfield formatting in summary
strings. If your expression paths leads to a so-called scalar type (the usual
int, float, char, double, short, long, long long, double, long double and
unsigned variants), you can ask LLDB to only grab some bits out of the value
and display them in any format you like. If you only need one bit you can use
the [n], just like indexing an array. To extract multiple bits, you can use a
slice-like syntax: [n-m], e.g.</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="p">(</span><span class="n">lldb</span><span class="p">)</span> <span class="n">frame</span> <span class="n">variable</span> <span class="n">float_point</span>
<span class="p">(</span><span class="nb">float</span><span class="p">)</span> <span class="n">float_point</span> <span class="o">=</span> <span class="o">-</span><span class="mf">3.14159</span>
</pre></div>
</div>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="p">(</span><span class="n">lldb</span><span class="p">)</span> <span class="nb">type</span> <span class="n">summary</span> <span class="n">add</span> <span class="o">--</span><span class="n">summary</span><span class="o">-</span><span class="n">string</span> <span class="s2">&quot;Sign: ${var[31]%B} Exponent: ${var[30-23]</span><span class="si">%x</span><span class="s2">} Mantissa: ${var[0-22]</span><span class="si">%u</span><span class="s2">}&quot;</span> <span class="nb">float</span>
<span class="p">(</span><span class="n">lldb</span><span class="p">)</span> <span class="n">frame</span> <span class="n">variable</span> <span class="n">float_point</span>
<span class="p">(</span><span class="nb">float</span><span class="p">)</span> <span class="n">float_point</span> <span class="o">=</span> <span class="o">-</span><span class="mf">3.14159</span> <span class="n">Sign</span><span class="p">:</span> <span class="n">true</span> <span class="n">Exponent</span><span class="p">:</span> <span class="mh">0x00000080</span> <span class="n">Mantissa</span><span class="p">:</span> <span class="mi">4788184</span>
</pre></div>
</div>
<p>In this example, LLDB shows the internal representation of a float variable by
extracting bitfields out of a float object.</p>
<p>When typing a range, the extremes n and m are always included, and the order of
the indices is irrelevant.</p>
<p>LLDB also allows to use a similar syntax to display array members inside a summary string. For instance, you may want to display all arrays of a given type using a more compact notation than the default, and then just delve into individual array members that prove interesting to your debugging task. You can tell LLDB to format arrays in special ways, possibly independent of the way the array members‚Äô datatype is formatted.
e.g.</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="p">(</span><span class="n">lldb</span><span class="p">)</span> <span class="n">frame</span> <span class="n">variable</span> <span class="n">sarray</span>
<span class="p">(</span><span class="n">Simple</span> <span class="p">[</span><span class="mi">3</span><span class="p">])</span> <span class="n">sarray</span> <span class="o">=</span> <span class="p">{</span>
   <span class="p">[</span><span class="mi">0</span><span class="p">]</span> <span class="o">=</span> <span class="p">{</span>
      <span class="n">x</span> <span class="o">=</span> <span class="mi">1</span>
      <span class="n">y</span> <span class="o">=</span> <span class="mi">2</span>
      <span class="n">z</span> <span class="o">=</span> <span class="s1">&#39;</span><span class="se">\x03</span><span class="s1">&#39;</span>
   <span class="p">}</span>
   <span class="p">[</span><span class="mi">1</span><span class="p">]</span> <span class="o">=</span> <span class="p">{</span>
      <span class="n">x</span> <span class="o">=</span> <span class="mi">4</span>
      <span class="n">y</span> <span class="o">=</span> <span class="mi">5</span>
      <span class="n">z</span> <span class="o">=</span> <span class="s1">&#39;</span><span class="se">\x06</span><span class="s1">&#39;</span>
   <span class="p">}</span>
   <span class="p">[</span><span class="mi">2</span><span class="p">]</span> <span class="o">=</span> <span class="p">{</span>
      <span class="n">x</span> <span class="o">=</span> <span class="mi">7</span>
      <span class="n">y</span> <span class="o">=</span> <span class="mi">8</span>
      <span class="n">z</span> <span class="o">=</span> <span class="s1">&#39;</span><span class="se">\t</span><span class="s1">&#39;</span>
   <span class="p">}</span>
<span class="p">}</span>

<span class="p">(</span><span class="n">lldb</span><span class="p">)</span> <span class="nb">type</span> <span class="n">summary</span> <span class="n">add</span> <span class="o">--</span><span class="n">summary</span><span class="o">-</span><span class="n">string</span> <span class="s2">&quot;${var[].x}&quot;</span> <span class="s2">&quot;Simple [3]&quot;</span>

<span class="p">(</span><span class="n">lldb</span><span class="p">)</span> <span class="n">frame</span> <span class="n">variable</span> <span class="n">sarray</span>
<span class="p">(</span><span class="n">Simple</span> <span class="p">[</span><span class="mi">3</span><span class="p">])</span> <span class="n">sarray</span> <span class="o">=</span> <span class="p">[</span><span class="mi">1</span><span class="p">,</span><span class="mi">4</span><span class="p">,</span><span class="mi">7</span><span class="p">]</span>
</pre></div>
</div>
<p>The [] symbol amounts to: if var is an array and I know its size, apply this summary string to every element of the array. Here, we are asking LLDB to display .x for every element of the array, and in fact this is what happens. If you find some of those integers anomalous, you can then inspect that one item in greater detail, without the array format getting in the way:</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="p">(</span><span class="n">lldb</span><span class="p">)</span> <span class="n">frame</span> <span class="n">variable</span> <span class="n">sarray</span><span class="p">[</span><span class="mi">1</span><span class="p">]</span>
<span class="p">(</span><span class="n">Simple</span><span class="p">)</span> <span class="n">sarray</span><span class="p">[</span><span class="mi">1</span><span class="p">]</span> <span class="o">=</span> <span class="p">{</span>
   <span class="n">x</span> <span class="o">=</span> <span class="mi">4</span>
   <span class="n">y</span> <span class="o">=</span> <span class="mi">5</span>
   <span class="n">z</span> <span class="o">=</span> <span class="s1">&#39;</span><span class="se">\x06</span><span class="s1">&#39;</span>
<span class="p">}</span>
</pre></div>
</div>
<p>You can also ask LLDB to only print a subset of the array range by using the
same syntax used to extract bit for bitfields:</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="p">(</span><span class="n">lldb</span><span class="p">)</span> <span class="nb">type</span> <span class="n">summary</span> <span class="n">add</span> <span class="o">--</span><span class="n">summary</span><span class="o">-</span><span class="n">string</span> <span class="s2">&quot;$</span><span class="si">{var[1-2].x}</span><span class="s2">&quot;</span> <span class="s2">&quot;Simple [3]&quot;</span>

<span class="p">(</span><span class="n">lldb</span><span class="p">)</span> <span class="n">frame</span> <span class="n">variable</span> <span class="n">sarray</span>
<span class="p">(</span><span class="n">Simple</span> <span class="p">[</span><span class="mi">3</span><span class="p">])</span> <span class="n">sarray</span> <span class="o">=</span> <span class="p">[</span><span class="mi">4</span><span class="p">,</span><span class="mi">7</span><span class="p">]</span>
</pre></div>
</div>
<p>If you are dealing with a pointer that you know is an array, you can use this
syntax to display the elements contained in the pointed array instead of just
the pointer value. However, because pointers have no notion of their size, the
empty brackets [] operator does not work, and you must explicitly provide
higher and lower bounds.</p>
<p>In general, LLDB needs the square brackets <code class="docutils literal notranslate"><span class="pre">operator</span> <span class="pre">[]</span></code> in order to handle
arrays and pointers correctly, and for pointers it also needs a range. However,
a few special cases are defined to make your life easier:</p>
<p>you can print a 0-terminated string (C-string) using the %s format, omitting
square brackets, as in:</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="p">(</span><span class="n">lldb</span><span class="p">)</span> <span class="nb">type</span> <span class="n">summary</span> <span class="n">add</span> <span class="o">--</span><span class="n">summary</span><span class="o">-</span><span class="n">string</span> <span class="s2">&quot;${var</span><span class="si">%s</span><span class="s2">}&quot;</span> <span class="s2">&quot;char *&quot;</span>
</pre></div>
</div>
<p>This syntax works for char* as well as for char[] because LLDB can rely on the
final 0 terminator to know when the string has ended.</p>
<p>LLDB has default summary strings for char* and char[] that use this special
case. On debugger startup, the following are defined automatically:</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="p">(</span><span class="n">lldb</span><span class="p">)</span> <span class="nb">type</span> <span class="n">summary</span> <span class="n">add</span> <span class="o">--</span><span class="n">summary</span><span class="o">-</span><span class="n">string</span> <span class="s2">&quot;${var</span><span class="si">%s</span><span class="s2">}&quot;</span> <span class="s2">&quot;char *&quot;</span>
<span class="p">(</span><span class="n">lldb</span><span class="p">)</span> <span class="nb">type</span> <span class="n">summary</span> <span class="n">add</span> <span class="o">--</span><span class="n">summary</span><span class="o">-</span><span class="n">string</span> <span class="s2">&quot;${var</span><span class="si">%s</span><span class="s2">}&quot;</span> <span class="o">-</span><span class="n">x</span> <span class="s2">&quot;char \[[0-9]+]&quot;</span>
</pre></div>
</div>
<p>any of the array formats (int8_t[], float32{}, ‚Ä¶), and the y, Y and a formats
work to print an array of a non-aggregate type, even if square brackets are
omitted.</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="p">(</span><span class="n">lldb</span><span class="p">)</span> <span class="nb">type</span> <span class="n">summary</span> <span class="n">add</span> <span class="o">--</span><span class="n">summary</span><span class="o">-</span><span class="n">string</span> <span class="s2">&quot;${var</span><span class="si">%i</span><span class="s2">nt32_t[]}&quot;</span> <span class="s2">&quot;int [10]&quot;</span>
</pre></div>
</div>
<p>This feature, however, is not enabled for pointers because there is no way for
LLDB to detect the end of the pointed data.</p>
<p>This also does not work for other formats (e.g. boolean), and you must specify
the square brackets operator to get the expected output.</p>
</section>
<section id="python-scripting">
<h2>Python Scripting<a class="headerlink" href="#python-scripting" title="Link to this heading">#</a></h2>
<p>Most of the times, summary strings prove good enough for the job of summarizing
the contents of a variable. However, as soon as you need to do more than
picking some values and rearranging them for display, summary strings stop
being an effective tool. This is because summary strings lack the power to
actually perform any kind of computation on the value of variables.</p>
<p>To solve this issue, you can bind some Python scripting code as a summary for
your datatype, and that script has the ability to both extract children
variables as the summary strings do and to perform active computation on the
extracted values. As a small example, let‚Äôs say we have a Rectangle class:</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="k">class</span><span class="w"> </span><span class="nc">Rectangle</span>
<span class="p">{</span>
<span class="n">private</span><span class="p">:</span>
   <span class="nb">int</span> <span class="n">height</span><span class="p">;</span>
   <span class="nb">int</span> <span class="n">width</span><span class="p">;</span>
<span class="n">public</span><span class="p">:</span>
   <span class="n">Rectangle</span><span class="p">()</span> <span class="p">:</span> <span class="n">height</span><span class="p">(</span><span class="mi">3</span><span class="p">),</span> <span class="n">width</span><span class="p">(</span><span class="mi">5</span><span class="p">)</span> <span class="p">{}</span>
   <span class="n">Rectangle</span><span class="p">(</span><span class="nb">int</span> <span class="n">H</span><span class="p">)</span> <span class="p">:</span> <span class="n">height</span><span class="p">(</span><span class="n">H</span><span class="p">),</span> <span class="n">width</span><span class="p">(</span><span class="n">H</span><span class="o">*</span><span class="mi">2</span><span class="o">-</span><span class="mi">1</span><span class="p">)</span> <span class="p">{}</span>
   <span class="n">Rectangle</span><span class="p">(</span><span class="nb">int</span> <span class="n">H</span><span class="p">,</span> <span class="nb">int</span> <span class="n">W</span><span class="p">)</span> <span class="p">:</span> <span class="n">height</span><span class="p">(</span><span class="n">H</span><span class="p">),</span> <span class="n">width</span><span class="p">(</span><span class="n">W</span><span class="p">)</span> <span class="p">{}</span>
   <span class="nb">int</span> <span class="n">GetHeight</span><span class="p">()</span> <span class="p">{</span> <span class="k">return</span> <span class="n">height</span><span class="p">;</span> <span class="p">}</span>
   <span class="nb">int</span> <span class="n">GetWidth</span><span class="p">()</span> <span class="p">{</span> <span class="k">return</span> <span class="n">width</span><span class="p">;</span> <span class="p">}</span>
<span class="p">};</span>
</pre></div>
</div>
<p>Summary strings are effective to reduce the screen real estate used by the
default viewing mode, but are not effective if we want to display the area and
perimeter of Rectangle objects</p>
<p>To obtain this, we can simply attach a small Python script to the Rectangle
class, as shown in this example:</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="p">(</span><span class="n">lldb</span><span class="p">)</span> <span class="nb">type</span> <span class="n">summary</span> <span class="n">add</span> <span class="o">-</span><span class="n">P</span> <span class="n">Rectangle</span>
<span class="n">Enter</span> <span class="n">your</span> <span class="n">Python</span> <span class="n">command</span><span class="p">(</span><span class="n">s</span><span class="p">)</span><span class="o">.</span> <span class="n">Type</span> <span class="s1">&#39;DONE&#39;</span> <span class="n">to</span> <span class="n">end</span><span class="o">.</span>
<span class="k">def</span><span class="w"> </span><span class="nf">function</span> <span class="p">(</span><span class="n">valobj</span><span class="p">,</span><span class="n">internal_dict</span><span class="p">,</span><span class="n">options</span><span class="p">):</span>
   <span class="n">height_val</span> <span class="o">=</span> <span class="n">valobj</span><span class="o">.</span><span class="n">GetChildMemberWithName</span><span class="p">(</span><span class="s1">&#39;height&#39;</span><span class="p">)</span>
   <span class="n">width_val</span> <span class="o">=</span> <span class="n">valobj</span><span class="o">.</span><span class="n">GetChildMemberWithName</span><span class="p">(</span><span class="s1">&#39;width&#39;</span><span class="p">)</span>
   <span class="n">height</span> <span class="o">=</span> <span class="n">height_val</span><span class="o">.</span><span class="n">GetValueAsUnsigned</span><span class="p">(</span><span class="mi">0</span><span class="p">)</span>
   <span class="n">width</span> <span class="o">=</span> <span class="n">width_val</span><span class="o">.</span><span class="n">GetValueAsUnsigned</span><span class="p">(</span><span class="mi">0</span><span class="p">)</span>
   <span class="n">area</span> <span class="o">=</span> <span class="n">height</span><span class="o">*</span><span class="n">width</span>
   <span class="n">perimeter</span> <span class="o">=</span> <span class="mi">2</span><span class="o">*</span><span class="p">(</span><span class="n">height</span> <span class="o">+</span> <span class="n">width</span><span class="p">)</span>
   <span class="k">return</span> <span class="s1">&#39;Area: &#39;</span> <span class="o">+</span> <span class="nb">str</span><span class="p">(</span><span class="n">area</span><span class="p">)</span> <span class="o">+</span> <span class="s1">&#39;, Perimeter: &#39;</span> <span class="o">+</span> <span class="nb">str</span><span class="p">(</span><span class="n">perimeter</span><span class="p">)</span>
   <span class="n">DONE</span>
<span class="p">(</span><span class="n">lldb</span><span class="p">)</span> <span class="n">frame</span> <span class="n">variable</span>
<span class="p">(</span><span class="n">Rectangle</span><span class="p">)</span> <span class="n">r1</span> <span class="o">=</span> <span class="n">Area</span><span class="p">:</span> <span class="mi">20</span><span class="p">,</span> <span class="n">Perimeter</span><span class="p">:</span> <span class="mi">18</span>
<span class="p">(</span><span class="n">Rectangle</span><span class="p">)</span> <span class="n">r2</span> <span class="o">=</span> <span class="n">Area</span><span class="p">:</span> <span class="mi">72</span><span class="p">,</span> <span class="n">Perimeter</span><span class="p">:</span> <span class="mi">36</span>
<span class="p">(</span><span class="n">Rectangle</span><span class="p">)</span> <span class="n">r3</span> <span class="o">=</span> <span class="n">Area</span><span class="p">:</span> <span class="mi">16</span><span class="p">,</span> <span class="n">Perimeter</span><span class="p">:</span> <span class="mi">16</span>
</pre></div>
</div>
<p>In order to write effective summary scripts, you need to know the LLDB public
API, which is the way Python code can access the LLDB object model. For further
details on the API you should look at the LLDB API reference documentation.</p>
<p>As a brief introduction, your script is encapsulated into a function that is
passed two parameters: <code class="docutils literal notranslate"><span class="pre">valobj</span></code> and <code class="docutils literal notranslate"><span class="pre">internal_dict</span></code>.</p>
<p><code class="docutils literal notranslate"><span class="pre">internal_dict</span></code> is an internal support parameter used by LLDB and you should
not touch it.</p>
<p><code class="docutils literal notranslate"><span class="pre">valobj</span></code> is the object encapsulating the actual variable being displayed, and
its type is <code class="xref any docutils literal notranslate"><span class="pre">SBValue</span></code>. Out of the many possible operations on an <code class="xref any docutils literal notranslate"><span class="pre">SBValue</span></code>, the
basic one is retrieve the children objects it contains (essentially, the fields
of the object wrapped by it), by calling <code class="docutils literal notranslate"><span class="pre">GetChildMemberWithName()</span></code>, passing
it the child‚Äôs name as a string.</p>
<p>If the variable has a value, you can ask for it, and return it as a string
using <code class="docutils literal notranslate"><span class="pre">GetValue()</span></code>, or as a signed/unsigned number using
<code class="docutils literal notranslate"><span class="pre">GetValueAsSigned()</span></code>, <code class="docutils literal notranslate"><span class="pre">GetValueAsUnsigned()</span></code>. It is also possible to
retrieve an <code class="xref any docutils literal notranslate"><span class="pre">SBData</span></code> object by calling <code class="docutils literal notranslate"><span class="pre">GetData()</span></code> and then read the object‚Äôs
contents out of the <code class="xref any docutils literal notranslate"><span class="pre">SBData</span></code>.</p>
<p>If you need to delve into several levels of hierarchy, as you can do with
summary strings, you can use the method <code class="docutils literal notranslate"><span class="pre">GetValueForExpressionPath()</span></code>,
passing it an expression path just like those you could use for summary strings
(one of the differences is that dereferencing a pointer does not occur by
prefixing the path with a <code class="docutils literal notranslate"><span class="pre">*`</span></code>, but by calling the <code class="docutils literal notranslate"><span class="pre">Dereference()</span></code> method
on the returned <code class="xref any docutils literal notranslate"><span class="pre">SBValue</span></code>). If you need to access array slices, you cannot do
that (yet) via this method call, and you must use <code class="docutils literal notranslate"><span class="pre">GetChildAtIndex()</span></code>
querying it for the array items one by one. Also, handling custom formats is
something you have to deal with on your own.</p>
<p><code class="docutils literal notranslate"><span class="pre">options</span></code> Python summary formatters can optionally define this
third argument, which is an object of type <code class="docutils literal notranslate"><span class="pre">lldb.SBTypeSummaryOptions</span></code>,
allowing for a few customizations of the result. The decision to
adopt or not this third argument - and the meaning of options
thereof - is up to the individual formatter‚Äôs writer.</p>
<p>Other than interactively typing a Python script there are two other ways for
you to input a Python script as a summary:</p>
<ul class="simple">
<li><p>using the ‚Äìpython-script option to type summary add and typing the script
code as an option argument; as in:</p></li>
</ul>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="p">(</span><span class="n">lldb</span><span class="p">)</span> <span class="nb">type</span> <span class="n">summary</span> <span class="n">add</span> <span class="o">--</span><span class="n">python</span><span class="o">-</span><span class="n">script</span> <span class="s2">&quot;height = valobj.GetChildMemberWithName(&#39;height&#39;).GetValueAsUnsigned(0);width = valobj.GetChildMemberWithName(&#39;width&#39;).GetValueAsUnsigned(0); return &#39;Area: </span><span class="si">%d</span><span class="s2">&#39; % (height*width)&quot;</span> <span class="n">Rectangle</span>
</pre></div>
</div>
<ul class="simple">
<li><p>using the ‚Äìpython-function (-F) option to type summary add and giving the
name of a Python function with the correct prototype. Most probably, you will
define (or have already defined) the function in the interactive interpreter,
or somehow loaded it from a file, using the command script import command.
LLDB will emit a warning if it is unable to find the function you passed, but
will still register the binding.</p></li>
</ul>
</section>
<section id="regular-expression-typenames">
<h2>Regular Expression Typenames<a class="headerlink" href="#regular-expression-typenames" title="Link to this heading">#</a></h2>
<p>As you noticed, in order to associate the custom summary string to the array
types, one must give the array size as part of the typename. This can long
become tiresome when using arrays of different sizes, Simple [3], Simple [9],
Simple [12], ‚Ä¶</p>
<p>If you use the -x option, type names are treated as regular expressions instead
of type names. This would let you rephrase the above example for arrays of type
Simple [3] as:</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="p">(</span><span class="n">lldb</span><span class="p">)</span> <span class="nb">type</span> <span class="n">summary</span> <span class="n">add</span> <span class="o">--</span><span class="n">summary</span><span class="o">-</span><span class="n">string</span> <span class="s2">&quot;${var[].x}&quot;</span> <span class="o">-</span><span class="n">x</span> <span class="s2">&quot;Simple \[[0-9]+\]&quot;</span>
<span class="p">(</span><span class="n">lldb</span><span class="p">)</span> <span class="n">frame</span> <span class="n">variable</span>
<span class="p">(</span><span class="n">Simple</span> <span class="p">[</span><span class="mi">3</span><span class="p">])</span> <span class="n">sarray</span> <span class="o">=</span> <span class="p">[</span><span class="mi">1</span><span class="p">,</span><span class="mi">4</span><span class="p">,</span><span class="mi">7</span><span class="p">]</span>
<span class="p">(</span><span class="n">Simple</span> <span class="p">[</span><span class="mi">2</span><span class="p">])</span> <span class="n">sother</span> <span class="o">=</span> <span class="p">[</span><span class="mi">3</span><span class="p">,</span><span class="mi">6</span><span class="p">]</span>
</pre></div>
</div>
<p>The above scenario works for Simple [3] as well as for any other array of
Simple objects.</p>
<p>While this feature is mostly useful for arrays, you could also use regular
expressions to catch other type sets grouped by name. However, as regular
expression matching is slower than normal name matching, LLDB will first try to
match by name in any way it can, and only when this fails, will it resort to
regular expression matching.</p>
<p>One of the ways LLDB uses this feature internally, is to match the names of STL
container classes, regardless of the template arguments provided. The details
for this are found at FormatManager.cpp</p>
<p>The regular expression language used by LLDB is the POSIX extended language, as
defined by the Single UNIX Specification, of which macOS is a compliant
implementation.</p>
</section>
<section id="names-summaries">
<h2>Names Summaries<a class="headerlink" href="#names-summaries" title="Link to this heading">#</a></h2>
<p>For a given type, there may be different meaningful summary representations.
However, currently, only one summary can be associated to a type at each
moment. If you need to temporarily override the association for a variable,
without changing the summary string for to its type, you can use named
summaries.</p>
<p>Named summaries work by attaching a name to a summary when creating it. Then,
when there is a need to attach the summary to a variable, the frame variable
command, supports a ‚Äìsummary option that tells LLDB to use the named summary
given instead of the default one.</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="p">(</span><span class="n">lldb</span><span class="p">)</span> <span class="nb">type</span> <span class="n">summary</span> <span class="n">add</span> <span class="o">--</span><span class="n">summary</span><span class="o">-</span><span class="n">string</span> <span class="s2">&quot;x=$</span><span class="si">{var.integer}</span><span class="s2">&quot;</span> <span class="o">--</span><span class="n">name</span> <span class="n">NamedSummary</span>
<span class="p">(</span><span class="n">lldb</span><span class="p">)</span> <span class="n">frame</span> <span class="n">variable</span> <span class="n">one</span>
<span class="p">(</span><span class="n">i_am_cool</span><span class="p">)</span> <span class="n">one</span> <span class="o">=</span> <span class="nb">int</span> <span class="o">=</span> <span class="mi">3</span><span class="p">,</span> <span class="nb">float</span> <span class="o">=</span> <span class="mf">3.14159</span><span class="p">,</span> <span class="n">char</span> <span class="o">=</span> <span class="mi">69</span>
<span class="p">(</span><span class="n">lldb</span><span class="p">)</span> <span class="n">frame</span> <span class="n">variable</span> <span class="n">one</span> <span class="o">--</span><span class="n">summary</span> <span class="n">NamedSummary</span>
<span class="p">(</span><span class="n">i_am_cool</span><span class="p">)</span> <span class="n">one</span> <span class="o">=</span> <span class="n">x</span><span class="o">=</span><span class="mi">3</span>
</pre></div>
</div>
<p>When defining a named summary, binding it to one or more types becomes
optional. Even if you bind the named summary to a type, and later change the
summary string for that type, the named summary will not be changed by that.
You can delete named summaries by using the type summary delete command, as if
the summary name was the datatype that the summary is applied to</p>
<p>A summary attached to a variable using the ‚Äìsummary option, has the same
semantics that a custom format attached using the -f option has: it stays
attached till you attach a new one, or till you let your program run again.</p>
</section>
<section id="synthetic-children">
<h2>Synthetic Children<a class="headerlink" href="#synthetic-children" title="Link to this heading">#</a></h2>
<p>Summaries work well when one is able to navigate through an expression path. In
order for LLDB to do so, appropriate debugging information must be available.</p>
<p>Some types are opaque, i.e. no knowledge of their internals is provided. When
that‚Äôs the case, expression paths do not work correctly.</p>
<p>In other cases, the internals are available to use in expression paths, but
they do not provide a user-friendly representation of the object‚Äôs value.</p>
<p>For instance, consider an STL vector, as implemented by the GNU C++ Library:</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="p">(</span><span class="n">lldb</span><span class="p">)</span> <span class="n">frame</span> <span class="n">variable</span> <span class="n">numbers</span> <span class="o">-</span><span class="n">T</span>
<span class="p">(</span><span class="n">std</span><span class="p">::</span><span class="n">vector</span><span class="o">&lt;</span><span class="nb">int</span><span class="o">&gt;</span><span class="p">)</span> <span class="n">numbers</span> <span class="o">=</span> <span class="p">{</span>
   <span class="p">(</span><span class="n">std</span><span class="p">::</span><span class="n">_Vector_base</span><span class="o">&lt;</span><span class="nb">int</span><span class="p">,</span> <span class="n">std</span><span class="p">::</span><span class="n">allocator</span><span class="o">&lt;</span><span class="nb">int</span><span class="o">&gt;</span> <span class="o">&gt;</span><span class="p">)</span> <span class="n">std</span><span class="p">::</span><span class="n">_Vector_base</span><span class="o">&lt;</span><span class="nb">int</span><span class="p">,</span> <span class="n">std</span><span class="p">::</span><span class="n">allocator</span><span class="o">&lt;</span><span class="nb">int</span><span class="o">&gt;</span> <span class="o">&gt;</span> <span class="o">=</span> <span class="p">{</span>
      <span class="p">(</span><span class="n">std</span><span class="p">::</span><span class="n">_Vector_base</span><span class="o">&lt;</span><span class="nb">int</span><span class="p">,</span> <span class="n">std</span><span class="p">::</span><span class="n">allocator</span><span class="o">&amp;</span><span class="n">tl</span><span class="p">;</span><span class="nb">int</span><span class="o">&gt;</span> <span class="o">&gt;</span><span class="p">::</span><span class="n">_Vector_impl</span><span class="p">)</span> <span class="n">_M_impl</span> <span class="o">=</span> <span class="p">{</span>
            <span class="p">(</span><span class="nb">int</span> <span class="o">*</span><span class="p">)</span> <span class="n">_M_start</span> <span class="o">=</span> <span class="mh">0x00000001001008a0</span>
            <span class="p">(</span><span class="nb">int</span> <span class="o">*</span><span class="p">)</span> <span class="n">_M_finish</span> <span class="o">=</span> <span class="mh">0x00000001001008a8</span>
            <span class="p">(</span><span class="nb">int</span> <span class="o">*</span><span class="p">)</span> <span class="n">_M_end_of_storage</span> <span class="o">=</span> <span class="mh">0x00000001001008a8</span>
      <span class="p">}</span>
   <span class="p">}</span>
<span class="p">}</span>
</pre></div>
</div>
<p>Here, you can see how the type is implemented, and you can write a summary for
that implementation but that is not going to help you infer what items are
actually stored in the vector.</p>
<p>What you would like to see is probably something like:</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="p">(</span><span class="n">lldb</span><span class="p">)</span> <span class="n">frame</span> <span class="n">variable</span> <span class="n">numbers</span> <span class="o">-</span><span class="n">T</span>
<span class="p">(</span><span class="n">std</span><span class="p">::</span><span class="n">vector</span><span class="o">&lt;</span><span class="nb">int</span><span class="o">&gt;</span><span class="p">)</span> <span class="n">numbers</span> <span class="o">=</span> <span class="p">{</span>
   <span class="p">(</span><span class="nb">int</span><span class="p">)</span> <span class="p">[</span><span class="mi">0</span><span class="p">]</span> <span class="o">=</span> <span class="mi">1</span>
   <span class="p">(</span><span class="nb">int</span><span class="p">)</span> <span class="p">[</span><span class="mi">1</span><span class="p">]</span> <span class="o">=</span> <span class="mi">12</span>
   <span class="p">(</span><span class="nb">int</span><span class="p">)</span> <span class="p">[</span><span class="mi">2</span><span class="p">]</span> <span class="o">=</span> <span class="mi">123</span>
   <span class="p">(</span><span class="nb">int</span><span class="p">)</span> <span class="p">[</span><span class="mi">3</span><span class="p">]</span> <span class="o">=</span> <span class="mi">1234</span>
<span class="p">}</span>
</pre></div>
</div>
<p>Synthetic children are a way to get that result.</p>
<p>The feature is based upon the idea of providing a new set of children for a
variable that replaces the ones available by default through the debug
information. In the example, we can use synthetic children to provide the
vector items as children for the std::vector object.</p>
<p>In order to create synthetic children, you need to provide a Python class that
adheres to a given interface (the word is italicized because Python has no
explicit notion of interface, by that word we mean a given set of methods must
be implemented by the Python class):</p>
<div class="highlight-python notranslate"><div class="highlight"><pre><span></span><span class="k">class</span><span class="w"> </span><span class="nc">SyntheticChildrenProvider</span><span class="p">:</span>
   <span class="k">def</span><span class="w"> </span><span class="fm">__init__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">valobj</span><span class="p">,</span> <span class="n">internal_dict</span><span class="p">):</span>
      <span class="n">this</span> <span class="n">call</span> <span class="n">should</span> <span class="n">initialize</span> <span class="n">the</span> <span class="n">Python</span> <span class="nb">object</span> <span class="n">using</span> <span class="n">valobj</span> <span class="k">as</span> <span class="n">the</span>
      <span class="n">variable</span> <span class="n">to</span> <span class="n">provide</span> <span class="n">synthetic</span> <span class="n">children</span> <span class="k">for</span>
   <span class="k">def</span><span class="w"> </span><span class="nf">num_children</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">max_children</span><span class="p">):</span>
      <span class="n">this</span> <span class="n">call</span> <span class="n">should</span> <span class="k">return</span> <span class="n">the</span> <span class="n">number</span> <span class="n">of</span> <span class="n">children</span> <span class="n">that</span> <span class="n">you</span> <span class="n">want</span> <span class="n">your</span>
      <span class="nb">object</span> <span class="n">to</span> <span class="n">have</span><span class="p">[</span><span class="mi">1</span><span class="p">]</span>
   <span class="k">def</span><span class="w"> </span><span class="nf">get_child_index</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span><span class="n">name</span><span class="p">):</span>
      <span class="n">this</span> <span class="n">call</span> <span class="n">should</span> <span class="k">return</span> <span class="n">the</span> <span class="n">index</span> <span class="n">of</span> <span class="n">the</span> <span class="n">synthetic</span> <span class="n">child</span> <span class="n">whose</span> <span class="n">name</span> <span class="ow">is</span>
      <span class="n">given</span> <span class="k">as</span> <span class="n">argument</span>
   <span class="k">def</span><span class="w"> </span><span class="nf">get_child_at_index</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span><span class="n">index</span><span class="p">):</span>
      <span class="n">this</span> <span class="n">call</span> <span class="n">should</span> <span class="k">return</span> <span class="n">a</span> <span class="n">new</span> <span class="n">LLDB</span> <span class="n">SBValue</span> <span class="nb">object</span> <span class="n">representing</span> <span class="n">the</span>
      <span class="n">child</span> <span class="n">at</span> <span class="n">the</span> <span class="n">index</span> <span class="n">given</span> <span class="k">as</span> <span class="n">argument</span>
   <span class="k">def</span><span class="w"> </span><span class="nf">update</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
      <span class="n">this</span> <span class="n">call</span> <span class="n">should</span> <span class="n">be</span> <span class="n">used</span> <span class="n">to</span> <span class="n">update</span> <span class="n">the</span> <span class="n">internal</span> <span class="n">state</span> <span class="n">of</span> <span class="n">this</span> <span class="n">Python</span>
      <span class="nb">object</span> <span class="n">whenever</span> <span class="n">the</span> <span class="n">state</span> <span class="n">of</span> <span class="n">the</span> <span class="n">variables</span> <span class="ow">in</span> <span class="n">LLDB</span> <span class="n">changes</span><span class="o">.</span><span class="p">[</span><span class="mi">2</span><span class="p">]</span>
      <span class="n">Also</span><span class="p">,</span> <span class="n">this</span> <span class="n">method</span> <span class="ow">is</span> <span class="n">invoked</span> <span class="n">before</span> <span class="nb">any</span> <span class="n">other</span> <span class="n">method</span> <span class="ow">in</span> <span class="n">the</span> <span class="n">interface</span><span class="o">.</span>
   <span class="k">def</span><span class="w"> </span><span class="nf">has_children</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
      <span class="n">this</span> <span class="n">call</span> <span class="n">should</span> <span class="k">return</span> <span class="kc">True</span> <span class="k">if</span> <span class="n">this</span> <span class="nb">object</span> <span class="n">might</span> <span class="n">have</span> <span class="n">children</span><span class="p">,</span> <span class="ow">and</span>
      <span class="kc">False</span> <span class="k">if</span> <span class="n">this</span> <span class="nb">object</span> <span class="n">can</span> <span class="n">be</span> <span class="n">guaranteed</span> <span class="ow">not</span> <span class="n">to</span> <span class="n">have</span> <span class="n">children</span><span class="o">.</span><span class="p">[</span><span class="mi">3</span><span class="p">]</span>
   <span class="k">def</span><span class="w"> </span><span class="nf">get_value</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
      <span class="n">this</span> <span class="n">call</span> <span class="n">can</span> <span class="k">return</span> <span class="n">an</span> <span class="n">SBValue</span> <span class="n">to</span> <span class="n">be</span> <span class="n">presented</span> <span class="k">as</span> <span class="n">the</span> <span class="n">value</span> <span class="n">of</span> <span class="n">the</span>
      <span class="n">synthetic</span> <span class="n">value</span> <span class="n">under</span> <span class="n">consideration</span><span class="o">.</span><span class="p">[</span><span class="mi">4</span><span class="p">]</span>
</pre></div>
</div>
<p>As a warning, exceptions that are thrown by python formatters are caught
silently by LLDB and should be handled appropriately by the formatter itself.
Being more specific, in case of exceptions, LLDB might assume that the given
object has no children or it might skip printing some children, as they are
printed one by one.</p>
<p>[1] The <code class="xref any docutils literal notranslate"><span class="pre">max_children</span></code> argument is optional (since lldb 3.8.0) and indicates the
maximum number of children that lldb is interested in (at this moment). If the
computation of the number of children is expensive (for example, requires
traversing a linked list to determine its size) your implementation may return
<code class="xref any docutils literal notranslate"><span class="pre">max_children</span></code> rather than the actual number. If the computation is cheap (e.g., the
number is stored as a field of the object), then you can always return the true
number of children (that is, ignore the <code class="xref any docutils literal notranslate"><span class="pre">max_children</span></code> argument).</p>
<p>[2] This method is optional. Also, a boolean value must be returned (since lldb
3.1.0). If <code class="docutils literal notranslate"><span class="pre">False</span></code> is returned, then whenever the process reaches a new stop,
this method will be invoked again to generate an updated list of the children
for a given variable. Otherwise, if <code class="docutils literal notranslate"><span class="pre">True</span></code> is returned, then the value is
cached and this method won‚Äôt be called again, effectively freezing the state of
the value in subsequent stops. Beware that returning <code class="docutils literal notranslate"><span class="pre">True</span></code> incorrectly could
show misleading information to the user.</p>
<p>[3] This method is optional (since lldb 3.2.0). While implementing it in terms
of num_children is acceptable, implementors are encouraged to look for
optimized coding alternatives whenever reasonable.</p>
<p>[4] This method is optional (since lldb 3.5.2). The <code class="xref any docutils literal notranslate"><span class="pre">SBValue</span></code> you return here
will most likely be a numeric type (int, float, ‚Ä¶) as its value bytes will be
used as-if they were the value of the root <code class="xref any docutils literal notranslate"><span class="pre">SBValue</span></code> proper.  As a shortcut for
this, you can inherit from lldb.SBSyntheticValueProvider, and just define
get_value as other methods are defaulted in the superclass as returning default
no-children responses.</p>
<p>If a synthetic child provider supplies a special child named
<code class="docutils literal notranslate"><span class="pre">$$dereference$$</span></code> then it will be used when evaluating <code class="docutils literal notranslate"><span class="pre">operator</span> <span class="pre">*</span></code> and
<code class="docutils literal notranslate"><span class="pre">operator</span> <span class="pre">-&gt;</span></code> in the frame variable command and related SB API
functions. It is possible to declare this synthetic child without
including it in the range of children displayed by LLDB. For example,
this subset of a synthetic children provider class would allow the
synthetic value to be dereferenced without actually showing any
synthetic children in the UI:</p>
<div class="highlight-python notranslate"><div class="highlight"><pre><span></span><span class="k">class</span><span class="w"> </span><span class="nc">SyntheticChildrenProvider</span><span class="p">:</span>
    <span class="p">[</span><span class="o">...</span><span class="p">]</span>
    <span class="k">def</span><span class="w"> </span><span class="nf">num_children</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="k">return</span> <span class="mi">0</span>
    <span class="k">def</span><span class="w"> </span><span class="nf">get_child_index</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">name</span><span class="p">):</span>
        <span class="k">if</span> <span class="n">name</span> <span class="o">==</span> <span class="s1">&#39;$$dereference$$&#39;</span><span class="p">:</span>
            <span class="k">return</span> <span class="mi">0</span>
        <span class="k">return</span> <span class="o">-</span><span class="mi">1</span>
    <span class="k">def</span><span class="w"> </span><span class="nf">get_child_at_index</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">index</span><span class="p">):</span>
        <span class="k">if</span> <span class="n">index</span> <span class="o">==</span> <span class="mi">0</span><span class="p">:</span>
            <span class="k">return</span> <span class="o">&lt;</span><span class="n">valobj</span> <span class="n">resulting</span> <span class="kn">from</span><span class="w"> </span><span class="nn">dereference</span><span class="o">&gt;</span>
        <span class="k">return</span> <span class="kc">None</span>
</pre></div>
</div>
<p>For examples of how synthetic children are created, you are encouraged to look
at examples/synthetic in the LLDB trunk. Please, be aware that the code in
those files (except bitfield/) is legacy code and is not maintained. You may
especially want to begin looking at this example to get a feel for this
feature, as it is a very easy and well commented example.</p>
<p>The design pattern consistently used in synthetic providers shipping with LLDB
is to use the __init__ to store the <code class="xref any docutils literal notranslate"><span class="pre">SBValue</span></code> instance as a part of self. The
update function is then used to perform the actual initialization. Once a
synthetic children provider is written, one must load it into LLDB before it
can be used. Currently, one can use the LLDB script command to type Python code
interactively, or use the command script import fileName command to load Python
code from a Python module (ordinary rules apply to importing modules this way).
A third option is to type the code for the provider class interactively while
adding it.</p>
<p>For example, let‚Äôs pretend we have a class Foo for which a synthetic children
provider class Foo_Provider is available, in a Python module contained in file
~/Foo_Tools.py. The following interaction sets Foo_Provider as a synthetic
children provider in LLDB:</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="p">(</span><span class="n">lldb</span><span class="p">)</span> <span class="n">command</span> <span class="n">script</span> <span class="kn">import</span><span class="w"> </span><span class="o">~/</span><span class="n">Foo_Tools</span><span class="o">.</span><span class="n">py</span>
<span class="p">(</span><span class="n">lldb</span><span class="p">)</span> <span class="nb">type</span> <span class="n">synthetic</span> <span class="n">add</span> <span class="n">Foo</span> <span class="o">--</span><span class="n">python</span><span class="o">-</span><span class="k">class</span><span class="w"> </span><span class="nc">Foo_Tools</span><span class="o">.</span><span class="n">Foo_Provider</span>
<span class="p">(</span><span class="n">lldb</span><span class="p">)</span> <span class="n">frame</span> <span class="n">variable</span> <span class="n">a_foo</span>
<span class="p">(</span><span class="n">Foo</span><span class="p">)</span> <span class="n">a_foo</span> <span class="o">=</span> <span class="p">{</span>
   <span class="n">x</span> <span class="o">=</span> <span class="mi">1</span>
   <span class="n">y</span> <span class="o">=</span> <span class="s2">&quot;Hello world&quot;</span>
<span class="p">}</span>
</pre></div>
</div>
<p>LLDB has synthetic children providers for a core subset of STL classes, both in
the version provided by libstdcpp and by libcxx, as well as for several
Foundation classes.</p>
<p>Synthetic children extend summary strings by enabling a new special variable:
<code class="docutils literal notranslate"><span class="pre">${svar</span></code>.</p>
<p>This symbol tells LLDB to refer expression paths to the synthetic children
instead of the real ones. For instance,</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="p">(</span><span class="n">lldb</span><span class="p">)</span> <span class="nb">type</span> <span class="n">summary</span> <span class="n">add</span> <span class="o">--</span><span class="n">expand</span> <span class="o">-</span><span class="n">x</span> <span class="s2">&quot;std::vector&lt;&quot;</span> <span class="o">--</span><span class="n">summary</span><span class="o">-</span><span class="n">string</span> <span class="s2">&quot;${svar%#} items&quot;</span>
<span class="p">(</span><span class="n">lldb</span><span class="p">)</span> <span class="n">frame</span> <span class="n">variable</span> <span class="n">numbers</span>
<span class="p">(</span><span class="n">std</span><span class="p">::</span><span class="n">vector</span><span class="o">&lt;</span><span class="nb">int</span><span class="o">&gt;</span><span class="p">)</span> <span class="n">numbers</span> <span class="o">=</span> <span class="mi">4</span> <span class="n">items</span> <span class="p">{</span>
   <span class="p">(</span><span class="nb">int</span><span class="p">)</span> <span class="p">[</span><span class="mi">0</span><span class="p">]</span> <span class="o">=</span> <span class="mi">1</span>
   <span class="p">(</span><span class="nb">int</span><span class="p">)</span> <span class="p">[</span><span class="mi">1</span><span class="p">]</span> <span class="o">=</span> <span class="mi">12</span>
   <span class="p">(</span><span class="nb">int</span><span class="p">)</span> <span class="p">[</span><span class="mi">2</span><span class="p">]</span> <span class="o">=</span> <span class="mi">123</span>
   <span class="p">(</span><span class="nb">int</span><span class="p">)</span> <span class="p">[</span><span class="mi">3</span><span class="p">]</span> <span class="o">=</span> <span class="mi">1234</span>
<span class="p">}</span>
</pre></div>
</div>
<p>It‚Äôs important to mention that LLDB invokes the synthetic child provider before
invoking the summary string provider, which allows the latter to have access to
the actual displayable children. This applies to both inlined summary strings
and python-based summary providers.</p>
<p>As a warning, when programmatically accessing the children or children count of
a variable that has a synthetic child provider, notice that LLDB hides the
actual raw children. For example, suppose we have a <code class="docutils literal notranslate"><span class="pre">std::vector</span></code>, which has
an actual in-memory property <code class="docutils literal notranslate"><span class="pre">__begin</span></code> marking the beginning of its data.
After the synthetic child provider is executed, the <code class="docutils literal notranslate"><span class="pre">std::vector</span></code> variable
won‚Äôt show <code class="docutils literal notranslate"><span class="pre">__begin</span></code> as child anymore, even through the SB API. It will have
instead the children calculated by the provider. In case the actual raw
children are needed, a call to <code class="docutils literal notranslate"><span class="pre">value.GetNonSyntheticValue()</span></code> is enough to
get a raw version of the value. It is import to remember this when implementing
summary string providers, as they run after the synthetic child provider.</p>
<p>In some cases, if LLDB is unable to use the real object to get a child
specified in an expression path, it will automatically refer to the synthetic
children. While in summaries it is best to always use ${svar to make your
intentions clearer, interactive debugging can benefit from this behavior, as
in:</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="p">(</span><span class="n">lldb</span><span class="p">)</span> <span class="n">frame</span> <span class="n">variable</span> <span class="n">numbers</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span> <span class="n">numbers</span><span class="p">[</span><span class="mi">1</span><span class="p">]</span>
<span class="p">(</span><span class="nb">int</span><span class="p">)</span> <span class="n">numbers</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span> <span class="o">=</span> <span class="mi">1</span>
<span class="p">(</span><span class="nb">int</span><span class="p">)</span> <span class="n">numbers</span><span class="p">[</span><span class="mi">1</span><span class="p">]</span> <span class="o">=</span> <span class="mi">12</span>
</pre></div>
</div>
<p>Unlike many other visualization features, however, the access to synthetic
children only works when using frame variable, and is not supported in
expression:</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="p">(</span><span class="n">lldb</span><span class="p">)</span> <span class="n">expression</span> <span class="n">numbers</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span>
<span class="n">Error</span> <span class="p">[</span><span class="n">IRForTarget</span><span class="p">]:</span> <span class="n">Call</span> <span class="n">to</span> <span class="n">a</span> <span class="n">function</span> <span class="s1">&#39;_ZNSt33vector&lt;int, std::allocator&lt;int&gt; &gt;ixEm&#39;</span> <span class="n">that</span> <span class="ow">is</span> <span class="ow">not</span> <span class="n">present</span> <span class="ow">in</span> <span class="n">the</span> <span class="n">target</span>
<span class="n">error</span><span class="p">:</span> <span class="n">Couldn</span><span class="s1">&#39;t convert the expression to DWARF</span>
</pre></div>
</div>
<p>The reason for this is that classes might have an overloaded <code class="docutils literal notranslate"><span class="pre">operator</span> <span class="pre">[]</span></code>,
or other special provisions and the expression command chooses to ignore
synthetic children in the interest of equivalency with code you asked to have
compiled from source.</p>
</section>
<section id="filters">
<h2>Filters<a class="headerlink" href="#filters" title="Link to this heading">#</a></h2>
<p>Filters are a solution to the display of complex classes. At times, classes
have many member variables but not all of these are actually necessary for the
user to see.</p>
<p>A filter will solve this issue by only letting the user see those member
variables they care about. Of course, the equivalent of a filter can be
implemented easily using synthetic children, but a filter lets you get the job
done without having to write Python code.</p>
<p>For instance, if your class Foobar has member variables named A thru Z, but you
only need to see the ones named B, H and Q, you can define a filter:</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="p">(</span><span class="n">lldb</span><span class="p">)</span> <span class="nb">type</span> <span class="nb">filter</span> <span class="n">add</span> <span class="n">Foobar</span> <span class="o">--</span><span class="n">child</span> <span class="n">B</span> <span class="o">--</span><span class="n">child</span> <span class="n">H</span> <span class="o">--</span><span class="n">child</span> <span class="n">Q</span>
<span class="p">(</span><span class="n">lldb</span><span class="p">)</span> <span class="n">frame</span> <span class="n">variable</span> <span class="n">a_foobar</span>
<span class="p">(</span><span class="n">Foobar</span><span class="p">)</span> <span class="n">a_foobar</span> <span class="o">=</span> <span class="p">{</span>
   <span class="p">(</span><span class="nb">int</span><span class="p">)</span> <span class="n">B</span> <span class="o">=</span> <span class="mi">1</span>
   <span class="p">(</span><span class="n">char</span><span class="p">)</span> <span class="n">H</span> <span class="o">=</span> <span class="s1">&#39;H&#39;</span>
   <span class="p">(</span><span class="n">std</span><span class="p">::</span><span class="n">string</span><span class="p">)</span> <span class="n">Q</span> <span class="o">=</span> <span class="s2">&quot;Hello world&quot;</span>
<span class="p">}</span>
</pre></div>
</div>
</section>
<section id="callback-based-type-matching">
<h2>Callback-based type matching<a class="headerlink" href="#callback-based-type-matching" title="Link to this heading">#</a></h2>
<p>Even though regular expression matching works well for the vast majority of data
formatters (you normally know the name of the type you‚Äôre writing a formatter
for), there are some cases where it‚Äôs useful to look at the type before deciding
what formatter to apply.</p>
<p>As an example scenario, imagine we have a code generator that produces some
classes that inherit from a common <code class="docutils literal notranslate"><span class="pre">GeneratedObject</span></code> class, and we have a
summary function and a synthetic child provider that work for all
<code class="docutils literal notranslate"><span class="pre">GeneratedObject</span></code> instances (they all follow the same pattern). However, there
is no common pattern in the name of these classes, so we can‚Äôt register the
formatter neither by name nor by regular expression.</p>
<p>In that case, you can write a recognizer function like this:</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="k">def</span><span class="w"> </span><span class="nf">is_generated_object</span><span class="p">(</span><span class="n">sbtype</span><span class="p">,</span> <span class="n">internal_dict</span><span class="p">):</span>
  <span class="k">for</span> <span class="n">base</span> <span class="ow">in</span> <span class="n">sbtype</span><span class="o">.</span><span class="n">get_bases_array</span><span class="p">():</span>
    <span class="k">if</span> <span class="n">base</span><span class="o">.</span><span class="n">GetName</span><span class="p">()</span> <span class="o">==</span> <span class="s2">&quot;GeneratedObject&quot;</span>
      <span class="k">return</span> <span class="kc">True</span>
  <span class="k">return</span> <span class="kc">False</span>
</pre></div>
</div>
<p>And pass this function to <code class="docutils literal notranslate"><span class="pre">type</span> <span class="pre">summary</span> <span class="pre">add</span></code> and <code class="docutils literal notranslate"><span class="pre">type</span> <span class="pre">synthetic</span> <span class="pre">add</span></code> using
the flag <code class="docutils literal notranslate"><span class="pre">--recognizer-function</span></code>.</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="p">(</span><span class="n">lldb</span><span class="p">)</span> <span class="nb">type</span> <span class="n">summary</span> <span class="n">add</span> <span class="o">--</span><span class="n">expand</span> <span class="o">--</span><span class="n">python</span><span class="o">-</span><span class="n">function</span> <span class="n">my_summary_function</span> <span class="o">--</span><span class="n">recognizer</span><span class="o">-</span><span class="n">function</span> <span class="n">is_generated_object</span>
<span class="p">(</span><span class="n">lldb</span><span class="p">)</span> <span class="nb">type</span> <span class="n">synthetic</span> <span class="n">add</span> <span class="o">--</span><span class="n">python</span><span class="o">-</span><span class="k">class</span><span class="w"> </span><span class="nc">my_child_provider</span> <span class="o">--</span><span class="n">recognizer</span><span class="o">-</span><span class="n">function</span> <span class="n">is_generated_object</span>
</pre></div>
</div>
</section>
<section id="objective-c-dynamic-type-discovery">
<h2>Objective-C Dynamic Type Discovery<a class="headerlink" href="#objective-c-dynamic-type-discovery" title="Link to this heading">#</a></h2>
<p>When doing Objective-C development, you may notice that some of your variables
come out as of type id (for instance, items extracted from NSArray). By
default, LLDB will not show you the real type of the object. it can actually
dynamically discover the type of an Objective-C variable, much like the runtime
itself does when invoking a selector. In order to be shown the result of that
discovery that, however, a special option to frame variable or expression is
required: <code class="docutils literal notranslate"><span class="pre">--dynamic-type</span></code>.</p>
<p><code class="docutils literal notranslate"><span class="pre">--dynamic-type</span></code> can have one of three values:</p>
<ul class="simple">
<li><p><code class="docutils literal notranslate"><span class="pre">no-dynamic-values</span></code>: the default, prevents dynamic type discovery</p></li>
<li><p><code class="docutils literal notranslate"><span class="pre">no-run-target</span></code>: enables dynamic type discovery as long as running code on
the target is not required</p></li>
<li><p><code class="docutils literal notranslate"><span class="pre">run-target</span></code>: enables code execution on the target in order to perform
dynamic type discovery</p></li>
</ul>
<p>If you specify a value of either no-run-target or run-target, LLDB will detect
the dynamic type of your variables and show the appropriate formatters for
them. As an example:</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span>(lldb) expr @&quot;Hello&quot;
(NSString *) $0 = 0x00000001048000b0 @&quot;Hello&quot;
(lldb) expr -d no-run @&quot;Hello&quot;
(__NSCFString *) $1 = 0x00000001048000b0 @&quot;Hello&quot;
</pre></div>
</div>
<p>Because LLDB uses a detection algorithm that does not need to invoke any
functions on the target process, no-run-target is enough for this to work.</p>
<p>As a side note, the summary for NSString shown in the example is built right
into LLDB. It was initially implemented through Python (the code is still
available for reference at CFString.py). However, this is out of sync with the
current implementation of the NSString formatter (which is a C++ function
compiled into the LLDB core).</p>
</section>
<section id="categories">
<h2>Categories<a class="headerlink" href="#categories" title="Link to this heading">#</a></h2>
<p>Categories are a way to group related formatters. For instance, LLDB itself
groups the formatters for STL types in a category named cpluspus. Basically,
categories act like containers in which to store formatters for a same library
or OS release.</p>
<p>By default, several categories are created in LLDB:</p>
<ul class="simple">
<li><p>default: this is the category where every formatter ends up, unless another category is specified</p></li>
<li><p>objc: formatters for basic and common Objective-C types that do not specifically depend on macOS</p></li>
<li><p>cplusplus: formatters for STL types (currently only libc++ and libstdc++ are supported). Enabled when debugging C++ targets.</p></li>
<li><p>system: truly basic types for which a formatter is required</p></li>
<li><p>AppKit: Cocoa classes</p></li>
<li><p>CoreFoundation: CF classes</p></li>
<li><p>CoreGraphics: CG classes</p></li>
<li><p>CoreServices: CS classes</p></li>
<li><p>VectorTypes: compact display for several vector types</p></li>
</ul>
<p>If you want to use a custom category for your formatters, all the <code class="docutils literal notranslate"><span class="pre">type</span> <span class="pre">...</span> <span class="pre">add</span></code>
provide a <code class="docutils literal notranslate"><span class="pre">--category</span></code> (<code class="docutils literal notranslate"><span class="pre">-w</span></code>) option, that names the category to add the formatter
to. To delete the formatter, you then have to specify the correct category.</p>
<p>Categories can be in one of two states: enabled and disabled. A category is
initially disabled, and can be enabled using the <code class="docutils literal notranslate"><span class="pre">type</span> <span class="pre">category</span> <span class="pre">enable</span></code> command.
To disable an enabled category, the command to use is <code class="docutils literal notranslate"><span class="pre">type</span> <span class="pre">category</span> <span class="pre">disable</span></code>.</p>
<p>The order in which categories are enabled or disabled is significant, in that
LLDB uses that order when looking for formatters. Therefore, when you enable a
category, it becomes the second one to be searched (after default, which always
stays on top of the list). The default categories are enabled in such a way
that the search order is:</p>
<ul class="simple">
<li><p>default</p></li>
<li><p>objc</p></li>
<li><p>CoreFoundation</p></li>
<li><p>AppKit</p></li>
<li><p>CoreServices</p></li>
<li><p>CoreGraphics</p></li>
<li><p>cplusplus</p></li>
<li><p>VectorTypes</p></li>
<li><p>system</p></li>
</ul>
<p>As said, cplusplus contain formatters for C++ STL data types.
system contains formatters for char* and char[], which reflect the behavior of
older versions of LLDB which had built-in formatters for these types. Because
now these are formatters, you can even replace them with your own if so you
wish.</p>
<p>There is no special command to create a category. When you place a formatter in
a category, if that category does not exist, it is automatically created. For
instance,</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="p">(</span><span class="n">lldb</span><span class="p">)</span> <span class="nb">type</span> <span class="n">summary</span> <span class="n">add</span> <span class="n">Foobar</span> <span class="o">--</span><span class="n">summary</span><span class="o">-</span><span class="n">string</span> <span class="s2">&quot;a foobar&quot;</span> <span class="o">--</span><span class="n">category</span> <span class="n">newcategory</span>
</pre></div>
</div>
<p>automatically creates a (disabled) category named newcategory.</p>
<p>Another way to create a new (empty) category, is to enable it, as in:</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="p">(</span><span class="n">lldb</span><span class="p">)</span> <span class="nb">type</span> <span class="n">category</span> <span class="n">enable</span> <span class="n">newcategory</span>
</pre></div>
</div>
<p>However, in this case LLDB warns you that enabling an empty category has no
effect. If you add formatters to the category after enabling it, they will be
honored. But an empty category per se does not change the way any type is
displayed. The reason the debugger warns you is that enabling an empty category
might be a typo, and you effectively wanted to enable a similarly-named but
not-empty category.</p>
</section>
<section id="finding-formatters-101">
<h2>Finding Formatters 101<a class="headerlink" href="#finding-formatters-101" title="Link to this heading">#</a></h2>
<p>Searching for a formatter (including formats, since lldb 3.4.0) given a
variable goes through a rather intricate set of rules. Namely, what happens is
that LLDB starts looking in each enabled category, according to the order in
which they were enabled (latest enabled first). In each category, LLDB does the
following:</p>
<ul class="simple">
<li><p>If there is a formatter for the type of the variable, use it</p></li>
<li><p>If this object is a pointer, and there is a formatter for the pointee type
that does not skip pointers, use it</p></li>
<li><p>If this object is a reference, and there is a formatter for the referred type
that does not skip references, use it</p></li>
<li><p>If this object is an Objective-C class and dynamic types are enabled, look
for a formatter for the dynamic type of the object. If dynamic types are
disabled, or the search failed, look for a formatter for the declared type of
the object</p></li>
<li><p>If this object‚Äôs type is a typedef, go through typedef hierarchy (LLDB might
not be able to do this if the compiler has not emitted enough information. If
the required information to traverse typedef hierarchies is missing, type
cascading will not work. The clang compiler, part of the LLVM project, emits
the correct debugging information for LLDB to cascade). If at any level of
the hierarchy there is a valid formatter that can cascade, use it.</p></li>
<li><p>If everything has failed, repeat the above search, looking for regular
expressions instead of exact matches</p></li>
</ul>
<p>If any of those attempts returned a valid formatter to be used, that one is
used, and the search is terminated (without going to look in other categories).
If nothing was found in the current category, the next enabled category is
scanned according to the same algorithm. If there are no more enabled
categories, the search has failed.</p>
<p><strong>Warning</strong>: previous versions of LLDB defined cascading to mean not only going
through typedef chains, but also through inheritance chains. This feature has
been removed since it significantly degrades performance. You need to set up
your formatters for every type in inheritance chains to which you want the
formatter to apply.</p>
</section>
</section>

        </article>
      </div>
      <footer>
        
        <div class="related-pages">
          <a class="next-page" href="symbolication.html">
              <div class="page-info">
                <div class="context">
                  <span>Next</span>
                </div>
                <div class="title">Symbolication</div>
              </div>
              <svg class="furo-related-icon"><use href="#svg-arrow-right"></use></svg>
            </a>
          <a class="prev-page" href="formatting.html">
              <svg class="furo-related-icon"><use href="#svg-arrow-right"></use></svg>
              <div class="page-info">
                <div class="context">
                  <span>Previous</span>
                </div>
                
                <div class="title">Frame and Thread Format</div>
                
              </div>
            </a>
        </div>
        <div class="bottom-of-page">
          <div class="left-details">
            <div class="copyright">
                Copyright &#169; 2007-2025, The LLDB Team
            </div>
            Made with <a href="https://www.sphinx-doc.org/">Sphinx</a> and <a class="muted-link" href="https://pradyunsg.me">@pradyunsg</a>'s
            
            <a href="https://github.com/pradyunsg/furo">Furo</a>
            <div class="last-updated">
              Last updated on Aug 13, 2025</div>
          </div>
          <div class="right-details">
            
          </div>
        </div>
        
      </footer>
    </div>
    <aside class="toc-drawer">
      
      
      <div class="toc-sticky toc-scroll">
        <div class="toc-title-container">
          <span class="toc-title">
            On this page
          </span>
        </div>
        <div class="toc-tree-container">
          <div class="toc-tree">
            <ul>
<li><a class="reference internal" href="#">Variable Formatting</a><ul>
<li><a class="reference internal" href="#type-format">Type Format</a></li>
<li><a class="reference internal" href="#type-summary">Type Summary</a></li>
<li><a class="reference internal" href="#summary-format-matching-on-pointers">Summary Format Matching On Pointers</a></li>
<li><a class="reference internal" href="#summary-strings">Summary Strings</a></li>
<li><a class="reference internal" href="#formatting-summary-elements">Formatting Summary Elements</a></li>
<li><a class="reference internal" href="#element-inlining">Element Inlining</a></li>
<li><a class="reference internal" href="#bitfields-and-array-syntax">Bitfields And Array Syntax</a></li>
<li><a class="reference internal" href="#python-scripting">Python Scripting</a></li>
<li><a class="reference internal" href="#regular-expression-typenames">Regular Expression Typenames</a></li>
<li><a class="reference internal" href="#names-summaries">Names Summaries</a></li>
<li><a class="reference internal" href="#synthetic-children">Synthetic Children</a></li>
<li><a class="reference internal" href="#filters">Filters</a></li>
<li><a class="reference internal" href="#callback-based-type-matching">Callback-based type matching</a></li>
<li><a class="reference internal" href="#objective-c-dynamic-type-discovery">Objective-C Dynamic Type Discovery</a></li>
<li><a class="reference internal" href="#categories">Categories</a></li>
<li><a class="reference internal" href="#finding-formatters-101">Finding Formatters 101</a></li>
</ul>
</li>
</ul>

          </div>
        </div>
      </div>
      
      
    </aside>
  </div>
</div><script src="../_static/documentation_options.js?v=7f41d439"></script>
    <script src="../_static/doctools.js?v=888ff710"></script>
    <script src="../_static/sphinx_highlight.js?v=dc90522c"></script>
    <script src="../_static/scripts/furo.js?v=32e29ea5"></script>
    </body>
</html>