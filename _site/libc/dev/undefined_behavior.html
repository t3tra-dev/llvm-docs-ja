<!DOCTYPE html>

<html lang="en" data-content_root="../">
  <head>
    <meta charset="utf-8" />
    <meta name="viewport" content="width=device-width, initial-scale=1.0" /><meta name="viewport" content="width=device-width, initial-scale=1" />

    <title>Defining Undefined Behavior &#8212; The LLVM C Library</title>
    <link rel="stylesheet" type="text/css" href="../_static/pygments.css?v=d75fae25" />
    <link rel="stylesheet" type="text/css" href="../_static/alabaster.css?v=2e637bd6" />
    <script src="../_static/documentation_options.js?v=5929fcd5"></script>
    <script src="../_static/doctools.js?v=888ff710"></script>
    <script src="../_static/sphinx_highlight.js?v=dc90522c"></script>
    <link rel="index" title="Index" href="../genindex.html" />
    <link rel="search" title="Search" href="../search.html" />
    <link rel="next" title="Printf Behavior Under All Conditions" href="printf_behavior.html" />
    <link rel="prev" title="Convention for implementing entrypoints" href="implementation_standard.html" />
   
  <link rel="stylesheet" href="../_static/custom.css" type="text/css" />
  

  
  

  </head><body>
  

    <div class="document">
      <div class="documentwrapper">
        <div class="bodywrapper">
          

          <div class="body" role="main">
            
  <section id="defining-undefined-behavior">
<h1>Defining Undefined Behavior<a class="headerlink" href="#defining-undefined-behavior" title="Link to this heading">¶</a></h1>
<nav class="contents local" id="table-of-contents">
<p class="topic-title">Table of Contents</p>
<ul class="simple">
<li><p><a class="reference internal" href="#guidelines" id="id1">Guidelines</a></p></li>
<li><p><a class="reference internal" href="#approaches" id="id2">Approaches</a></p>
<ul>
<li><p><a class="reference internal" href="#matching-behavior-against-existing-implementations" id="id3">Matching Behavior Against Existing Implementations</a></p></li>
<li><p><a class="reference internal" href="#simplifying-handling-invalid-inputs" id="id4">Simplifying Handling Invalid Inputs</a></p></li>
<li><p><a class="reference internal" href="#conforming-to-existing-practice" id="id5">Conforming to Existing Practice</a></p></li>
<li><p><a class="reference internal" href="#interpreting-the-standard-s-reasoning" id="id6">Interpreting the Standard’s Reasoning</a></p></li>
<li><p><a class="reference internal" href="#ignoring-bug-for-bug-compatibility" id="id7">Ignoring Bug-For-Bug Compatibility</a></p></li>
</ul>
</li>
<li><p><a class="reference internal" href="#design-decisions" id="id8">Design Decisions</a></p>
<ul>
<li><p><a class="reference internal" href="#resizable-tables-for-hsearch" id="id9">Resizable Tables for hsearch</a></p></li>
<li><p><a class="reference internal" href="#path-without-leading-slashs-in-shm-open" id="id10">Path without Leading Slashs in shm_open</a></p></li>
<li><p><a class="reference internal" href="#handling-of-null-arguments-to-the-s-format-specifier" id="id11">Handling of NULL arguments to the ‘s’ format specifier</a></p></li>
<li><p><a class="reference internal" href="#unknown-math-rounding-direction" id="id12">Unknown Math Rounding Direction</a></p></li>
<li><p><a class="reference internal" href="#non-const-constant-return-values" id="id13">Non-const Constant Return Values</a></p></li>
<li><p><a class="reference internal" href="#unrecognized-clockid-t-values-for-pthread-rwlock-clock-apis" id="id14">Unrecognized <code class="docutils literal notranslate"><span class="pre">clockid_t</span></code> values for <code class="docutils literal notranslate"><span class="pre">pthread_rwlock_clock*</span></code> APIs</a></p></li>
<li><p><a class="reference internal" href="#pthread-spinlock-destroy" id="id15">PThread SpinLock Destroy</a></p></li>
<li><p><a class="reference internal" href="#strftime" id="id16">Strftime</a></p></li>
<li><p><a class="reference internal" href="#a64l-and-l64a" id="id17">a64l and l64a</a></p></li>
</ul>
</li>
</ul>
</nav>
<p>The C standard leaves behavior undefined or implementation defined in many
places. Undefined behavior is behavior that the standards leave up to the
implementation. As an implementation, LLVM’s libc must provide a result for any
input, including inputs for which the result is undefined. This page provides
examples of how these situations are handled in existing code, followed by
guidelines to help determine the right approach for new situations.</p>
<section id="guidelines">
<h2><a class="toc-backref" href="#id1" role="doc-backlink">Guidelines</a><a class="headerlink" href="#guidelines" title="Link to this heading">¶</a></h2>
<p>Most undefined behavior is outside the scope of normal use. Follow these
guidelines and the resulting code should behave predictably even in unexpected
situations.</p>
<ol class="arabic simple">
<li><dl class="simple">
<dt>Follow the standards.</dt><dd><ol class="arabic simple">
<li><p>If there is no standard, first ask yourself if this implementation is necessary (are there users who need this functionality?). If it truly is, then match existing implementations. Creating competing designs just causes confusion (see the history of qsort_r).</p></li>
</ol>
</dd>
</dl>
</li>
<li><dl class="simple">
<dt>Avoid giving an incorrect answer.</dt><dd><ol class="arabic simple">
<li><p>In general, correct answer &gt; correct answer (wrong format) &gt; no answer &gt; crash the program &gt;&gt;&gt;&gt;&gt;&gt;&gt; incorrect answer.</p></li>
<li><p>The C library is called frequently in performance critical situations, and so can’t afford to do thorough error checking and correction.</p></li>
<li><p>It also cannot give the incorrect answer for any reasonable input, since it is so foundational.</p></li>
<li><p>This leaves crashing or address space corruption as a probable option for a libc function in an ambiguous state.</p></li>
</ol>
</dd>
</dl>
</li>
<li><dl class="simple">
<dt>Don’t overcomplicate undefined situations.</dt><dd><ol class="arabic simple">
<li><p>It’s better to have a slightly confusing result for an undefined input than 100 extra lines of code that are never used for a well defined input.</p></li>
<li><p>LLVM’s libc is also used for embedded systems that care a lot about code size.</p></li>
<li><p>Unreasonable inputs can have unreasonable outputs.</p></li>
</ol>
</dd>
</dl>
</li>
<li><dl class="simple">
<dt>Match other implementations when it makes sense.</dt><dd><ol class="arabic simple">
<li><p>Every libc has to make these choices, and sometimes others have already found the right choice.</p></li>
<li><p>Be careful, just because there is a consensus doesn’t make that consensus right.</p></li>
</ol>
</dd>
</dl>
</li>
<li><dl class="simple">
<dt>LLVM’s libc should be consistent with itself.</dt><dd><ol class="arabic simple">
<li><p>Similar inputs to the same function should yield similar results, even when the inputs are undefined.</p></li>
<li><p>The same input to similar functions should also yield similar results.</p></li>
<li><p>The same input to the same function on different platforms should yield the same result, unless there’s a specific reason not to (e.g. 64 bit long vs 32 bit long).</p></li>
</ol>
</dd>
</dl>
</li>
<li><dl class="simple">
<dt>Write down the decision.</dt><dd><ol class="arabic simple">
<li><p>Every libc has to make a decision on how to handle undefined inputs. Users should be able to find what LLVM’s libc does.</p></li>
<li><p>While users shouldn’t rely on undefined behavior, it shouldn’t surprise them.</p></li>
</ol>
</dd>
</dl>
</li>
</ol>
</section>
<section id="approaches">
<h2><a class="toc-backref" href="#id2" role="doc-backlink">Approaches</a><a class="headerlink" href="#approaches" title="Link to this heading">¶</a></h2>
<section id="matching-behavior-against-existing-implementations">
<h3><a class="toc-backref" href="#id3" role="doc-backlink">Matching Behavior Against Existing Implementations</a><a class="headerlink" href="#matching-behavior-against-existing-implementations" title="Link to this heading">¶</a></h3>
<p>Existing implementations have already chosen how to handle undefined situations, and sometimes there are benefits to matching those decisions, such as in the case of atoi. The C Standard defines atoi as being equivalent to a call to strtol, with the result cast from long to int. The standard also clarifies that any input that cannot be represented as an int causes undefined behavior. For the strtol function, the standard instead defines inputs that cannot be represented in a long int as returning LONG_MAX or LONG_MIN, according to their sign. The decision of whether to cast the result from strtol or to handle integer overflow like strtol does is left to the implementation. LLVM’s libc performs the raw cast, since the atoi function is fuzz tested against the implementation from glibc. By matching a known good implementation, LLVM’s libc can more effectively be checked for correctness in this case.</p>
</section>
<section id="simplifying-handling-invalid-inputs">
<h3><a class="toc-backref" href="#id4" role="doc-backlink">Simplifying Handling Invalid Inputs</a><a class="headerlink" href="#simplifying-handling-invalid-inputs" title="Link to this heading">¶</a></h3>
<p>When handling invalid inputs, the output should be simple to code, and simple for the user to understand. An example of this is how the printf function handles invalid conversion specifiers. A conversion specifier is a segment of the format string that starts with a %. At the end of a conversion specifier is the character that determines the behavior for the conversion, called the conversion name. As an example, the conversion specifier %d has the conversion name of d which represents an integer conversion. If the conversion name is instead an invalid character such as ? then the behavior is undefined. When passed an invalid conversion specifier like %? LLVM’s libc defines the output as the raw text of the conversion specifier. This simplifies the algorithm and makes the result obvious and predictable for the user.</p>
</section>
<section id="conforming-to-existing-practice">
<h3><a class="toc-backref" href="#id5" role="doc-backlink">Conforming to Existing Practice</a><a class="headerlink" href="#conforming-to-existing-practice" title="Link to this heading">¶</a></h3>
<p>There are some behaviors that are technically undefined, but are otherwise consistent across implementations, such as how printf handles length modifiers on inappropriate conversions. For each conversion name there is a list of length modifiers that can apply to it. If a length modifier is applied to a conversion specifier that it doesn’t apply to, then the behavior is undefined. For most conversions, LLVM’s libc ignores any length modifier that doesn’t apply. As an example, a conversion of %hf would be read as an f float conversion with the h length modifier. The h length modifier doesn’t apply to floating point conversions and so %hf is the same as %f. There is one exception, which is the L length modifier on integer conversions. Many libcs handle the L length modifier like the ll length modifier when applied to integer conversions, despite L only applying to float conversions in the standard. LLVM’s libc follows this convention because it is a useful feature that is simple to implement and has a predictable outcome for the user.</p>
</section>
<section id="interpreting-the-standard-s-reasoning">
<h3><a class="toc-backref" href="#id6" role="doc-backlink">Interpreting the Standard’s Reasoning</a><a class="headerlink" href="#interpreting-the-standard-s-reasoning" title="Link to this heading">¶</a></h3>
<p>Often the standard will imply an intended behavior through what it states is undefined, such as in the case of printf’s handling of the %% conversion. The %% conversion is used to write a % character, since it’s used as the start of a conversion specifier. The standard specifies that %% must be the complete conversion specifier, and any options would make the conversion undefined. The conversion specifier %10% can therefore be interpreted as a % conversion with a width of 10, but the standard implies that this is not necessary. By making the options undefined, the standard implies a desired behavior for %% with options. The implied behavior is to ignore all options and always print %. This still leaves the behavior of %*% ambiguous, since the star normally consumes an argument to be used as the width. Since % conversions ignore the width, it would be reasonable to not read the argument in this case, but it would add additional complexity to the parsing logic. For that reason, the implementation in LLVM’s libc will consume an argument for %*%, although the value is ignored. Adding additional logic for unreasonable edge cases, such as this one, is unnecessary.</p>
</section>
<section id="ignoring-bug-for-bug-compatibility">
<h3><a class="toc-backref" href="#id7" role="doc-backlink">Ignoring Bug-For-Bug Compatibility</a><a class="headerlink" href="#ignoring-bug-for-bug-compatibility" title="Link to this heading">¶</a></h3>
<p>Any long running implementations will have bugs and deviations from the standard. Hyrum’s Law states that “all observable behaviors of your system will be depended on by somebody” which includes these bugs. An example of a long-standing bug is glibc’s scanf float parsing behavior. The behavior is specifically defined in the standard, but it isn’t adhered to by all libc implementations. There is a longstanding bug in glibc where it incorrectly parses the string 100er and this caused the C standard to add that specific example to the definition for scanf. The intended behavior is for scanf, when parsing a float, to parse the longest possibly valid prefix and then accept it if and only if that complete parsed value is a float. In the case of 100er the longest possibly valid prefix is 100e but the float parsed from that string is only 100. Since there is no number after the e it shouldn’t be included in the float, so scanf should return a parsing error. For LLVM’s libc it was decided to follow the standard, even though glibc’s version is slightly simpler to implement and this edge case is rare. Following the standard must be the first priority, since that’s the goal of the library. If there is no standard, then matching another implementation (even bug-for-bug) may be necessary, but before you implement an unstandardized function first consider if anyone will actually use it at all.</p>
</section>
</section>
<section id="design-decisions">
<h2><a class="toc-backref" href="#id8" role="doc-backlink">Design Decisions</a><a class="headerlink" href="#design-decisions" title="Link to this heading">¶</a></h2>
<section id="resizable-tables-for-hsearch">
<h3><a class="toc-backref" href="#id9" role="doc-backlink">Resizable Tables for hsearch</a><a class="headerlink" href="#resizable-tables-for-hsearch" title="Link to this heading">¶</a></h3>
<p>The POSIX.1 standard does not delineate the behavior consequent to invoking hsearch or hdestroy without prior initialization of the hash table via hcreate. Furthermore, the standard does not specify the outcomes of successive invocations of hsearch absent intervening hdestroy calls. Libraries such as MUSL and Glibc do not apply checks to these scenarios, potentially leading to memory corruption or leakage. Conversely, FreeBSD’s libc and Bionic automatically initialize the hash table to a minimal size if it is found uninitialized, and proceeding to destroy the table only if initialization has occurred. This approach also avoids redundant table allocation if an initialized hash table is already present. Given that the hash table starts with a minimal size, resizing becomes necessary to accommodate additional user insertions. LLVM’s libc mirrors the approach of FreeBSD’s libc and Bionic, owing to its enhanced robustness and user-friendliness. Notably, such resizing behavior itself aligns with POSIX.1 standards, which explicitly permit implementations to modify the capacity of the hash table.</p>
</section>
<section id="path-without-leading-slashs-in-shm-open">
<h3><a class="toc-backref" href="#id10" role="doc-backlink">Path without Leading Slashs in shm_open</a><a class="headerlink" href="#path-without-leading-slashs-in-shm-open" title="Link to this heading">¶</a></h3>
<p>POSIX.1 leaves that when the name of a shared memory object does not begin with a slash, the behavior is implementation defined. In such cases, the shm_open in LLVM libc is implemented to behave as if the name began with a slash.</p>
</section>
<section id="handling-of-null-arguments-to-the-s-format-specifier">
<h3><a class="toc-backref" href="#id11" role="doc-backlink">Handling of NULL arguments to the ‘s’ format specifier</a><a class="headerlink" href="#handling-of-null-arguments-to-the-s-format-specifier" title="Link to this heading">¶</a></h3>
<p>The C standard does not specify behavior for <code class="docutils literal notranslate"><span class="pre">printf(&quot;%s&quot;,</span> <span class="pre">NULL)</span></code>. We will
print the string literal <code class="docutils literal notranslate"><span class="pre">(null)</span></code> unless using the
<code class="docutils literal notranslate"><span class="pre">LIBC_COPT_PRINTF_NO_NULLPTR_CHECKS</span></code> option described in <a class="reference internal" href="printf_behavior.html#printf-behavior"><span class="std std-ref">printf
behavior</span></a>.
TODO: Move this to printf_behavior.</p>
</section>
<section id="unknown-math-rounding-direction">
<h3><a class="toc-backref" href="#id12" role="doc-backlink">Unknown Math Rounding Direction</a><a class="headerlink" href="#unknown-math-rounding-direction" title="Link to this heading">¶</a></h3>
<p>The C23 standard states that if the value of the <code class="docutils literal notranslate"><span class="pre">rnd</span></code> argument of the
<code class="docutils literal notranslate"><span class="pre">fromfp</span></code>, <code class="docutils literal notranslate"><span class="pre">ufromfp</span></code>, <code class="docutils literal notranslate"><span class="pre">fromfpx</span></code> and <code class="docutils literal notranslate"><span class="pre">ufromfpx</span></code> functions is not equal to
the value of a math rounding direction macro, the direction of rounding is
unspecified. LLVM’s libc chooses to use the <code class="docutils literal notranslate"><span class="pre">FP_INT_TONEAREST</span></code> rounding
direction in this case.</p>
</section>
<section id="non-const-constant-return-values">
<h3><a class="toc-backref" href="#id13" role="doc-backlink">Non-const Constant Return Values</a><a class="headerlink" href="#non-const-constant-return-values" title="Link to this heading">¶</a></h3>
<p>Some libc functions, like <code class="docutils literal notranslate"><span class="pre">dlerror()</span></code>, return <code class="docutils literal notranslate"><span class="pre">char</span> <span class="pre">*</span></code> instead of <code class="docutils literal notranslate"><span class="pre">const</span> <span class="pre">char</span> <span class="pre">*</span></code> and then tell the caller they promise not to to modify this value. Any modification of this value is undefined behavior.</p>
</section>
<section id="unrecognized-clockid-t-values-for-pthread-rwlock-clock-apis">
<h3><a class="toc-backref" href="#id14" role="doc-backlink">Unrecognized <code class="docutils literal notranslate"><span class="pre">clockid_t</span></code> values for <code class="docutils literal notranslate"><span class="pre">pthread_rwlock_clock*</span></code> APIs</a><a class="headerlink" href="#unrecognized-clockid-t-values-for-pthread-rwlock-clock-apis" title="Link to this heading">¶</a></h3>
<p>POSIX.1-2024 only demands support for <code class="docutils literal notranslate"><span class="pre">CLOCK_REALTIME</span></code> and <code class="docutils literal notranslate"><span class="pre">CLOCK_MONOTONIC</span></code>. Currently,
as in LLVM libc, if other clock ids are used, they will be treated as monotonic clocks.</p>
</section>
<section id="pthread-spinlock-destroy">
<h3><a class="toc-backref" href="#id15" role="doc-backlink">PThread SpinLock Destroy</a><a class="headerlink" href="#pthread-spinlock-destroy" title="Link to this heading">¶</a></h3>
<p>POSIX.1 Issue 7 updates the spinlock destroy behavior description such that the return code for
uninitialized spinlock and invalid spinlock is left undefined. We follow the recommendation as in
POSIX.1-2024, where EINVAL is returned if the spinlock is invalid (here we only check for null pointers) or
EBUSY is returned if the spinlock is currently locked. The lock is poisoned after a successful destroy. That is,
subsequent operations on the lock object without any reinitialization will return EINVAL.</p>
</section>
<section id="strftime">
<h3><a class="toc-backref" href="#id16" role="doc-backlink">Strftime</a><a class="headerlink" href="#strftime" title="Link to this heading">¶</a></h3>
<p>In the C Standard, it provides a list of modifiers, and the conversions these
are valid on. It also says that a modifier on an unspecified conversion is
undefined. For LLVM-libc, the conversion is treated as if the modifier isn’t
there.</p>
<p>If a struct tm with values out of the normal range is passed, the standard says
the result is undefined. For LLVM-libc, the result may be either the normalized
value (e.g. weekday % 7) or the actual, out of range value. For any numeric
conversion where the result is just printing a value out of the struct
(e.g. “%w” prints the day of the week), no normalization occurs (“%w” on a
tm_wday of 32 prints “32”). For any numeric conversion where the value is
calculated (e.g. “%u” prints the day of the week, starting on monday), the
value is normalized (e.g. “%u” on a tm_wday of 32 prints “4”). For conversions
that result in strings, passing an out of range value will result in “?”.</p>
<p>Posix adds padding support to strftime, but says “the default padding character
is unspecified.” For LLVM-libc, the default padding character is ‘ ‘ (space)
for all string-type conversions and ‘0’ for integer-type conversions. Composite
conversions pass the padding to the first (leftmost) conversion. In practice
this is always a numeric conversion, so it pads with ‘0’. For the purposes of
padding, composite conversions also assume the non-leading conversions have
valid inputs and output their expected number of characters. For %c this means
that the padding will be off if the year is outside of the range -999 to 9999.</p>
<p>The %e conversion is padded with spaces by default, but pads with 0s if the ‘0’
flag is set.</p>
<p>Posix also adds flags and a minimum field width, but leaves unspecified what
happens for most combinations of these. For LLVM-libc:
An unspecified minimum field width defaults to 0.
More specific flags take precedence over less specific flags (i.e. ‘+’ takes precedence over ‘0’)
Any conversion with a minimum width is padded with the padding character until it is at least as long as the minimum width.
Modifiers are applied, then the result is padded if necessary.
Any composite conversion will pass along all flags to the component conversions.</p>
</section>
<section id="a64l-and-l64a">
<h3><a class="toc-backref" href="#id17" role="doc-backlink">a64l and l64a</a><a class="headerlink" href="#a64l-and-l64a" title="Link to this heading">¶</a></h3>
<p>These functions convert to and from a posix-specified base64 encoding. There are
a few cases left undefined. For a64l, the behavior is undefined if the input
pointer (s) is a null pointer. For LLVM-libc this will cause a null pointer
dereference. It’s also undefined if the input pointer to a64l wasn’t generated
by l64a. For LLVM-libc, if the user passes a valid base 64 string, it will be
parsed as normal. For l64a it’s unspecified what happens if the input value is
negative. For LLVM-libc, all inputs to l64a are treated as unsigned 32 bit ints.
Additionally, the return of l64a is in a thread-local buffer that’s overwritten
on each call.</p>
</section>
</section>
</section>


          </div>
          
        </div>
      </div>
      <div class="sphinxsidebar" role="navigation" aria-label="main navigation">
        <div class="sphinxsidebarwrapper">
<h1 class="logo"><a href="../index.html">libc</a></h1>








<h3>Navigation</h3>
<p class="caption" role="heading"><span class="caption-text">Status &amp; Support</span></p>
<ul>
<li class="toctree-l1"><a class="reference internal" href="../headers/index.html">Implementation Status</a></li>
<li class="toctree-l1"><a class="reference internal" href="../arch_support.html">Architecture Support</a></li>
<li class="toctree-l1"><a class="reference internal" href="../platform_support.html">Platform Support</a></li>
<li class="toctree-l1"><a class="reference internal" href="../compiler_support.html">Compiler Support</a></li>
</ul>
<p class="caption" role="heading"><span class="caption-text">Simple Usage</span></p>
<ul>
<li class="toctree-l1"><a class="reference internal" href="../getting_started.html">Getting Started</a></li>
</ul>
<p class="caption" role="heading"><span class="caption-text">Advanced Usage</span></p>
<ul>
<li class="toctree-l1"><a class="reference internal" href="../full_host_build.html">Full Host Build</a></li>
<li class="toctree-l1"><a class="reference internal" href="../full_cross_build.html">Full Cross Build</a></li>
<li class="toctree-l1"><a class="reference internal" href="../overlay_mode.html">Overlay Mode</a></li>
<li class="toctree-l1"><a class="reference internal" href="../gpu/index.html">libc for GPUs</a></li>
<li class="toctree-l1"><a class="reference internal" href="../uefi/index.html">libc for UEFI</a></li>
<li class="toctree-l1"><a class="reference internal" href="../configure.html">Configure Options</a></li>
</ul>
<p class="caption" role="heading"><span class="caption-text">Development</span></p>
<ul class="current">
<li class="toctree-l1"><a class="reference internal" href="../Maintainers.html">LLVM-libc Maintainers</a></li>
<li class="toctree-l1"><a class="reference internal" href="../build_and_test.html">Building and Testing the libc</a></li>
<li class="toctree-l1 current"><a class="reference internal" href="index.html">Developer Guides</a></li>
<li class="toctree-l1"><a class="reference internal" href="../porting.html">Bringup on a New OS or Architecture</a></li>
<li class="toctree-l1"><a class="reference internal" href="../contributing.html">Contributing to the libc Project</a></li>
</ul>
<p class="caption" role="heading"><span class="caption-text">Useful Links</span></p>
<ul>
<li class="toctree-l1"><a class="reference internal" href="../talks.html">Talks</a></li>
<li class="toctree-l1"><a class="reference external" href="https://github.com/llvm/llvm-project/tree/main/libc">Source Code</a></li>
<li class="toctree-l1"><a class="reference external" href="https://github.com/llvm/llvm-project/labels/libc">Bug Reports</a></li>
<li class="toctree-l1"><a class="reference external" href="https://discourse.llvm.org/c/runtimes/libc">Discourse</a></li>
<li class="toctree-l1"><a class="reference external" href="https://discord.gg/xS7Z362">Join the Discord</a></li>
<li class="toctree-l1"><a class="reference external" href="https://discord.com/channels/636084430946959380/636732994891284500">Discord Channel</a></li>
<li class="toctree-l1"><a class="reference external" href="https://lab.llvm.org/buildbot/#/builders?tags=libc">Buildbot</a></li>
</ul>

<div class="relations">
<h3>Related Topics</h3>
<ul>
  <li><a href="../index.html">Documentation overview</a><ul>
  <li><a href="index.html">Developer Guides</a><ul>
      <li>Previous: <a href="implementation_standard.html" title="previous chapter">Convention for implementing entrypoints</a></li>
      <li>Next: <a href="printf_behavior.html" title="next chapter">Printf Behavior Under All Conditions</a></li>
  </ul></li>
  </ul></li>
</ul>
</div>
<div id="searchbox" style="display: none" role="search">
  <h3 id="searchlabel">Quick search</h3>
    <div class="searchformwrapper">
    <form class="search" action="../search.html" method="get">
      <input type="text" name="q" aria-labelledby="searchlabel" autocomplete="off" autocorrect="off" autocapitalize="off" spellcheck="false"/>
      <input type="submit" value="Go" />
    </form>
    </div>
</div>
<script>document.getElementById('searchbox').style.display = "block"</script>








        </div>
      </div>
      <div class="clearer"></div>
    </div>
    <div class="footer">
      &#169;2011-2025, LLVM Project.
      
      |
      Powered by <a href="https://www.sphinx-doc.org/">Sphinx 7.2.6</a>
      &amp; <a href="https://alabaster.readthedocs.io">Alabaster 0.7.16</a>
      
      |
      <a href="../_sources/dev/undefined_behavior.rst.txt"
          rel="nofollow">Page source</a>
    </div>

    

    
  </body>
</html>