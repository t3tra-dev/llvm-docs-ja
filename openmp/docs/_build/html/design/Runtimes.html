<!DOCTYPE html>

<html lang="en" data-content_root="../">
  <head>
    <meta charset="utf-8" />
    <meta name="viewport" content="width=device-width, initial-scale=1.0" /><meta name="viewport" content="width=device-width, initial-scale=1" />

    <title>LLVM/OpenMP Runtimes &#8212; LLVM/OpenMP  documentation</title>
    <link rel="stylesheet" type="text/css" href="../_static/pygments.css?v=d75fae25" />
    <link rel="stylesheet" type="text/css" href="../_static/agogo.css?v=a323ad78" />
    <script src="../_static/documentation_options.js?v=7f41d439"></script>
    <script src="../_static/doctools.js?v=888ff710"></script>
    <script src="../_static/sphinx_highlight.js?v=dc90522c"></script>
    <link rel="index" title="Index" href="../genindex.html" />
    <link rel="search" title="Search" href="../search.html" />
    <link rel="next" title="OpenMP in LLVM — Offloading Design" href="Offloading.html" />
    <link rel="prev" title="OpenMP in LLVM — Design Overview" href="Overview.html" />
<style type="text/css">
  table.right { float: right; margin-left: 20px; }
  table.right td { border: 1px solid #ccc; }
</style>

  </head><body>
    <div class="header-wrapper" role="banner">
      <div class="header">
        <div class="headertitle"><a
          href="../index.html">LLVM/OpenMP  documentation</a></div>
        <div class="rel" role="navigation" aria-label="related navigation">
          <a href="../index.html" title="LLVM OpenMP Documentation">HOME</a>
           |
          <a href="Overview.html" title="OpenMP in LLVM — Design Overview"
             accesskey="P">previous</a> |
          <a href="Offloading.html" title="OpenMP in LLVM — Offloading Design"
             accesskey="N">next</a> |
          <a href="../genindex.html" title="General Index"
             accesskey="I">index</a>
        </div>
       </div>
    </div>

    <div class="content-wrapper">
      <div class="content">
        <div class="document">
            
      <div class="documentwrapper">
        <div class="bodywrapper">
          <div class="body" role="main">
            
  <section id="llvm-openmp-runtimes">
<span id="openmp-runtimes"></span><h1>LLVM/OpenMP Runtimes<a class="headerlink" href="#llvm-openmp-runtimes" title="Link to this heading">¶</a></h1>
<p>There are four distinct types of LLVM/OpenMP runtimes: the host runtime
<a class="reference internal" href="#libomp"><span class="std std-ref">LLVM/OpenMP Host Runtime (libomp)</span></a>, the target offloading runtime <a class="reference internal" href="#libomptarget"><span class="std std-ref">LLVM/OpenMP Target Host Runtime (libomptarget)</span></a>, the target
offloading plugin <a class="reference internal" href="#libomptarget-plugin"><span class="std std-ref">LLVM/OpenMP Target Host Runtime Plugins (libomptarget.rtl.XXXX)</span></a>, and finally the target device
runtime <a class="reference internal" href="#libomptarget-device"><span class="std std-ref">LLVM/OpenMP Target Device Runtime (libomptarget-ARCH-SUBARCH.bc)</span></a>.</p>
<p>For general information on debugging OpenMP target offloading applications, see
<a class="reference internal" href="#libomptarget-info"><span class="std std-ref">LIBOMPTARGET_INFO</span></a> and <a class="reference internal" href="#libomptarget-device-debugging"><span class="std std-ref">Debugging</span></a></p>
<section id="llvm-openmp-host-runtime-libomp">
<span id="libomp"></span><h2>LLVM/OpenMP Host Runtime (<code class="docutils literal notranslate"><span class="pre">libomp</span></code>)<a class="headerlink" href="#llvm-openmp-host-runtime-libomp" title="Link to this heading">¶</a></h2>
<p>An <a class="reference external" href="https://raw.githubusercontent.com/llvm/llvm-project/main/openmp/runtime/doc/Reference.pdf">early (2015) design document</a>
for the LLVM/OpenMP host runtime, aka.  <cite>libomp.so</cite>, is available as a <a class="reference external" href="https://raw.githubusercontent.com/llvm/llvm-project/main/openmp/runtime/doc/Reference.pdf">pdf</a>.</p>
<section id="environment-variables">
<span id="libomp-environment-vars"></span><h3>Environment Variables<a class="headerlink" href="#environment-variables" title="Link to this heading">¶</a></h3>
<section id="omp-cancellation">
<h4>OMP_CANCELLATION<a class="headerlink" href="#omp-cancellation" title="Link to this heading">¶</a></h4>
<p>Enables cancellation of the innermost enclosing region of the type specified.
If set to <code class="docutils literal notranslate"><span class="pre">true</span></code>, the effects of the cancel construct and of cancellation
points are enabled and cancellation is activated. If set to <code class="docutils literal notranslate"><span class="pre">false</span></code>,
cancellation is disabled and the cancel construct and cancellation points are
effectively ignored.</p>
<div class="admonition note">
<p class="admonition-title">Note</p>
<p>Internal barrier code will work differently depending on whether cancellation
is enabled. Barrier code should repeatedly check the global flag to figure
out if cancellation has been triggered. If a thread observes cancellation, it
should leave the barrier prematurely with the return value 1 (and may wake up
other threads). Otherwise, it should leave the barrier with the return value 0.</p>
</div>
<p>Enables (<code class="docutils literal notranslate"><span class="pre">true</span></code>) or disables (<code class="docutils literal notranslate"><span class="pre">false</span></code>) cancellation of the innermost
enclosing region of the type specified.</p>
<p><strong>Default:</strong> <code class="docutils literal notranslate"><span class="pre">false</span></code></p>
</section>
<section id="omp-display-env">
<h4>OMP_DISPLAY_ENV<a class="headerlink" href="#omp-display-env" title="Link to this heading">¶</a></h4>
<p>Enables (<code class="docutils literal notranslate"><span class="pre">true</span></code>) or disables (<code class="docutils literal notranslate"><span class="pre">false</span></code>) the printing to <code class="docutils literal notranslate"><span class="pre">stderr</span></code> of
the OpenMP version number and the values associated with the OpenMP
environment variables.</p>
<p>Possible values are: <code class="docutils literal notranslate"><span class="pre">true</span></code>, <code class="docutils literal notranslate"><span class="pre">false</span></code>, or <code class="docutils literal notranslate"><span class="pre">verbose</span></code>.</p>
<p><strong>Default:</strong> <code class="docutils literal notranslate"><span class="pre">false</span></code></p>
</section>
<section id="omp-default-device">
<h4>OMP_DEFAULT_DEVICE<a class="headerlink" href="#omp-default-device" title="Link to this heading">¶</a></h4>
<p>Sets the device that will be used in a target region. The OpenMP routine
<code class="docutils literal notranslate"><span class="pre">omp_set_default_device</span></code> or a device clause in a parallel pragma can override
this variable. If no device with the specified device number exists, the code is
executed on the host. If this environment variable is not set, device number 0
is used.</p>
</section>
<section id="omp-dynamic">
<h4>OMP_DYNAMIC<a class="headerlink" href="#omp-dynamic" title="Link to this heading">¶</a></h4>
<p>Enables (<code class="docutils literal notranslate"><span class="pre">true</span></code>) or disables (<code class="docutils literal notranslate"><span class="pre">false</span></code>) the dynamic adjustment of the
number of threads.</p>
<div class="line-block">
<div class="line"><strong>Default:</strong> <code class="docutils literal notranslate"><span class="pre">false</span></code></div>
</div>
</section>
<section id="omp-max-active-levels">
<h4>OMP_MAX_ACTIVE_LEVELS<a class="headerlink" href="#omp-max-active-levels" title="Link to this heading">¶</a></h4>
<p>The maximum number of levels of parallel nesting for the program.</p>
<div class="line-block">
<div class="line"><strong>Default:</strong> <code class="docutils literal notranslate"><span class="pre">1</span></code></div>
</div>
</section>
<section id="omp-nested">
<h4>OMP_NESTED<a class="headerlink" href="#omp-nested" title="Link to this heading">¶</a></h4>
<div class="admonition warning">
<p class="admonition-title">Warning</p>
<p>Deprecated. Please use <code class="docutils literal notranslate"><span class="pre">OMP_MAX_ACTIVE_LEVELS</span></code> to control nested parallelism</p>
</div>
<p>Enables (<code class="docutils literal notranslate"><span class="pre">true</span></code>) or disables (<code class="docutils literal notranslate"><span class="pre">false</span></code>) nested parallelism.</p>
<div class="line-block">
<div class="line"><strong>Default:</strong> <code class="docutils literal notranslate"><span class="pre">false</span></code></div>
</div>
</section>
<section id="omp-num-threads">
<h4>OMP_NUM_THREADS<a class="headerlink" href="#omp-num-threads" title="Link to this heading">¶</a></h4>
<p>Sets the maximum number of threads to use for OpenMP parallel regions if no
other value is specified in the application.</p>
<p>The value can be a single integer, in which case it specifies the number of threads
for all parallel regions. The value can also be a comma-separated list of integers,
in which case each integer specifies the number of threads for a parallel
region at that particular nesting level.</p>
<p>The first position in the list represents the outer-most parallel nesting level,
the second position represents the next-inner parallel nesting level, and so on.
At any level, the integer can be left out of the list. If the first integer in a
list is left out, it implies the normal default value for threads is used at the
outer-most level. If the integer is left out of any other level, the number of
threads for that level is inherited from the previous level.</p>
<div class="line-block">
<div class="line"><strong>Default:</strong> The number of processors visible to the operating system on which the program is executed.</div>
<div class="line"><strong>Syntax:</strong> <code class="docutils literal notranslate"><span class="pre">OMP_NUM_THREADS=value[,value]*</span></code></div>
<div class="line"><strong>Example:</strong> <code class="docutils literal notranslate"><span class="pre">OMP_NUM_THREADS=4,3</span></code></div>
</div>
</section>
<section id="omp-places">
<h4>OMP_PLACES<a class="headerlink" href="#omp-places" title="Link to this heading">¶</a></h4>
<p>Specifies an explicit ordered list of places, either as an abstract name
describing a set of places or as an explicit list of places described by
non-negative numbers. An exclusion operator, <code class="docutils literal notranslate"><span class="pre">!</span></code>, can also be used to exclude
the number or place immediately following the operator.</p>
<p>For <strong>explicit lists</strong>, an ordered list of places is specified with each place
represented as a set of non-negative numbers. The non-negative numbers represent
operating system logical processor numbers and can be thought of as an OS affinity mask.</p>
<p>Individual places can be specified through two methods.
Both the <strong>examples</strong> below represent the same place.</p>
<ul class="simple">
<li><p>An explicit list of comma-separated non-negatives numbers <strong>Example:</strong> <code class="docutils literal notranslate"><span class="pre">{0,2,4,6}</span></code></p></li>
<li><p>An interval with notation <code class="docutils literal notranslate"><span class="pre">&lt;lower-bound&gt;:&lt;length&gt;[:&lt;stride&gt;]</span></code>.  <strong>Example:</strong> <code class="docutils literal notranslate"><span class="pre">{0:4:2}</span></code>. When <code class="docutils literal notranslate"><span class="pre">&lt;stride&gt;</span></code> is omitted, a unit stride is assumed.
The interval notation represents this set of numbers:</p></li>
</ul>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="o">&lt;</span><span class="n">lower</span><span class="o">-</span><span class="n">bound</span><span class="o">&gt;</span><span class="p">,</span> <span class="o">&lt;</span><span class="n">lower</span><span class="o">-</span><span class="n">bound</span><span class="o">&gt;</span> <span class="o">+</span> <span class="o">&lt;</span><span class="n">stride</span><span class="o">&gt;</span><span class="p">,</span> <span class="o">...</span><span class="p">,</span> <span class="o">&lt;</span><span class="n">lower</span><span class="o">-</span><span class="n">bound</span><span class="o">&gt;</span> <span class="o">+</span> <span class="p">(</span><span class="o">&lt;</span><span class="n">length</span><span class="o">&gt;</span> <span class="o">-</span> <span class="mi">1</span><span class="p">)</span> <span class="o">*</span> <span class="o">&lt;</span><span class="n">stride</span><span class="o">&gt;</span>
</pre></div>
</div>
<p>A place list can also be specified using the same interval
notation: <code class="docutils literal notranslate"><span class="pre">{place}:&lt;length&gt;[:&lt;stride&gt;]</span></code>.
This represents the list of length <code class="docutils literal notranslate"><span class="pre">&lt;length&gt;</span></code> places determined by the following:</p>
<div class="highlight-c notranslate"><div class="highlight"><pre><span></span><span class="p">{</span><span class="n">place</span><span class="p">},</span><span class="w"> </span><span class="p">{</span><span class="n">place</span><span class="p">}</span><span class="w"> </span><span class="o">+</span><span class="w"> </span><span class="o">&lt;</span><span class="n">stride</span><span class="o">&gt;</span><span class="p">,</span><span class="w"> </span><span class="p">...,</span><span class="w"> </span><span class="p">{</span><span class="n">place</span><span class="p">}</span><span class="w"> </span><span class="o">+</span><span class="w"> </span><span class="p">(</span><span class="o">&lt;</span><span class="n">length</span><span class="o">&gt;</span><span class="mi">-1</span><span class="p">)</span><span class="o">*&lt;</span><span class="n">stride</span><span class="o">&gt;</span>
<span class="n">Where</span><span class="w"> </span><span class="n">given</span><span class="w"> </span><span class="p">{</span><span class="n">place</span><span class="p">}</span><span class="w"> </span><span class="n">and</span><span class="w"> </span><span class="n">integer</span><span class="w"> </span><span class="n">N</span><span class="p">,</span><span class="w"> </span><span class="p">{</span><span class="n">place</span><span class="p">}</span><span class="w"> </span><span class="o">+</span><span class="w"> </span><span class="n">N</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="p">{</span><span class="n">place</span><span class="w"> </span><span class="n">with</span><span class="w"> </span><span class="n">every</span><span class="w"> </span><span class="n">number</span><span class="w"> </span><span class="n">offset</span><span class="w"> </span><span class="n">by</span><span class="w"> </span><span class="n">N</span><span class="p">}</span>
<span class="nl">Example</span><span class="p">:</span><span class="w"> </span><span class="p">{</span><span class="mi">0</span><span class="p">,</span><span class="mi">3</span><span class="p">,</span><span class="mi">6</span><span class="p">}</span><span class="o">:</span><span class="mi">4</span><span class="o">:</span><span class="mi">1</span><span class="w"> </span><span class="n">represents</span><span class="w"> </span><span class="p">{</span><span class="mi">0</span><span class="p">,</span><span class="mi">3</span><span class="p">,</span><span class="mi">6</span><span class="p">},</span><span class="w"> </span><span class="p">{</span><span class="mi">1</span><span class="p">,</span><span class="mi">4</span><span class="p">,</span><span class="mi">7</span><span class="p">},</span><span class="w"> </span><span class="p">{</span><span class="mi">2</span><span class="p">,</span><span class="mi">5</span><span class="p">,</span><span class="mi">8</span><span class="p">},</span><span class="w"> </span><span class="p">{</span><span class="mi">3</span><span class="p">,</span><span class="mi">6</span><span class="p">,</span><span class="mi">9</span><span class="p">}</span>
</pre></div>
</div>
<p><strong>Examples of explicit lists:</strong>
These all represent the same set of places</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="n">OMP_PLACES</span><span class="o">=</span><span class="s2">&quot;{0,1,2,3},{4,5,6,7},{8,9,10,11},{12,13,14,15}&quot;</span>
<span class="n">OMP_PLACES</span><span class="o">=</span><span class="s2">&quot;</span><span class="si">{0:4}</span><span class="s2">,</span><span class="si">{4:4}</span><span class="s2">,</span><span class="si">{8:4}</span><span class="s2">,</span><span class="si">{12:4}</span><span class="s2">&quot;</span>
<span class="n">OMP_PLACES</span><span class="o">=</span><span class="s2">&quot;</span><span class="si">{0:4}</span><span class="s2">:4:4&quot;</span>
</pre></div>
</div>
<div class="admonition note">
<p class="admonition-title">Note</p>
<p>When specifying a place using a set of numbers, if any number cannot be
mapped to a processor on the target platform, then that number is
ignored within the place, but the rest of the place is kept intact.
If all numbers within a place are invalid, then the entire place is removed
from the place list, but the rest of place list is kept intact.</p>
</div>
<p>The <strong>abstract names</strong> listed below are understood by the run-time environment:</p>
<ul class="simple">
<li><p><code class="docutils literal notranslate"><span class="pre">threads:</span></code> Each place corresponds to a single hardware thread.</p></li>
<li><p><code class="docutils literal notranslate"><span class="pre">cores:</span></code> Each place corresponds to a single core (having one or more hardware threads).</p></li>
<li><p><code class="docutils literal notranslate"><span class="pre">sockets:</span></code> Each place corresponds to a single socket (consisting of one or more cores).</p></li>
<li><p><code class="docutils literal notranslate"><span class="pre">numa_domains:</span></code> Each place corresponds to a single NUMA domain (consisting of one or more cores).</p></li>
<li><p><code class="docutils literal notranslate"><span class="pre">ll_caches:</span></code> Each place corresponds to a last-level cache (consisting of one or more cores).</p></li>
</ul>
<p>The abstract name may be appended by a positive number in parentheses to
denote the length of the place list to be created, that is <code class="docutils literal notranslate"><span class="pre">abstract_name(num-places)</span></code>.
If the optional number isn’t specified, then the runtime will use all available
resources of type <code class="docutils literal notranslate"><span class="pre">abstract_name</span></code>. When requesting fewer places than available
on the system, the first available resources as determined by <code class="docutils literal notranslate"><span class="pre">abstract_name</span></code>
are used. When requesting more places than available on the system, only the
available resources are used.</p>
<p><strong>Examples of abstract names:</strong></p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="n">OMP_PLACES</span><span class="o">=</span><span class="n">threads</span>
<span class="n">OMP_PLACES</span><span class="o">=</span><span class="n">threads</span><span class="p">(</span><span class="mi">4</span><span class="p">)</span>
</pre></div>
</div>
</section>
<section id="omp-proc-bind-windows-linux">
<h4>OMP_PROC_BIND (Windows, Linux)<a class="headerlink" href="#omp-proc-bind-windows-linux" title="Link to this heading">¶</a></h4>
<p>Sets the thread affinity policy to be used for parallel regions at the
corresponding nested level. Enables (<code class="docutils literal notranslate"><span class="pre">true</span></code>) or disables (<code class="docutils literal notranslate"><span class="pre">false</span></code>)
the binding of threads to processor contexts. If enabled, this is the
same as specifying <code class="docutils literal notranslate"><span class="pre">KMP_AFFINITY=scatter</span></code>. If disabled, this is the
same as specifying <code class="docutils literal notranslate"><span class="pre">KMP_AFFINITY=none</span></code>.</p>
<p><strong>Acceptable values:</strong> <code class="docutils literal notranslate"><span class="pre">true</span></code>, <code class="docutils literal notranslate"><span class="pre">false</span></code>, or a comma separated list, each
element of which is one of the following values: <code class="docutils literal notranslate"><span class="pre">master</span></code>, <code class="docutils literal notranslate"><span class="pre">close</span></code>, <code class="docutils literal notranslate"><span class="pre">spread</span></code>, or <code class="docutils literal notranslate"><span class="pre">primary</span></code>.</p>
<p><strong>Default:</strong> <code class="docutils literal notranslate"><span class="pre">false</span></code></p>
<div class="admonition warning">
<p class="admonition-title">Warning</p>
<p><code class="docutils literal notranslate"><span class="pre">master</span></code> is deprecated. The semantics of <code class="docutils literal notranslate"><span class="pre">master</span></code> are the same as <code class="docutils literal notranslate"><span class="pre">primary</span></code>.</p>
</div>
<p>If set to <code class="docutils literal notranslate"><span class="pre">false</span></code>, the execution environment may move OpenMP threads between
OpenMP places, thread affinity is disabled, and <code class="docutils literal notranslate"><span class="pre">proc_bind</span></code> clauses on
parallel constructs are ignored. Otherwise, the execution environment should
not move OpenMP threads between OpenMP places, thread affinity is enabled, and
the initial thread is bound to the first place in the OpenMP place list.</p>
<p>If set to <code class="docutils literal notranslate"><span class="pre">primary</span></code>, all threads are bound to the same place as the primary
thread.</p>
<p>If set to <code class="docutils literal notranslate"><span class="pre">close</span></code>, threads are bound to successive places, near where the
primary thread is bound.</p>
<p>If set to <code class="docutils literal notranslate"><span class="pre">spread</span></code>, the primary thread’s partition is subdivided and threads
are bound to single place successive sub-partitions.</p>
<div class="line-block">
<div class="line"><strong>Related environment variables:</strong> <code class="docutils literal notranslate"><span class="pre">KMP_AFFINITY</span></code> (overrides <code class="docutils literal notranslate"><span class="pre">OMP_PROC_BIND</span></code>).</div>
</div>
</section>
<section id="omp-schedule">
<h4>OMP_SCHEDULE<a class="headerlink" href="#omp-schedule" title="Link to this heading">¶</a></h4>
<p>Sets the run-time schedule type and an optional chunk size.</p>
<div class="line-block">
<div class="line"><strong>Default:</strong> <code class="docutils literal notranslate"><span class="pre">static</span></code>, no chunk size specified</div>
<div class="line"><strong>Syntax:</strong> <code class="docutils literal notranslate"><span class="pre">OMP_SCHEDULE=&quot;kind[,chunk_size]&quot;</span></code></div>
</div>
</section>
<section id="omp-stacksize">
<h4>OMP_STACKSIZE<a class="headerlink" href="#omp-stacksize" title="Link to this heading">¶</a></h4>
<p>Sets the number of bytes to allocate for each OpenMP thread to use as the
private stack for the thread. Recommended size is 16M.</p>
<p>Use the optional suffixes to specify byte units: <code class="docutils literal notranslate"><span class="pre">B</span></code> (bytes), <code class="docutils literal notranslate"><span class="pre">K</span></code> (Kilobytes),
<code class="docutils literal notranslate"><span class="pre">M</span></code> (Megabytes), <code class="docutils literal notranslate"><span class="pre">G</span></code> (Gigabytes), or <code class="docutils literal notranslate"><span class="pre">T</span></code> (Terabytes) to specify the units.
If you specify a value without a suffix, the byte unit
is assumed to be <code class="docutils literal notranslate"><span class="pre">K</span></code> (Kilobytes).</p>
<p>This variable does not affect the native operating system threads created by the
user program, or the thread executing the sequential part of an OpenMP program.</p>
<p>The <code class="docutils literal notranslate"><span class="pre">kmp_{set,get}_stacksize_s()</span></code> routines set/retrieve the value.
The <code class="docutils literal notranslate"><span class="pre">kmp_set_stacksize_s()</span></code> routine must be called from sequential part, before
first parallel region is created. Otherwise, calling <code class="docutils literal notranslate"><span class="pre">kmp_set_stacksize_s()</span></code>
has no effect.</p>
<div class="line-block">
<div class="line"><strong>Default:</strong></div>
</div>
<ul class="simple">
<li><p>32-bit architecture: <code class="docutils literal notranslate"><span class="pre">2M</span></code></p></li>
<li><p>64-bit architecture: <code class="docutils literal notranslate"><span class="pre">4M</span></code></p></li>
</ul>
<div class="line-block">
<div class="line"><strong>Related environment variables:</strong> <code class="docutils literal notranslate"><span class="pre">KMP_STACKSIZE</span></code> (overrides <code class="docutils literal notranslate"><span class="pre">OMP_STACKSIZE</span></code>).</div>
<div class="line"><strong>Example:</strong> <code class="docutils literal notranslate"><span class="pre">OMP_STACKSIZE=8M</span></code></div>
</div>
</section>
<section id="omp-thread-limit">
<h4>OMP_THREAD_LIMIT<a class="headerlink" href="#omp-thread-limit" title="Link to this heading">¶</a></h4>
<p>Limits the number of simultaneously-executing threads in an OpenMP program.</p>
<p>If this limit is reached and another native operating system thread encounters
OpenMP API calls or constructs, the program can abort with an error message.
If this limit is reached when an OpenMP parallel region begins, a one-time
warning message might be generated indicating that the number of threads in
the team was reduced, but the program will continue.</p>
<p>The <code class="docutils literal notranslate"><span class="pre">omp_get_thread_limit()</span></code> routine returns the value of the limit.</p>
<div class="line-block">
<div class="line"><strong>Default:</strong> No enforced limit</div>
<div class="line"><strong>Related environment variable:</strong> <code class="docutils literal notranslate"><span class="pre">KMP_ALL_THREADS</span></code> (overrides <code class="docutils literal notranslate"><span class="pre">OMP_THREAD_LIMIT</span></code>).</div>
</div>
</section>
<section id="omp-wait-policy">
<h4>OMP_WAIT_POLICY<a class="headerlink" href="#omp-wait-policy" title="Link to this heading">¶</a></h4>
<p>Decides whether threads spin (active) or yield (passive) while they are waiting.
<code class="docutils literal notranslate"><span class="pre">OMP_WAIT_POLICY=active</span></code> is an alias for <code class="docutils literal notranslate"><span class="pre">KMP_LIBRARY=turnaround</span></code>, and
<code class="docutils literal notranslate"><span class="pre">OMP_WAIT_POLICY=passive</span></code> is an alias for <code class="docutils literal notranslate"><span class="pre">KMP_LIBRARY=throughput</span></code>.</p>
<div class="line-block">
<div class="line"><strong>Default:</strong> <code class="docutils literal notranslate"><span class="pre">passive</span></code></div>
</div>
<div class="admonition note">
<p class="admonition-title">Note</p>
<p>Although the default is <code class="docutils literal notranslate"><span class="pre">passive</span></code>, unless the user has explicitly set
<code class="docutils literal notranslate"><span class="pre">OMP_WAIT_POLICY</span></code>, there is a small period of active spinning determined
by <code class="docutils literal notranslate"><span class="pre">KMP_BLOCKTIME</span></code>.</p>
</div>
</section>
<section id="kmp-affinity-windows-linux">
<h4>KMP_AFFINITY (Windows, Linux)<a class="headerlink" href="#kmp-affinity-windows-linux" title="Link to this heading">¶</a></h4>
<p>Enables run-time library to bind threads to physical processing units.</p>
<p>You must set this environment variable before the first parallel region, or
certain API calls including <code class="docutils literal notranslate"><span class="pre">omp_get_max_threads()</span></code>, <code class="docutils literal notranslate"><span class="pre">omp_get_num_procs()</span></code>
and any affinity API calls.</p>
<p><strong>Syntax:</strong> <code class="docutils literal notranslate"><span class="pre">KMP_AFFINITY=[&lt;modifier&gt;,...]&lt;type&gt;[,&lt;permute&gt;][,&lt;offset&gt;]</span></code></p>
<p><code class="docutils literal notranslate"><span class="pre">modifiers</span></code> are optional strings consisting of a keyword and possibly a specifier</p>
<ul class="simple">
<li><p><code class="docutils literal notranslate"><span class="pre">respect</span></code> (default) and <code class="docutils literal notranslate"><span class="pre">norespect</span></code> - determine whether to respect the original process affinity mask.</p></li>
<li><p><code class="docutils literal notranslate"><span class="pre">verbose</span></code> and <code class="docutils literal notranslate"><span class="pre">noverbose</span></code> (default) - determine whether to display affinity information.</p></li>
<li><p><code class="docutils literal notranslate"><span class="pre">warnings</span></code> (default) and <code class="docutils literal notranslate"><span class="pre">nowarnings</span></code> - determine whether to display warnings during affinity detection.</p></li>
<li><p><code class="docutils literal notranslate"><span class="pre">reset</span></code> and <code class="docutils literal notranslate"><span class="pre">noreset</span></code> (default) - determine whether to reset primary thread’s affinity after outermost parallel region(s)</p></li>
<li><p><code class="docutils literal notranslate"><span class="pre">granularity=&lt;specifier&gt;</span></code> - takes the following specifiers <code class="docutils literal notranslate"><span class="pre">thread</span></code>, <code class="docutils literal notranslate"><span class="pre">core</span></code> (default), <code class="docutils literal notranslate"><span class="pre">tile</span></code>,
<code class="docutils literal notranslate"><span class="pre">socket</span></code>, <code class="docutils literal notranslate"><span class="pre">die</span></code>, <code class="docutils literal notranslate"><span class="pre">group</span></code> (Windows only).
The granularity describes the lowest topology levels that OpenMP threads are allowed to float within a topology map.
For example, if <code class="docutils literal notranslate"><span class="pre">granularity=core</span></code>, then the OpenMP threads will be allowed to move between logical processors within
a single core. If <code class="docutils literal notranslate"><span class="pre">granularity=thread</span></code>, then the OpenMP threads will be restricted to a single logical processor.</p></li>
<li><p><code class="docutils literal notranslate"><span class="pre">proclist=[&lt;proc_list&gt;]</span></code> - The <code class="docutils literal notranslate"><span class="pre">proc_list</span></code> is specified by</p></li>
</ul>
<table class="docutils align-default">
<thead>
<tr class="row-odd"><th class="head"><p>Value</p></th>
<th class="head"><p>Description</p></th>
</tr>
</thead>
<tbody>
<tr class="row-even"><td><p>&lt;proc_list&gt; :=</p></td>
<td><p>&lt;proc_id&gt; | { &lt;id_list&gt; }</p></td>
</tr>
<tr class="row-odd"><td><p>&lt;id_list&gt; :=</p></td>
<td><p>&lt;proc_id&gt; | &lt;proc_id&gt;,&lt;id_list&gt;</p></td>
</tr>
</tbody>
</table>
<p>Where each <code class="docutils literal notranslate"><span class="pre">proc_id</span></code> represents an operating system logical processor ID.
For example, <code class="docutils literal notranslate"><span class="pre">proclist=[3,0,{1,2},{0,3}]</span></code> with <code class="docutils literal notranslate"><span class="pre">OMP_NUM_THREADS=4</span></code> would place thread 0 on
OS logical processor 3, thread 1 on OS logical processor 0, thread 2 on both OS logical
processors 1 &amp; 2, and thread 3 on OS logical processors 0 &amp; 3.</p>
<p><code class="docutils literal notranslate"><span class="pre">type</span></code> is the thread affinity policy to choose.
Valid choices are <code class="docutils literal notranslate"><span class="pre">none</span></code>, <code class="docutils literal notranslate"><span class="pre">balanced</span></code>, <code class="docutils literal notranslate"><span class="pre">compact</span></code>, <code class="docutils literal notranslate"><span class="pre">scatter</span></code>, <code class="docutils literal notranslate"><span class="pre">explicit</span></code>, <code class="docutils literal notranslate"><span class="pre">disabled</span></code></p>
<ul class="simple">
<li><p>type <code class="docutils literal notranslate"><span class="pre">none</span></code> (default) - Does not bind OpenMP threads to particular thread contexts;
however, if the operating system supports affinity, the compiler still uses the
OpenMP thread affinity interface to determine machine topology.
Specify <code class="docutils literal notranslate"><span class="pre">KMP_AFFINITY=verbose,none</span></code> to list a machine topology map.</p></li>
<li><p>type <code class="docutils literal notranslate"><span class="pre">compact</span></code> - Specifying compact assigns the OpenMP thread &lt;n&gt;+1 to a free thread
context as close as possible to the thread context where the &lt;n&gt; OpenMP thread was
placed. For example, in a topology map, the nearer a node is to the root, the more
significance the node has when sorting the threads.</p></li>
<li><p>type <code class="docutils literal notranslate"><span class="pre">scatter</span></code> - Specifying scatter distributes the threads as evenly as
possible across the entire system. <code class="docutils literal notranslate"><span class="pre">scatter</span></code> is the opposite of <code class="docutils literal notranslate"><span class="pre">compact</span></code>; so the
leaves of the node are most significant when sorting through the machine topology map.</p></li>
<li><p>type <code class="docutils literal notranslate"><span class="pre">balanced</span></code> - Places threads on separate cores until all cores have at least one thread,
similar to the <code class="docutils literal notranslate"><span class="pre">scatter</span></code> type. However, when the runtime must use multiple hardware thread
contexts on the same core, the balanced type ensures that the OpenMP thread numbers are close
to each other, which scatter does not do. This affinity type is supported on the CPU only for
single socket systems.</p></li>
<li><p>type <code class="docutils literal notranslate"><span class="pre">explicit</span></code> - Specifying explicit assigns OpenMP threads to a list of OS proc IDs that
have been explicitly specified by using the <code class="docutils literal notranslate"><span class="pre">proclist</span></code> modifier, which is required
for this affinity type.</p></li>
<li><p>type <code class="docutils literal notranslate"><span class="pre">disabled</span></code> - Specifying disabled completely disables the thread affinity interfaces.
This forces the OpenMP run-time library to behave as if the affinity interface was not
supported by the operating system. This includes the low-level API interfaces such
as <code class="docutils literal notranslate"><span class="pre">kmp_set_affinity</span></code> and <code class="docutils literal notranslate"><span class="pre">kmp_get_affinity</span></code>, which have no effect and will return
a nonzero error code.</p></li>
</ul>
<p>For both <code class="docutils literal notranslate"><span class="pre">compact</span></code> and <code class="docutils literal notranslate"><span class="pre">scatter</span></code>, <code class="docutils literal notranslate"><span class="pre">permute</span></code> and <code class="docutils literal notranslate"><span class="pre">offset</span></code> are allowed;
however, if you specify only one integer, the runtime interprets the value as
a permute specifier. <strong>Both permute and offset default to 0.</strong></p>
<p>The <code class="docutils literal notranslate"><span class="pre">permute</span></code> specifier controls which levels are most significant when sorting
the machine topology map. A value for <code class="docutils literal notranslate"><span class="pre">permute</span></code> forces the mappings to make the
specified number of most significant levels of the sort the least significant,
and it inverts the order of significance. The root node of the tree is not
considered a separate level for the sort operations.</p>
<p>The <code class="docutils literal notranslate"><span class="pre">offset</span></code> specifier indicates the starting position for thread assignment.</p>
<div class="line-block">
<div class="line"><strong>Default:</strong> <code class="docutils literal notranslate"><span class="pre">noverbose,warnings,respect,granularity=core,none</span></code></div>
<div class="line"><strong>Related environment variable:</strong> <code class="docutils literal notranslate"><span class="pre">OMP_PROC_BIND</span></code> (<code class="docutils literal notranslate"><span class="pre">KMP_AFFINITY</span></code> takes precedence)</div>
</div>
<div class="admonition note">
<p class="admonition-title">Note</p>
<p>On Windows with multiple processor groups, the norespect affinity modifier
is assumed when the process affinity mask equals a single processor group
(which is default on Windows). Otherwise, the respect affinity modifier is used.</p>
</div>
<div class="admonition note">
<p class="admonition-title">Note</p>
<p>On Windows with multiple processor groups, if the granularity is too coarse, it
will be set to <code class="docutils literal notranslate"><span class="pre">granularity=group</span></code>. For example, if two processor groups exist
across one socket, and <code class="docutils literal notranslate"><span class="pre">granularity=socket</span></code> the runtime will shift the
granularity down to group since that is the largest granularity allowed by the OS.</p>
</div>
</section>
<section id="kmp-hidden-helper-affinity-windows-linux">
<h4>KMP_HIDDEN_HELPER_AFFINITY (Windows, Linux)<a class="headerlink" href="#kmp-hidden-helper-affinity-windows-linux" title="Link to this heading">¶</a></h4>
<p>Enables run-time library to bind hidden helper threads to physical processing units.
This environment variable has the same syntax and semantics as <code class="docutils literal notranslate"><span class="pre">KMP_AFFINIY</span></code> but only
applies to the hidden helper team.</p>
<p>You must set this environment variable before the first parallel region, or
certain API calls including <code class="docutils literal notranslate"><span class="pre">omp_get_max_threads()</span></code>, <code class="docutils literal notranslate"><span class="pre">omp_get_num_procs()</span></code>
and any affinity API calls.</p>
<p><strong>Syntax:</strong> Same as <code class="docutils literal notranslate"><span class="pre">KMP_AFFINITY</span></code></p>
<p>The following <code class="docutils literal notranslate"><span class="pre">modifiers</span></code> are ignored in <code class="docutils literal notranslate"><span class="pre">KMP_HIDDEN_HELPER_AFFINITY</span></code> and are only valid
for <code class="docutils literal notranslate"><span class="pre">KMP_AFFINITY</span></code>:
* <code class="docutils literal notranslate"><span class="pre">respect</span></code> and <code class="docutils literal notranslate"><span class="pre">norespect</span></code>
* <code class="docutils literal notranslate"><span class="pre">reset</span></code> and <code class="docutils literal notranslate"><span class="pre">noreset</span></code></p>
</section>
<section id="kmp-all-threads">
<h4>KMP_ALL_THREADS<a class="headerlink" href="#kmp-all-threads" title="Link to this heading">¶</a></h4>
<p>Limits the number of simultaneously-executing threads in an OpenMP program.
If this limit is reached and another native operating system thread encounters
OpenMP API calls or constructs, then the program may abort with an error
message. If this limit is reached at the time an OpenMP parallel region begins,
a one-time warning message may be generated indicating that the number of
threads in the team was reduced, but the program will continue execution.</p>
<div class="line-block">
<div class="line"><strong>Default:</strong> No enforced limit.</div>
<div class="line"><strong>Related environment variable:</strong> <code class="docutils literal notranslate"><span class="pre">OMP_THREAD_LIMIT</span></code> (<code class="docutils literal notranslate"><span class="pre">KMP_ALL_THREADS</span></code> takes precedence)</div>
</div>
</section>
<section id="kmp-blocktime">
<h4>KMP_BLOCKTIME<a class="headerlink" href="#kmp-blocktime" title="Link to this heading">¶</a></h4>
<p>Sets the time that a thread should wait, after completing the
execution of a parallel region, before sleeping.</p>
<p>Use the optional suffixes: <code class="docutils literal notranslate"><span class="pre">ms</span></code> (milliseconds), or <code class="docutils literal notranslate"><span class="pre">us</span></code> (microseconds) to
specify/change the units. Defaults units is milliseconds.</p>
<p>Specify <code class="docutils literal notranslate"><span class="pre">infinite</span></code> for an unlimited wait time.</p>
<div class="line-block">
<div class="line"><strong>Default:</strong> 200 milliseconds</div>
<div class="line"><strong>Related Environment Variable:</strong> <code class="docutils literal notranslate"><span class="pre">KMP_LIBRARY</span></code></div>
<div class="line"><strong>Example:</strong> <code class="docutils literal notranslate"><span class="pre">KMP_BLOCKTIME=1ms</span></code></div>
</div>
</section>
<section id="kmp-cpuinfo-file">
<h4>KMP_CPUINFO_FILE<a class="headerlink" href="#kmp-cpuinfo-file" title="Link to this heading">¶</a></h4>
<p>Specifies an alternate file name for a file containing the machine topology
description. The file must be in the same format as <code class="file docutils literal notranslate"><span class="pre">/proc/cpuinfo</span></code>.</p>
<p><strong>Default:</strong> None</p>
</section>
<section id="kmp-deterministic-reduction">
<h4>KMP_DETERMINISTIC_REDUCTION<a class="headerlink" href="#kmp-deterministic-reduction" title="Link to this heading">¶</a></h4>
<p>Enables (<code class="docutils literal notranslate"><span class="pre">true</span></code>) or disables (<code class="docutils literal notranslate"><span class="pre">false</span></code>) the use of a specific ordering of
the reduction operations for implementing the reduction clause for an OpenMP
parallel region. This has the effect that, for a given number of threads, in
a given parallel region, for a given data set and reduction operation, a
floating point reduction done for an OpenMP reduction clause has a consistent
floating point result from run to run, since round-off errors are identical.</p>
<div class="line-block">
<div class="line"><strong>Default:</strong> <code class="docutils literal notranslate"><span class="pre">false</span></code></div>
<div class="line"><strong>Example:</strong> <code class="docutils literal notranslate"><span class="pre">KMP_DETERMINISTIC_REDUCTION=true</span></code></div>
</div>
</section>
<section id="kmp-dynamic-mode">
<h4>KMP_DYNAMIC_MODE<a class="headerlink" href="#kmp-dynamic-mode" title="Link to this heading">¶</a></h4>
<p>Selects the method used to determine the number of threads to use for a parallel
region when <code class="docutils literal notranslate"><span class="pre">OMP_DYNAMIC=true</span></code>. Possible values: (<code class="docutils literal notranslate"><span class="pre">load_balance</span></code> | <code class="docutils literal notranslate"><span class="pre">thread_limit</span></code>), where,</p>
<ul class="simple">
<li><p><code class="docutils literal notranslate"><span class="pre">load_balance</span></code>: tries to avoid using more threads than available execution units on the machine;</p></li>
<li><p><code class="docutils literal notranslate"><span class="pre">thread_limit</span></code>: tries to avoid using more threads than total execution units on the machine.</p></li>
</ul>
<p><strong>Default:</strong> <code class="docutils literal notranslate"><span class="pre">load_balance</span></code> (on all supported platforms)</p>
</section>
<section id="kmp-hot-teams-max-level">
<h4>KMP_HOT_TEAMS_MAX_LEVEL<a class="headerlink" href="#kmp-hot-teams-max-level" title="Link to this heading">¶</a></h4>
<p>Sets the maximum nested level to which teams of threads will be hot.</p>
<div class="admonition note">
<p class="admonition-title">Note</p>
<p>A hot team is a team of threads optimized for faster reuse by subsequent
parallel regions. In a hot team, threads are kept ready for execution of
the next parallel region, in contrast to the cold team, which is freed
after each parallel region, with its threads going into a common pool
of threads.</p>
</div>
<p>For values of 2 and above, nested parallelism should be enabled.</p>
<p><strong>Default:</strong> 1</p>
</section>
<section id="kmp-hot-teams-mode">
<h4>KMP_HOT_TEAMS_MODE<a class="headerlink" href="#kmp-hot-teams-mode" title="Link to this heading">¶</a></h4>
<p>Specifies the run-time behavior when the number of threads in a hot team is reduced.
Possible values:</p>
<ul class="simple">
<li><p><code class="docutils literal notranslate"><span class="pre">0</span></code> - Extra threads are freed and put into a common pool of threads.</p></li>
<li><p><code class="docutils literal notranslate"><span class="pre">1</span></code> - Extra threads are kept in the team in reserve, for faster reuse
in subsequent parallel regions.</p></li>
</ul>
<p><strong>Default:</strong> 0</p>
</section>
<section id="kmp-hw-subset">
<h4>KMP_HW_SUBSET<a class="headerlink" href="#kmp-hw-subset" title="Link to this heading">¶</a></h4>
<p>Specifies the subset of available hardware resources for the hardware topology
hierarchy. The subset is specified in terms of number of units per upper layer
unit starting from top layer downwards. E.g. the number of sockets (top layer
units), cores per socket, and the threads per core, to use with an OpenMP
application, as an alternative to writing complicated explicit affinity settings
or a limiting process affinity mask. You can also specify an offset value to set
which resources to use. When available, you can specify attributes to select
different subsets of resources.</p>
<p>An extended syntax is available when <code class="docutils literal notranslate"><span class="pre">KMP_TOPOLOGY_METHOD=hwloc</span></code>. Depending on what
resources are detected, you may be able to specify additional resources, such as
NUMA domains and groups of hardware resources that share certain cache levels.</p>
<p><strong>Basic syntax:</strong> <code class="docutils literal notranslate"><span class="pre">[:][num_units|*]ID[&#64;offset][:attribute]</span> <span class="pre">[,[num_units|*]ID[&#64;offset][:attribute]...]</span></code></p>
<p>An optional colon (:) can be specified at the beginning of the syntax to specify an explicit hardware subset. The default is an implicit hardware subset.</p>
<p>Supported unit IDs are not case-insensitive.</p>
<div class="line-block">
<div class="line"><code class="docutils literal notranslate"><span class="pre">S</span></code> - socket</div>
<div class="line"><code class="docutils literal notranslate"><span class="pre">num_units</span></code> specifies the requested number of sockets.</div>
</div>
<div class="line-block">
<div class="line"><code class="docutils literal notranslate"><span class="pre">D</span></code> - die</div>
<div class="line"><code class="docutils literal notranslate"><span class="pre">num_units</span></code> specifies the requested number of dies per socket.</div>
</div>
<div class="line-block">
<div class="line"><code class="docutils literal notranslate"><span class="pre">C</span></code> - core</div>
<div class="line"><code class="docutils literal notranslate"><span class="pre">num_units</span></code> specifies the requested number of cores per die - if any - otherwise, per socket.</div>
</div>
<div class="line-block">
<div class="line"><code class="docutils literal notranslate"><span class="pre">T</span></code> - thread</div>
<div class="line"><code class="docutils literal notranslate"><span class="pre">num_units</span></code> specifies the requested number of HW threads per core.</div>
</div>
<div class="admonition note">
<p class="admonition-title">Note</p>
<p><code class="docutils literal notranslate"><span class="pre">num_units</span></code> can be left out or explicitly specified as <code class="docutils literal notranslate"><span class="pre">*</span></code> instead of a positive integer
meaning use all specified resources at that level.
e.g., <code class="docutils literal notranslate"><span class="pre">1s,*c</span></code> means use 1 socket and all the cores on that socket</p>
</div>
<p><code class="docutils literal notranslate"><span class="pre">offset</span></code> - (Optional) The number of units to skip.</p>
<p><code class="docutils literal notranslate"><span class="pre">attribute</span></code> - (Optional) An attribute differentiating resources at a particular level. The attributes available to users are:</p>
<ul class="simple">
<li><p><strong>Core type</strong> - On Intel architectures, this can be <code class="docutils literal notranslate"><span class="pre">intel_atom</span></code> or <code class="docutils literal notranslate"><span class="pre">intel_core</span></code></p></li>
<li><p><strong>Core efficiency</strong> - This is specified as <code class="docutils literal notranslate"><span class="pre">eff</span></code><em>num</em> where <em>num</em> is a number from 0
to the number of core efficiencies detected in the machine topology minus one.
E.g., <code class="docutils literal notranslate"><span class="pre">eff0</span></code>. The greater the efficiency number the more performant the core. There may be
more core efficiencies than core types and can be viewed by setting <code class="docutils literal notranslate"><span class="pre">KMP_AFFINITY=verbose</span></code></p></li>
</ul>
<div class="admonition note">
<p class="admonition-title">Note</p>
<p>The hardware cache can be specified as a unit, e.g. L2 for L2 cache,
or LL for last level cache.</p>
</div>
<p><strong>Extended syntax when KMP_TOPOLOGY_METHOD=hwloc:</strong></p>
<p>Additional IDs can be specified if detected. For example:</p>
<p><code class="docutils literal notranslate"><span class="pre">N</span></code> - numa
<code class="docutils literal notranslate"><span class="pre">num_units</span></code> specifies the requested number of NUMA nodes per upper layer
unit, e.g. per socket.</p>
<p><code class="docutils literal notranslate"><span class="pre">TI</span></code> - tile
num_units specifies the requested number of tiles to use per upper layer
unit, e.g. per NUMA node.</p>
<p>When any numa or tile units are specified in <code class="docutils literal notranslate"><span class="pre">KMP_HW_SUBSET</span></code> and the hwloc
topology method is available, the <code class="docutils literal notranslate"><span class="pre">KMP_TOPOLOGY_METHOD</span></code> will be automatically
set to hwloc, so there is no need to set it explicitly.</p>
<p>For an <strong>explicit hardware subset</strong>, if one or more topology layers detected by the
runtime are omitted from the subset, then those topology layers are ignored.
Only explicitly specified topology layers are used in the subset.</p>
<p>For an <strong>implicit hardware subset</strong>, it is implied that the socket, core, and thread
topology types should be included in the subset. Other topology layers are not
implicitly included and are ignored if they are not specified in the subset.
Because the socket, core and thread topology types are always included in
implicit hardware subsets, when they are omitted, it is assumed that all
available resources of that type should be used. Implicit hardware subsets are
the default.</p>
<p>If you don’t specify one or more types of resource, such as socket or thread,
all available resources of that type are used.</p>
<p>The run-time library prints a warning, and the setting of
<code class="docutils literal notranslate"><span class="pre">KMP_HW_SUBSET</span></code> is ignored if:</p>
<ul class="simple">
<li><p>a resource is specified, but detection of that resource is not supported
by the chosen topology detection method and/or</p></li>
<li><p>a resource is specified twice. An exception to this condition is if attributes
differentiate the resource.</p></li>
<li><p>attributes are used when not detected in the machine topology or conflict with
each other.</p></li>
</ul>
<p>This variable does not work if <code class="docutils literal notranslate"><span class="pre">KMP_AFFINITY=disabled</span></code>.</p>
<p><strong>Default:</strong> If omitted, the default value is to use all the
available hardware resources.</p>
<p><strong>Implicit Hardware Subset Examples:</strong></p>
<ul class="simple">
<li><p><code class="docutils literal notranslate"><span class="pre">2s,4c,2t</span></code>: Use the first 2 sockets (s0 and s1), the first 4 cores on each
socket (c0 - c3), and 2 threads per core.</p></li>
<li><p><code class="docutils literal notranslate"><span class="pre">2s&#64;2,4c&#64;8,2t</span></code>: Skip the first 2 sockets (s0 and s1) and use 2 sockets
(s2-s3), skip the first 8 cores (c0-c7) and use 4 cores on each socket
(c8-c11), and use 2 threads per core.</p></li>
<li><p><code class="docutils literal notranslate"><span class="pre">5C&#64;1,3T</span></code>: Use all available sockets, skip the first core and use 5 cores,
and use 3 threads per core.</p></li>
<li><p><code class="docutils literal notranslate"><span class="pre">1T</span></code>: Use all cores on all sockets, 1 thread per core.</p></li>
<li><p><code class="docutils literal notranslate"><span class="pre">1s,</span> <span class="pre">1d,</span> <span class="pre">1n,</span> <span class="pre">1c,</span> <span class="pre">1t</span></code>: Use 1 socket, 1 die, 1 NUMA node, 1 core, 1 thread
- use HW thread as a result.</p></li>
<li><p><code class="docutils literal notranslate"><span class="pre">4c:intel_atom,5c:intel_core</span></code>: Use all available sockets and use 4
Intel Atom(R) processor cores and 5 Intel(R) Core(TM) processor cores per socket.</p></li>
<li><p><code class="docutils literal notranslate"><span class="pre">2c:eff0&#64;1,3c:eff1</span></code>: Use all available sockets, skip the first core with efficiency 0
and use the next 2 cores with efficiency 0 and 3 cores with efficiency 1 per socket.</p></li>
<li><p><code class="docutils literal notranslate"><span class="pre">1s,</span> <span class="pre">1c,</span> <span class="pre">1t</span></code>: Use 1 socket, 1 core, 1 thread. This may result in using
single thread on a 3-layer topology architecture, or multiple threads on
4-layer or 5-layer architecture. Result may even be different on the same
architecture, depending on <code class="docutils literal notranslate"><span class="pre">KMP_TOPOLOGY_METHOD</span></code> specified, as hwloc can
often detect more topology layers than the default method used by the OpenMP
run-time library.</p></li>
<li><p><code class="docutils literal notranslate"><span class="pre">*c:eff1&#64;3</span></code>: Use all available sockets, skip the first three cores of
efficiency 1, and then use the rest of the available cores of efficiency 1.</p></li>
</ul>
<p>Explicit Hardware Subset Examples:</p>
<ul class="simple">
<li><p><code class="docutils literal notranslate"><span class="pre">:2s,6t</span></code> Use exactly the first two sockets and 6 threads per socket.</p></li>
<li><p><code class="docutils literal notranslate"><span class="pre">:1t&#64;7</span></code> Skip the first 7 threads (t0-t6) and use exactly one thread (t7).</p></li>
<li><p><code class="docutils literal notranslate"><span class="pre">:5c,1t</span></code> Use exactly the first 5 cores (c0-c4) and the first thread on each core.</p></li>
</ul>
<p>To see the result of the setting, you can specify <code class="docutils literal notranslate"><span class="pre">verbose</span></code> modifier in
<code class="docutils literal notranslate"><span class="pre">KMP_AFFINITY</span></code> environment variable. The OpenMP run-time library will output
to <code class="docutils literal notranslate"><span class="pre">stderr</span></code> the information about the discovered hardware topology before and
after the <code class="docutils literal notranslate"><span class="pre">KMP_HW_SUBSET</span></code> setting was applied.</p>
</section>
<section id="kmp-inherit-fp-control">
<h4>KMP_INHERIT_FP_CONTROL<a class="headerlink" href="#kmp-inherit-fp-control" title="Link to this heading">¶</a></h4>
<p>Enables (<code class="docutils literal notranslate"><span class="pre">true</span></code>) or disables (<code class="docutils literal notranslate"><span class="pre">false</span></code>) the copying of the floating-point
control settings of the primary thread to the floating-point control settings
of the OpenMP worker threads at the start of each parallel region.</p>
<p><strong>Default:</strong> <code class="docutils literal notranslate"><span class="pre">true</span></code></p>
</section>
<section id="kmp-library">
<h4>KMP_LIBRARY<a class="headerlink" href="#kmp-library" title="Link to this heading">¶</a></h4>
<p>Selects the OpenMP run-time library execution mode. The values for this variable
are <code class="docutils literal notranslate"><span class="pre">serial</span></code>, <code class="docutils literal notranslate"><span class="pre">turnaround</span></code>, or <code class="docutils literal notranslate"><span class="pre">throughput</span></code>.</p>
<div class="line-block">
<div class="line"><strong>Default:</strong> <code class="docutils literal notranslate"><span class="pre">throughput</span></code></div>
<div class="line"><strong>Related environment variable:</strong> <code class="docutils literal notranslate"><span class="pre">KMP_BLOCKTIME</span></code> and <code class="docutils literal notranslate"><span class="pre">OMP_WAIT_POLICY</span></code></div>
</div>
</section>
<section id="kmp-settings">
<h4>KMP_SETTINGS<a class="headerlink" href="#kmp-settings" title="Link to this heading">¶</a></h4>
<p>Enables (<code class="docutils literal notranslate"><span class="pre">true</span></code>) or disables (<code class="docutils literal notranslate"><span class="pre">false</span></code>) the printing of OpenMP run-time library
environment variables during program execution. Two lists of variables are printed:
user-defined environment variables settings and effective values of variables used
by OpenMP run-time library.</p>
<p><strong>Default:</strong> <code class="docutils literal notranslate"><span class="pre">false</span></code></p>
</section>
<section id="kmp-stacksize">
<h4>KMP_STACKSIZE<a class="headerlink" href="#kmp-stacksize" title="Link to this heading">¶</a></h4>
<p>Sets the number of bytes to allocate for each OpenMP thread to use as its private stack.</p>
<p>Recommended size is <code class="docutils literal notranslate"><span class="pre">16M</span></code>.</p>
<p>Use the optional suffixes to specify byte units: <code class="docutils literal notranslate"><span class="pre">B</span></code> (bytes), <code class="docutils literal notranslate"><span class="pre">K</span></code> (Kilobytes),
<code class="docutils literal notranslate"><span class="pre">M</span></code> (Megabytes), <code class="docutils literal notranslate"><span class="pre">G</span></code> (Gigabytes), or <code class="docutils literal notranslate"><span class="pre">T</span></code> (Terabytes) to specify the units.
If you specify a value without a suffix, the byte unit is assumed to be K (Kilobytes).</p>
<p><strong>Related environment variable:</strong> <code class="docutils literal notranslate"><span class="pre">KMP_STACKSIZE</span></code> overrides <code class="docutils literal notranslate"><span class="pre">GOMP_STACKSIZE</span></code>, which
overrides <code class="docutils literal notranslate"><span class="pre">OMP_STACKSIZE</span></code>.</p>
<p><strong>Default:</strong></p>
<ul class="simple">
<li><p>32-bit architectures: <code class="docutils literal notranslate"><span class="pre">2M</span></code></p></li>
<li><p>64-bit architectures: <code class="docutils literal notranslate"><span class="pre">4M</span></code></p></li>
</ul>
</section>
<section id="kmp-topology-method">
<h4>KMP_TOPOLOGY_METHOD<a class="headerlink" href="#kmp-topology-method" title="Link to this heading">¶</a></h4>
<p>Forces OpenMP to use a particular machine topology modeling method.</p>
<p>Possible values are:</p>
<ul class="simple">
<li><p><code class="docutils literal notranslate"><span class="pre">all</span></code> - Let OpenMP choose which topology method is most appropriate
based on the platform and possibly other environment variable settings.</p></li>
<li><p><code class="docutils literal notranslate"><span class="pre">cpuid_leaf31</span></code> (x86 only) - Decodes the APIC identifiers as specified by leaf 31 of the
cpuid instruction. The runtime will produce an error if the machine does not support leaf 31.</p></li>
<li><p><code class="docutils literal notranslate"><span class="pre">cpuid_leaf11</span></code> (x86 only) - Decodes the APIC identifiers as specified by leaf 11 of the
cpuid instruction. The runtime will produce an error if the machine does not support leaf 11.</p></li>
<li><p><code class="docutils literal notranslate"><span class="pre">cpuid_leaf4</span></code> (x86 only) - Decodes the APIC identifiers as specified in leaf 4
of the cpuid instruction. The runtime will produce an error if the machine does not support leaf 4.</p></li>
<li><p><code class="docutils literal notranslate"><span class="pre">cpuinfo</span></code> - If <code class="docutils literal notranslate"><span class="pre">KMP_CPUINFO_FILE</span></code> is not specified, forces OpenMP to
parse <code class="file docutils literal notranslate"><span class="pre">/proc/cpuinfo</span></code> to determine the topology (Linux only).
If <code class="docutils literal notranslate"><span class="pre">KMP_CPUINFO_FILE</span></code> is specified as described above, uses it (Windows or Linux).</p></li>
<li><p><code class="docutils literal notranslate"><span class="pre">group</span></code> - Models the machine as a 2-level map, with level 0 specifying the
different processors in a group, and level 1 specifying the different
groups (Windows 64-bit only).</p></li>
</ul>
<div class="admonition note">
<p class="admonition-title">Note</p>
<p>Support for group is now deprecated and will be removed in a future release. Use all instead.</p>
</div>
<ul class="simple">
<li><p><code class="docutils literal notranslate"><span class="pre">flat</span></code> - Models the machine as a flat (linear) list of processors.</p></li>
<li><p><code class="docutils literal notranslate"><span class="pre">hwloc</span></code> - Models the machine as the Portable Hardware Locality (hwloc) library does.
This model is the most detailed and includes, but is not limited to: numa domains,
packages, cores, hardware threads, caches, and Windows processor groups. This method is
only available if you have configured libomp to use hwloc during CMake configuration.</p></li>
</ul>
<p><strong>Default:</strong> all</p>
</section>
<section id="kmp-version">
<h4>KMP_VERSION<a class="headerlink" href="#kmp-version" title="Link to this heading">¶</a></h4>
<p>Enables (<code class="docutils literal notranslate"><span class="pre">true</span></code>) or disables (<code class="docutils literal notranslate"><span class="pre">false</span></code>) the printing of OpenMP run-time
library version information during program execution.</p>
<p><strong>Default:</strong> <code class="docutils literal notranslate"><span class="pre">false</span></code></p>
</section>
<section id="kmp-warnings">
<h4>KMP_WARNINGS<a class="headerlink" href="#kmp-warnings" title="Link to this heading">¶</a></h4>
<p>Enables (<code class="docutils literal notranslate"><span class="pre">true</span></code>) or disables (<code class="docutils literal notranslate"><span class="pre">false</span></code>) displaying warnings from the
OpenMP run-time library during program execution.</p>
<p><strong>Default:</strong> <code class="docutils literal notranslate"><span class="pre">true</span></code></p>
</section>
</section>
</section>
<section id="llvm-openmp-target-host-runtime-libomptarget">
<span id="libomptarget"></span><h2>LLVM/OpenMP Target Host Runtime (<code class="docutils literal notranslate"><span class="pre">libomptarget</span></code>)<a class="headerlink" href="#llvm-openmp-target-host-runtime-libomptarget" title="Link to this heading">¶</a></h2>
<section id="libopenmptarget-environment-vars">
<span id="id1"></span><h3>Environment Variables<a class="headerlink" href="#libopenmptarget-environment-vars" title="Link to this heading">¶</a></h3>
<p><code class="docutils literal notranslate"><span class="pre">libomptarget</span></code> uses environment variables to control different features of the
library at runtime. This allows the user to obtain useful runtime information as
well as enable or disable certain features. A full list of supported environment
variables is defined below.</p>
<blockquote>
<div><ul class="simple">
<li><p><code class="docutils literal notranslate"><span class="pre">LIBOMPTARGET_DEBUG=&lt;Num&gt;</span></code></p></li>
<li><p><code class="docutils literal notranslate"><span class="pre">LIBOMPTARGET_PROFILE=&lt;Filename&gt;</span></code></p></li>
<li><p><code class="docutils literal notranslate"><span class="pre">LIBOMPTARGET_PROFILE_GRANULARITY=&lt;Num&gt;</span> <span class="pre">(default</span> <span class="pre">500,</span> <span class="pre">in</span> <span class="pre">us)</span></code></p></li>
<li><p><code class="docutils literal notranslate"><span class="pre">LIBOMPTARGET_MEMORY_MANAGER_THRESHOLD=&lt;Num&gt;</span></code></p></li>
<li><p><code class="docutils literal notranslate"><span class="pre">LIBOMPTARGET_INFO=&lt;Num&gt;</span></code></p></li>
<li><p><code class="docutils literal notranslate"><span class="pre">LIBOMPTARGET_HEAP_SIZE=&lt;Num&gt;</span></code></p></li>
<li><p><code class="docutils literal notranslate"><span class="pre">LIBOMPTARGET_STACK_SIZE=&lt;Num&gt;</span></code></p></li>
<li><p><code class="docutils literal notranslate"><span class="pre">LIBOMPTARGET_SHARED_MEMORY_SIZE=&lt;Num&gt;</span></code></p></li>
<li><p><code class="docutils literal notranslate"><span class="pre">LIBOMPTARGET_MAP_FORCE_ATOMIC=[TRUE/FALSE]</span> <span class="pre">(default</span> <span class="pre">TRUE)</span></code></p></li>
<li><p><code class="docutils literal notranslate"><span class="pre">LIBOMPTARGET_JIT_OPT_LEVEL={0,1,2,3}</span> <span class="pre">(default</span> <span class="pre">3)</span></code></p></li>
<li><p><code class="docutils literal notranslate"><span class="pre">LIBOMPTARGET_JIT_SKIP_OPT=[TRUE/FALSE]</span> <span class="pre">(default</span> <span class="pre">FALSE)</span></code></p></li>
<li><p><code class="docutils literal notranslate"><span class="pre">LIBOMPTARGET_JIT_REPLACEMENT_OBJECT=&lt;in:Filename&gt;</span> <span class="pre">(object</span> <span class="pre">file)</span></code></p></li>
<li><p><code class="docutils literal notranslate"><span class="pre">LIBOMPTARGET_JIT_REPLACEMENT_MODULE=&lt;in:Filename&gt;</span> <span class="pre">(LLVM-IR</span> <span class="pre">file)</span></code></p></li>
<li><p><code class="docutils literal notranslate"><span class="pre">LIBOMPTARGET_JIT_PRE_OPT_IR_MODULE=&lt;out:Filename&gt;</span> <span class="pre">(LLVM-IR</span> <span class="pre">file)</span></code></p></li>
<li><p><code class="docutils literal notranslate"><span class="pre">LIBOMPTARGET_JIT_POST_OPT_IR_MODULE=&lt;out:Filename&gt;</span> <span class="pre">(LLVM-IR</span> <span class="pre">file)</span></code></p></li>
<li><p><code class="docutils literal notranslate"><span class="pre">LIBOMPTARGET_MIN_THREADS_FOR_LOW_TRIP_COUNT=&lt;Num&gt;</span> <span class="pre">(default:</span> <span class="pre">32)</span></code></p></li>
<li><p><code class="docutils literal notranslate"><span class="pre">LIBOMPTARGET_REUSE_BLOCKS_FOR_HIGH_TRIP_COUNT=[TRUE/FALSE]</span> <span class="pre">(default</span> <span class="pre">TRUE)</span></code></p></li>
<li><p><code class="docutils literal notranslate"><span class="pre">OFFLOAD_TRACK_ALLOCATION_TRACES=[TRUE/FALSE]</span> <span class="pre">(default</span> <span class="pre">FALSE)</span></code></p></li>
<li><p><code class="docutils literal notranslate"><span class="pre">OFFLOAD_TRACK_NUM_KERNEL_LAUNCH_TRACES=&lt;Num&gt;</span> <span class="pre">(default</span> <span class="pre">0)</span></code></p></li>
</ul>
</div></blockquote>
<section id="libomptarget-debug">
<h4>LIBOMPTARGET_DEBUG<a class="headerlink" href="#libomptarget-debug" title="Link to this heading">¶</a></h4>
<p><code class="docutils literal notranslate"><span class="pre">LIBOMPTARGET_DEBUG</span></code> controls whether or not debugging information will be
displayed. This feature is only available if <code class="docutils literal notranslate"><span class="pre">libomptarget</span></code> was built with
<code class="docutils literal notranslate"><span class="pre">-DOMPTARGET_DEBUG</span></code>. The debugging output provided is intended for use by
<code class="docutils literal notranslate"><span class="pre">libomptarget</span></code> developers. More user-friendly output is presented when using
<code class="docutils literal notranslate"><span class="pre">LIBOMPTARGET_INFO</span></code>.</p>
</section>
<section id="libomptarget-profile">
<h4>LIBOMPTARGET_PROFILE<a class="headerlink" href="#libomptarget-profile" title="Link to this heading">¶</a></h4>
<p><code class="docutils literal notranslate"><span class="pre">LIBOMPTARGET_PROFILE</span></code> allows <code class="docutils literal notranslate"><span class="pre">libomptarget</span></code> to generate time profile output
similar to Clang’s <code class="docutils literal notranslate"><span class="pre">-ftime-trace</span></code> option. This generates a JSON file based on
<a class="reference external" href="https://www.chromium.org/developers/how-tos/trace-event-profiling-tool">Chrome Tracing</a> that can be viewed with <code class="docutils literal notranslate"><span class="pre">chrome://tracing</span></code> or the
<a class="reference external" href="https://www.speedscope.app/">Speedscope App</a>. The output will be saved to the filename specified by the
environment variable. For multi-threaded applications, profiling in <code class="docutils literal notranslate"><span class="pre">libomp</span></code>
is also needed. Setting the CMake option <code class="docutils literal notranslate"><span class="pre">OPENMP_ENABLE_LIBOMP_PROFILING=ON</span></code>
to enable the feature. This feature depends on the <a class="reference external" href="https://llvm.org/docs/SupportLibrary.html">LLVM Support Library</a>
for time trace output. Note that this will turn <code class="docutils literal notranslate"><span class="pre">libomp</span></code> into a C++ library.</p>
</section>
<section id="libomptarget-profile-granularity">
<h4>LIBOMPTARGET_PROFILE_GRANULARITY<a class="headerlink" href="#libomptarget-profile-granularity" title="Link to this heading">¶</a></h4>
<p><code class="docutils literal notranslate"><span class="pre">LIBOMPTARGET_PROFILE_GRANULARITY</span></code> allows to change the time profile
granularity measured in <cite>us</cite>. Default is 500 (<cite>us</cite>).</p>
</section>
<section id="libomptarget-memory-manager-threshold">
<h4>LIBOMPTARGET_MEMORY_MANAGER_THRESHOLD<a class="headerlink" href="#libomptarget-memory-manager-threshold" title="Link to this heading">¶</a></h4>
<p><code class="docutils literal notranslate"><span class="pre">LIBOMPTARGET_MEMORY_MANAGER_THRESHOLD</span></code> sets the threshold size for which the
<code class="docutils literal notranslate"><span class="pre">libomptarget</span></code> memory manager will handle the allocation. Any allocations
larger than this threshold will not use the memory manager and be freed after
the device kernel exits. The default threshold value is <code class="docutils literal notranslate"><span class="pre">8KB</span></code>. If
<code class="docutils literal notranslate"><span class="pre">LIBOMPTARGET_MEMORY_MANAGER_THRESHOLD</span></code> is set to <code class="docutils literal notranslate"><span class="pre">0</span></code> the memory manager
will be completely disabled.</p>
</section>
<section id="libomptarget-info">
<span id="id2"></span><h4>LIBOMPTARGET_INFO<a class="headerlink" href="#libomptarget-info" title="Link to this heading">¶</a></h4>
<p><code class="docutils literal notranslate"><span class="pre">LIBOMPTARGET_INFO</span></code> allows the user to request different types of runtime
information from <code class="docutils literal notranslate"><span class="pre">libomptarget</span></code>. <code class="docutils literal notranslate"><span class="pre">LIBOMPTARGET_INFO</span></code> uses a 32-bit field to
enable or disable different types of information. This includes information
about data-mappings and kernel execution. It is recommended to build your
application with debugging information enabled, this will enable filenames and
variable declarations in the information messages. OpenMP Debugging information
is enabled at any level of debugging so a full debug runtime is not required.
For minimal debugging information compile with <cite>-gline-tables-only</cite>, or compile
with <cite>-g</cite> for full debug information. A full list of flags supported by
<code class="docutils literal notranslate"><span class="pre">LIBOMPTARGET_INFO</span></code> is given below.</p>
<blockquote>
<div><ul class="simple">
<li><p>Print all data arguments upon entering an OpenMP device kernel: <code class="docutils literal notranslate"><span class="pre">0x01</span></code></p></li>
<li><p>Indicate when a mapped address already exists in the device mapping table:
<code class="docutils literal notranslate"><span class="pre">0x02</span></code></p></li>
<li><p>Dump the contents of the device pointer map at kernel exit: <code class="docutils literal notranslate"><span class="pre">0x04</span></code></p></li>
<li><p>Indicate when an entry is changed in the device mapping table: <code class="docutils literal notranslate"><span class="pre">0x08</span></code></p></li>
<li><p>Print OpenMP kernel information from device plugins: <code class="docutils literal notranslate"><span class="pre">0x10</span></code></p></li>
<li><p>Indicate when data is copied to and from the device: <code class="docutils literal notranslate"><span class="pre">0x20</span></code></p></li>
</ul>
</div></blockquote>
<p>Any combination of these flags can be used by setting the appropriate bits. For
example, to enable printing all data active in an OpenMP target region along
with <code class="docutils literal notranslate"><span class="pre">CUDA</span></code> information, run the following <code class="docutils literal notranslate"><span class="pre">bash</span></code> command.</p>
<div class="highlight-console notranslate"><div class="highlight"><pre><span></span><span class="gp">$ </span>env<span class="w"> </span><span class="nv">LIBOMPTARGET_INFO</span><span class="o">=</span><span class="k">$((</span><span class="m">0x1</span><span class="w"> </span><span class="o">|</span><span class="w"> </span><span class="m">0x10</span><span class="k">))</span><span class="w"> </span>./your-application
</pre></div>
</div>
<p>Or, to enable every flag run with every bit set.</p>
<div class="highlight-console notranslate"><div class="highlight"><pre><span></span><span class="gp">$ </span>env<span class="w"> </span><span class="nv">LIBOMPTARGET_INFO</span><span class="o">=</span>-1<span class="w"> </span>./your-application
</pre></div>
</div>
<p>For example, given a small application implementing the <code class="docutils literal notranslate"><span class="pre">ZAXPY</span></code> BLAS routine,
<code class="docutils literal notranslate"><span class="pre">Libomptarget</span></code> can provide useful information about data mappings and thread
usages.</p>
<div class="highlight-c++ notranslate"><div class="highlight"><pre><span></span><span class="cp">#include</span><span class="w"> </span><span class="cpf">&lt;complex&gt;</span>

<span class="k">using</span><span class="w"> </span><span class="n">complex</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">std</span><span class="o">::</span><span class="n">complex</span><span class="o">&lt;</span><span class="kt">double</span><span class="o">&gt;</span><span class="p">;</span>

<span class="kt">void</span><span class="w"> </span><span class="nf">zaxpy</span><span class="p">(</span><span class="n">complex</span><span class="w"> </span><span class="o">*</span><span class="n">X</span><span class="p">,</span><span class="w"> </span><span class="n">complex</span><span class="w"> </span><span class="o">*</span><span class="n">Y</span><span class="p">,</span><span class="w"> </span><span class="n">complex</span><span class="w"> </span><span class="n">D</span><span class="p">,</span><span class="w"> </span><span class="n">std</span><span class="o">::</span><span class="kt">size_t</span><span class="w"> </span><span class="n">N</span><span class="p">)</span><span class="w"> </span><span class="p">{</span>
<span class="cp">#pragma omp target teams distribute parallel for</span>
<span class="w">  </span><span class="k">for</span><span class="w"> </span><span class="p">(</span><span class="n">std</span><span class="o">::</span><span class="kt">size_t</span><span class="w"> </span><span class="n">i</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="mi">0</span><span class="p">;</span><span class="w"> </span><span class="n">i</span><span class="w"> </span><span class="o">&lt;</span><span class="w"> </span><span class="n">N</span><span class="p">;</span><span class="w"> </span><span class="o">++</span><span class="n">i</span><span class="p">)</span>
<span class="w">    </span><span class="n">Y</span><span class="p">[</span><span class="n">i</span><span class="p">]</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">D</span><span class="w"> </span><span class="o">*</span><span class="w"> </span><span class="n">X</span><span class="p">[</span><span class="n">i</span><span class="p">]</span><span class="w"> </span><span class="o">+</span><span class="w"> </span><span class="n">Y</span><span class="p">[</span><span class="n">i</span><span class="p">];</span>
<span class="p">}</span>

<span class="kt">int</span><span class="w"> </span><span class="nf">main</span><span class="p">()</span><span class="w"> </span><span class="p">{</span>
<span class="w">  </span><span class="k">const</span><span class="w"> </span><span class="n">std</span><span class="o">::</span><span class="kt">size_t</span><span class="w"> </span><span class="n">N</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="mi">1024</span><span class="p">;</span>
<span class="w">  </span><span class="n">complex</span><span class="w"> </span><span class="n">X</span><span class="p">[</span><span class="n">N</span><span class="p">],</span><span class="w"> </span><span class="n">Y</span><span class="p">[</span><span class="n">N</span><span class="p">],</span><span class="w"> </span><span class="n">D</span><span class="p">;</span>
<span class="cp">#pragma omp target data map(to:X[0 : N]) map(tofrom:Y[0 : N])</span>
<span class="w">  </span><span class="n">zaxpy</span><span class="p">(</span><span class="n">X</span><span class="p">,</span><span class="w"> </span><span class="n">Y</span><span class="p">,</span><span class="w"> </span><span class="n">D</span><span class="p">,</span><span class="w"> </span><span class="n">N</span><span class="p">);</span>
<span class="p">}</span>
</pre></div>
</div>
<p>Compiling this code targeting <code class="docutils literal notranslate"><span class="pre">nvptx64</span></code> with all information enabled will
provide the following output from the runtime library.</p>
<div class="highlight-console notranslate"><div class="highlight"><pre><span></span><span class="gp">$ </span>clang++<span class="w"> </span>-fopenmp<span class="w"> </span>-fopenmp-targets<span class="o">=</span>nvptx64<span class="w"> </span>-O3<span class="w"> </span>-gline-tables-only<span class="w"> </span>zaxpy.cpp<span class="w"> </span>-o<span class="w"> </span>zaxpy
<span class="gp">$ </span>env<span class="w"> </span><span class="nv">LIBOMPTARGET_INFO</span><span class="o">=</span>-1<span class="w"> </span>./zaxpy
</pre></div>
</div>
<div class="highlight-text notranslate"><div class="highlight"><pre><span></span>Info: Entering OpenMP data region at zaxpy.cpp:14:1 with 2 arguments:
Info: to(X[0:N])[16384]
Info: tofrom(Y[0:N])[16384]
Info: Creating new map entry with HstPtrBegin=0x00007fff0d259a40,
      TgtPtrBegin=0x00007fdba5800000, Size=16384, RefCount=1, Name=X[0:N]
Info: Copying data from host to device, HstPtr=0x00007fff0d259a40,
      TgtPtr=0x00007fdba5800000, Size=16384, Name=X[0:N]
Info: Creating new map entry with HstPtrBegin=0x00007fff0d255a40,
      TgtPtrBegin=0x00007fdba5804000, Size=16384, RefCount=1, Name=Y[0:N]
Info: Copying data from host to device, HstPtr=0x00007fff0d255a40,
      TgtPtr=0x00007fdba5804000, Size=16384, Name=Y[0:N]
Info: OpenMP Host-Device pointer mappings after block at zaxpy.cpp:14:1:
Info: Host Ptr           Target Ptr         Size (B) RefCount Declaration
Info: 0x00007fff0d255a40 0x00007fdba5804000 16384    1        Y[0:N] at zaxpy.cpp:13:17
Info: 0x00007fff0d259a40 0x00007fdba5800000 16384    1        X[0:N] at zaxpy.cpp:13:11
Info: Entering OpenMP kernel at zaxpy.cpp:6:1 with 4 arguments:
Info: firstprivate(N)[8] (implicit)
Info: use_address(Y)[0] (implicit)
Info: tofrom(D)[16] (implicit)
Info: use_address(X)[0] (implicit)
Info: Mapping exists (implicit) with HstPtrBegin=0x00007fff0d255a40,
      TgtPtrBegin=0x00007fdba5804000, Size=0, RefCount=2 (incremented), Name=Y
Info: Creating new map entry with HstPtrBegin=0x00007fff0d2559f0,
      TgtPtrBegin=0x00007fdba5808000, Size=16, RefCount=1, Name=D
Info: Copying data from host to device, HstPtr=0x00007fff0d2559f0,
      TgtPtr=0x00007fdba5808000, Size=16, Name=D
Info: Mapping exists (implicit) with HstPtrBegin=0x00007fff0d259a40,
      TgtPtrBegin=0x00007fdba5800000, Size=0, RefCount=2 (incremented), Name=X
Info: Mapping exists with HstPtrBegin=0x00007fff0d255a40,
      TgtPtrBegin=0x00007fdba5804000, Size=0, RefCount=2 (update suppressed)
Info: Mapping exists with HstPtrBegin=0x00007fff0d2559f0,
      TgtPtrBegin=0x00007fdba5808000, Size=16, RefCount=1 (update suppressed)
Info: Mapping exists with HstPtrBegin=0x00007fff0d259a40,
      TgtPtrBegin=0x00007fdba5800000, Size=0, RefCount=2 (update suppressed)
Info: Launching kernel __omp_offloading_10305_c08c86__Z5zaxpyPSt7complexIdES1_S0_m_l6
      with 8 blocks and 128 threads in SPMD mode
Info: Mapping exists with HstPtrBegin=0x00007fff0d259a40,
      TgtPtrBegin=0x00007fdba5800000, Size=0, RefCount=1 (decremented)
Info: Mapping exists with HstPtrBegin=0x00007fff0d2559f0,
      TgtPtrBegin=0x00007fdba5808000, Size=16, RefCount=1 (deferred final decrement)
Info: Copying data from device to host, TgtPtr=0x00007fdba5808000,
      HstPtr=0x00007fff0d2559f0, Size=16, Name=D
Info: Mapping exists with HstPtrBegin=0x00007fff0d255a40,
      TgtPtrBegin=0x00007fdba5804000, Size=0, RefCount=1 (decremented)
Info: Removing map entry with HstPtrBegin=0x00007fff0d2559f0,
      TgtPtrBegin=0x00007fdba5808000, Size=16, Name=D
Info: OpenMP Host-Device pointer mappings after block at zaxpy.cpp:6:1:
Info: Host Ptr           Target Ptr         Size (B) RefCount Declaration
Info: 0x00007fff0d255a40 0x00007fdba5804000 16384    1        Y[0:N] at zaxpy.cpp:13:17
Info: 0x00007fff0d259a40 0x00007fdba5800000 16384    1        X[0:N] at zaxpy.cpp:13:11
Info: Exiting OpenMP data region at zaxpy.cpp:14:1 with 2 arguments:
Info: to(X[0:N])[16384]
Info: tofrom(Y[0:N])[16384]
Info: Mapping exists with HstPtrBegin=0x00007fff0d255a40,
      TgtPtrBegin=0x00007fdba5804000, Size=16384, RefCount=1 (deferred final decrement)
Info: Copying data from device to host, TgtPtr=0x00007fdba5804000,
      HstPtr=0x00007fff0d255a40, Size=16384, Name=Y[0:N]
Info: Mapping exists with HstPtrBegin=0x00007fff0d259a40,
      TgtPtrBegin=0x00007fdba5800000, Size=16384, RefCount=1 (deferred final decrement)
Info: Removing map entry with HstPtrBegin=0x00007fff0d255a40,
      TgtPtrBegin=0x00007fdba5804000, Size=16384, Name=Y[0:N]
Info: Removing map entry with HstPtrBegin=0x00007fff0d259a40,
      TgtPtrBegin=0x00007fdba5800000, Size=16384, Name=X[0:N]
</pre></div>
</div>
<p>From this information, we can see the OpenMP kernel being launched on the CUDA
device with enough threads and blocks for all <code class="docutils literal notranslate"><span class="pre">1024</span></code> iterations of the loop in
simplified <a class="reference internal" href="Offloading.html"><span class="doc">SPMD Mode</span></a>. The information from the OpenMP data
region shows the two arrays <code class="docutils literal notranslate"><span class="pre">X</span></code> and <code class="docutils literal notranslate"><span class="pre">Y</span></code> being copied from the host to the
device. This creates an entry in the host-device mapping table associating the
host pointers to the newly created device data. The data mappings in the OpenMP
device kernel show the default mappings being used for all the variables used
implicitly on the device. Because <code class="docutils literal notranslate"><span class="pre">X</span></code> and <code class="docutils literal notranslate"><span class="pre">Y</span></code> are already mapped in the
device’s table, no new entries are created. Additionally, the default mapping
shows that <code class="docutils literal notranslate"><span class="pre">D</span></code> will be copied back from the device once the OpenMP device
kernel region ends even though it isn’t written to. Finally, at the end of the
OpenMP data region the entries for <code class="docutils literal notranslate"><span class="pre">X</span></code> and <code class="docutils literal notranslate"><span class="pre">Y</span></code> are removed from the table.</p>
<p>The information level can be controlled at runtime using an internal
libomptarget library call <code class="docutils literal notranslate"><span class="pre">__tgt_set_info_flag</span></code>. This allows for different
levels of information to be enabled or disabled for certain regions of code.
Using this requires declaring the function signature as an external function so
it can be linked with the runtime library.</p>
<div class="highlight-c++ notranslate"><div class="highlight"><pre><span></span><span class="k">extern</span><span class="w"> </span><span class="s">&quot;C&quot;</span><span class="w"> </span><span class="kt">void</span><span class="w"> </span><span class="n">__tgt_set_info_flag</span><span class="p">(</span><span class="kt">uint32_t</span><span class="p">);</span>

<span class="k">extern</span><span class="w"> </span><span class="n">foo</span><span class="p">();</span>

<span class="kt">int</span><span class="w"> </span><span class="nf">main</span><span class="p">()</span><span class="w"> </span><span class="p">{</span>
<span class="w">  </span><span class="n">__tgt_set_info_flag</span><span class="p">(</span><span class="mh">0x10</span><span class="p">);</span>
<span class="cp">#pragma omp target</span>
<span class="w">  </span><span class="n">foo</span><span class="p">();</span>
<span class="p">}</span>
</pre></div>
</div>
</section>
</section>
<section id="errors">
<span id="libopenmptarget-errors"></span><h3>Errors:<a class="headerlink" href="#errors" title="Link to this heading">¶</a></h3>
<p><code class="docutils literal notranslate"><span class="pre">libomptarget</span></code> provides error messages when the program fails inside the
OpenMP target region. Common causes of failure could be an invalid pointer
access, running out of device memory, or trying to offload when the device is
busy. If the application was built with debugging symbols the error messages
will additionally provide the source location of the OpenMP target region.</p>
<p>For example, consider the following code that implements a simple parallel
reduction on the GPU. This code has a bug that causes it to fail in the
offloading region.</p>
<div class="highlight-c++ notranslate"><div class="highlight"><pre><span></span><span class="cp">#include</span><span class="w"> </span><span class="cpf">&lt;cstdio&gt;</span>

<span class="kt">double</span><span class="w"> </span><span class="nf">sum</span><span class="p">(</span><span class="kt">double</span><span class="w"> </span><span class="o">*</span><span class="n">A</span><span class="p">,</span><span class="w"> </span><span class="n">std</span><span class="o">::</span><span class="kt">size_t</span><span class="w"> </span><span class="n">N</span><span class="p">)</span><span class="w"> </span><span class="p">{</span>
<span class="w">  </span><span class="kt">double</span><span class="w"> </span><span class="n">sum</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="mf">0.0</span><span class="p">;</span>
<span class="cp">#pragma omp target teams distribute parallel for reduction(+:sum)</span>
<span class="w">  </span><span class="k">for</span><span class="w"> </span><span class="p">(</span><span class="kt">int</span><span class="w"> </span><span class="n">i</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="mi">0</span><span class="p">;</span><span class="w"> </span><span class="n">i</span><span class="w"> </span><span class="o">&lt;</span><span class="w"> </span><span class="n">N</span><span class="p">;</span><span class="w"> </span><span class="o">++</span><span class="n">i</span><span class="p">)</span>
<span class="w">    </span><span class="n">sum</span><span class="w"> </span><span class="o">+=</span><span class="w"> </span><span class="n">A</span><span class="p">[</span><span class="n">i</span><span class="p">];</span>

<span class="w">  </span><span class="k">return</span><span class="w"> </span><span class="n">sum</span><span class="p">;</span>
<span class="p">}</span>

<span class="kt">int</span><span class="w"> </span><span class="nf">main</span><span class="p">()</span><span class="w"> </span><span class="p">{</span>
<span class="w">  </span><span class="k">const</span><span class="w"> </span><span class="kt">int</span><span class="w"> </span><span class="n">N</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="mi">1024</span><span class="p">;</span>
<span class="w">  </span><span class="kt">double</span><span class="w"> </span><span class="n">A</span><span class="p">[</span><span class="n">N</span><span class="p">];</span>
<span class="w">  </span><span class="n">sum</span><span class="p">(</span><span class="n">A</span><span class="p">,</span><span class="w"> </span><span class="n">N</span><span class="p">);</span>
<span class="p">}</span>
</pre></div>
</div>
<p>If this code is compiled and run, there will be an error message indicating what is
going wrong.</p>
<div class="highlight-console notranslate"><div class="highlight"><pre><span></span><span class="gp">$ </span>clang++<span class="w"> </span>-fopenmp<span class="w"> </span>-fopenmp-targets<span class="o">=</span>nvptx64<span class="w"> </span>-O3<span class="w"> </span>-gline-tables-only<span class="w"> </span>sum.cpp<span class="w"> </span>-o<span class="w"> </span>sum
<span class="gp">$ </span>./sum
</pre></div>
</div>
<div class="highlight-text notranslate"><div class="highlight"><pre><span></span>CUDA error: an illegal memory access was encountered
Libomptarget error: Copying data from device failed.
Libomptarget error: Call to targetDataEnd failed, abort target.
Libomptarget error: Failed to process data after launching the kernel.
Libomptarget error: Consult https://openmp.llvm.org/design/Runtimes.html for debugging options.
sum.cpp:5:1: Libomptarget error 1: failure of target construct while offloading is mandatory
</pre></div>
</div>
<p>This shows that there is an illegal memory access occurring inside the OpenMP
target region once execution has moved to the CUDA device, suggesting a
segmentation fault. This then causes a chain reaction of failures in
<code class="docutils literal notranslate"><span class="pre">libomptarget</span></code>. Another message suggests using the <code class="docutils literal notranslate"><span class="pre">LIBOMPTARGET_INFO</span></code>
environment variable as described in <a class="reference internal" href="#libopenmptarget-environment-vars"><span class="std std-ref">Environment Variables</span></a>. If
we do this it will print the sate of the host-target pointer mappings at the
time of failure.</p>
<div class="highlight-console notranslate"><div class="highlight"><pre><span></span><span class="gp">$ </span>clang++<span class="w"> </span>-fopenmp<span class="w"> </span>-fopenmp-targets<span class="o">=</span>nvptx64<span class="w"> </span>-O3<span class="w"> </span>-gline-tables-only<span class="w"> </span>sum.cpp<span class="w"> </span>-o<span class="w"> </span>sum
<span class="gp">$ </span>env<span class="w"> </span><span class="nv">LIBOMPTARGET_INFO</span><span class="o">=</span><span class="m">4</span><span class="w"> </span>./sum
</pre></div>
</div>
<div class="highlight-text notranslate"><div class="highlight"><pre><span></span>info: OpenMP Host-Device pointer mappings after block at sum.cpp:5:1:
info: Host Ptr           Target Ptr         Size (B) RefCount Declaration
info: 0x00007ffc058280f8 0x00007f4186600000 8        1        sum at sum.cpp:4:10
</pre></div>
</div>
<p>This tells us that the only data mapped between the host and the device is the
<code class="docutils literal notranslate"><span class="pre">sum</span></code> variable that will be copied back from the device once the reduction has
ended. There is no entry mapping the host array <code class="docutils literal notranslate"><span class="pre">A</span></code> to the device. In this
situation, the compiler cannot determine the size of the array at compile time
so it will simply assume that the pointer is mapped on the device already by
default. The solution is to add an explicit map clause in the target region.</p>
<div class="highlight-c++ notranslate"><div class="highlight"><pre><span></span><span class="kt">double</span><span class="w"> </span><span class="nf">sum</span><span class="p">(</span><span class="kt">double</span><span class="w"> </span><span class="o">*</span><span class="n">A</span><span class="p">,</span><span class="w"> </span><span class="n">std</span><span class="o">::</span><span class="kt">size_t</span><span class="w"> </span><span class="n">N</span><span class="p">)</span><span class="w"> </span><span class="p">{</span>
<span class="w">  </span><span class="kt">double</span><span class="w"> </span><span class="n">sum</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="mf">0.0</span><span class="p">;</span>
<span class="cp">#pragma omp target teams distribute parallel for reduction(+:sum) map(to:A[0 : N])</span>
<span class="w">  </span><span class="k">for</span><span class="w"> </span><span class="p">(</span><span class="kt">int</span><span class="w"> </span><span class="n">i</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="mi">0</span><span class="p">;</span><span class="w"> </span><span class="n">i</span><span class="w"> </span><span class="o">&lt;</span><span class="w"> </span><span class="n">N</span><span class="p">;</span><span class="w"> </span><span class="o">++</span><span class="n">i</span><span class="p">)</span>
<span class="w">    </span><span class="n">sum</span><span class="w"> </span><span class="o">+=</span><span class="w"> </span><span class="n">A</span><span class="p">[</span><span class="n">i</span><span class="p">];</span>

<span class="w">  </span><span class="k">return</span><span class="w"> </span><span class="n">sum</span><span class="p">;</span>
<span class="p">}</span>
</pre></div>
</div>
<section id="libomptarget-stack-size">
<h4>LIBOMPTARGET_STACK_SIZE<a class="headerlink" href="#libomptarget-stack-size" title="Link to this heading">¶</a></h4>
<p>This environment variable sets the stack size in bytes for the AMDGPU and CUDA
plugins. This can be used to increase or decrease the standard amount of memory
reserved for each thread’s stack.</p>
</section>
<section id="libomptarget-heap-size">
<h4>LIBOMPTARGET_HEAP_SIZE<a class="headerlink" href="#libomptarget-heap-size" title="Link to this heading">¶</a></h4>
<p>This environment variable sets the amount of memory in bytes that can be
allocated using <code class="docutils literal notranslate"><span class="pre">malloc</span></code> and <code class="docutils literal notranslate"><span class="pre">free</span></code> for the CUDA plugin. This is necessary
for some applications that allocate too much memory either through the user or
globalization.</p>
</section>
<section id="libomptarget-shared-memory-size">
<h4>LIBOMPTARGET_SHARED_MEMORY_SIZE<a class="headerlink" href="#libomptarget-shared-memory-size" title="Link to this heading">¶</a></h4>
<p>This environment variable sets the amount of dynamic shared memory in bytes used
by the kernel once it is launched. A pointer to the dynamic memory buffer can be
accessed using the <code class="docutils literal notranslate"><span class="pre">llvm_omp_target_dynamic_shared_alloc</span></code> function. An example
is shown in <a class="reference internal" href="#libomptarget-dynamic-shared"><span class="std std-ref">Dynamic Shared Memory</span></a>.</p>
<div class="toctree-wrapper compound">
</div>
</section>
<section id="libomptarget-map-force-atomic">
<h4>LIBOMPTARGET_MAP_FORCE_ATOMIC<a class="headerlink" href="#libomptarget-map-force-atomic" title="Link to this heading">¶</a></h4>
<p>The OpenMP standard guarantees that map clauses are atomic. However, the this
can have a drastic performance impact. Users that do not require atomic map
clauses can disable them to potentially recover lost performance. As a
consequence, users have to guarantee themselves that no two map clauses will
concurrently map the same memory. If the memory is already mapped and the
map clauses will only modify the reference counter from a non-zero count to
another non-zero count, concurrent map clauses are supported regardless of
this option. To disable forced atomic map clauses use “false”/”FALSE” as the
value of the <code class="docutils literal notranslate"><span class="pre">LIBOMPTARGET_MAP_FORCE_ATOMIC</span></code> environment variable.
The default behavior of LLVM 14 is to force atomic maps clauses, prior versions
of LLVM did not.</p>
</section>
<section id="libomptarget-jit-opt-level">
<span id="id3"></span><h4>LIBOMPTARGET_JIT_OPT_LEVEL<a class="headerlink" href="#libomptarget-jit-opt-level" title="Link to this heading">¶</a></h4>
<p>This environment variable can be used to change the optimization pipeline used
to optimize the embedded device code as part of the device JIT. The value is
corresponds to the <code class="docutils literal notranslate"><span class="pre">-O{0,1,2,3}</span></code> command line argument passed to <code class="docutils literal notranslate"><span class="pre">clang</span></code>.</p>
</section>
<section id="libomptarget-jit-skip-opt">
<h4>LIBOMPTARGET_JIT_SKIP_OPT<a class="headerlink" href="#libomptarget-jit-skip-opt" title="Link to this heading">¶</a></h4>
<p>This environment variable can be used to skip the optimization pipeline during
JIT compilation. If set, the image will only be passed through the backend. The
backend is invoked with the <code class="docutils literal notranslate"><span class="pre">LIBOMPTARGET_JIT_OPT_LEVEL</span></code> flag.</p>
</section>
<section id="libomptarget-jit-replacement-object">
<h4>LIBOMPTARGET_JIT_REPLACEMENT_OBJECT<a class="headerlink" href="#libomptarget-jit-replacement-object" title="Link to this heading">¶</a></h4>
<p>This environment variable can be used to replace the embedded device code
before the device JIT finishes compilation for the target. The value is
expected to be a filename to an object file, thus containing the output of the
assembler in object format for the respective target. The JIT optimization
pipeline and backend are skipped and only target specific post-processing is
performed on the object file before it is loaded onto the device.</p>
</section>
<section id="libomptarget-jit-replacement-module">
<span id="id4"></span><h4>LIBOMPTARGET_JIT_REPLACEMENT_MODULE<a class="headerlink" href="#libomptarget-jit-replacement-module" title="Link to this heading">¶</a></h4>
<p>This environment variable can be used to replace the embedded device code
before the device JIT finishes compilation for the target. The value is
expected to be a filename to an LLVM-IR file, thus containing an LLVM-IR module
for the respective target. To obtain a device code image compatible with the
embedded one it is recommended to extract the embedded one either before or
after IR optimization. This can be done at compile time, after compile time via
llvm tools (llvm-objdump), or, simply, by setting the
<a class="reference internal" href="#libomptarget-jit-pre-opt-ir-module"><span class="std std-ref">LIBOMPTARGET_JIT_PRE_OPT_IR_MODULE</span></a> or
<a class="reference internal" href="#libomptarget-jit-post-opt-ir-module"><span class="std std-ref">LIBOMPTARGET_JIT_POST_OPT_IR_MODULE</span></a> environment variables.</p>
</section>
<section id="libomptarget-jit-pre-opt-ir-module">
<span id="id5"></span><h4>LIBOMPTARGET_JIT_PRE_OPT_IR_MODULE<a class="headerlink" href="#libomptarget-jit-pre-opt-ir-module" title="Link to this heading">¶</a></h4>
<p>This environment variable can be used to extract the embedded device code
before the device JIT runs additional IR optimizations on it (see
<a class="reference internal" href="#libomptarget-jit-opt-level"><span class="std std-ref">LIBOMPTARGET_JIT_OPT_LEVEL</span></a>). The value is expected to be a filename into
which the LLVM-IR module is written. The module can be the analyzed, and
transformed and loaded back into the JIT pipeline via
<a class="reference internal" href="#libomptarget-jit-replacement-module"><span class="std std-ref">LIBOMPTARGET_JIT_REPLACEMENT_MODULE</span></a>.</p>
</section>
<section id="libomptarget-jit-post-opt-ir-module">
<span id="id6"></span><h4>LIBOMPTARGET_JIT_POST_OPT_IR_MODULE<a class="headerlink" href="#libomptarget-jit-post-opt-ir-module" title="Link to this heading">¶</a></h4>
<p>This environment variable can be used to extract the embedded device code after
the device JIT runs additional IR optimizations on it (see
<a class="reference internal" href="#libomptarget-jit-opt-level"><span class="std std-ref">LIBOMPTARGET_JIT_OPT_LEVEL</span></a>). The value is expected to be a filename into
which the LLVM-IR module is written. The module can be the analyzed, and
transformed and loaded back into the JIT pipeline via
<a class="reference internal" href="#libomptarget-jit-replacement-module"><span class="std std-ref">LIBOMPTARGET_JIT_REPLACEMENT_MODULE</span></a>.</p>
</section>
<section id="libomptarget-min-threads-for-low-trip-count">
<h4>LIBOMPTARGET_MIN_THREADS_FOR_LOW_TRIP_COUNT<a class="headerlink" href="#libomptarget-min-threads-for-low-trip-count" title="Link to this heading">¶</a></h4>
<p>This environment variable defines a lower bound for the number of threads if a
combined kernel, e.g., <cite>target teams distribute parallel for</cite>, has insufficient
parallelism. Especially if the trip count of the loops is lower than the number
of threads possible times the number of teams (aka. blocks) the device prefers
(see also <a class="reference internal" href="#libomptarget-amdgpu-teams-per-cu"><span class="std std-ref">LIBOMPTARGET_AMDGPU_TEAMS_PER_CU</span></a>), we will reduce the thread
count to increase outer (team/block) parallelism. The thread count will never
be reduced below the value passed for this environment variable though.</p>
</section>
<section id="libomptarget-reuse-blocks-for-high-trip-count">
<h4>LIBOMPTARGET_REUSE_BLOCKS_FOR_HIGH_TRIP_COUNT<a class="headerlink" href="#libomptarget-reuse-blocks-for-high-trip-count" title="Link to this heading">¶</a></h4>
<p>This environment variable can be used to control how the OpenMP runtime assigns
blocks to loops with high trip counts. By default we reuse existing blocks
rather than spawning new blocks.</p>
</section>
<section id="offload-track-allocation-traces">
<h4>OFFLOAD_TRACK_ALLOCATION_TRACES<a class="headerlink" href="#offload-track-allocation-traces" title="Link to this heading">¶</a></h4>
<p>This environment variable determines if the stack traces of allocations and
deallocations are tracked to aid in error reporting, e.g., in case of
double-free.</p>
</section>
<section id="offload-track-kernel-launch-traces">
<h4>OFFLOAD_TRACK_KERNEL_LAUNCH_TRACES<a class="headerlink" href="#offload-track-kernel-launch-traces" title="Link to this heading">¶</a></h4>
<p>This environment variable determines how manytstack traces of kernel launches
are tracked to aid in error reporting, e.g., what asynchronous kernel failed.</p>
</section>
</section>
</section>
<section id="llvm-openmp-target-host-runtime-plugins-libomptarget-rtl-xxxx">
<span id="libomptarget-plugin"></span><h2>LLVM/OpenMP Target Host Runtime Plugins (<code class="docutils literal notranslate"><span class="pre">libomptarget.rtl.XXXX</span></code>)<a class="headerlink" href="#llvm-openmp-target-host-runtime-plugins-libomptarget-rtl-xxxx" title="Link to this heading">¶</a></h2>
<p>The LLVM/OpenMP target host runtime plugins were recently re-implemented,
temporarily renamed as the NextGen plugins, and set as the default and only
plugins’ implementation. Currently, these plugins have support for the NVIDIA
and AMDGPU devices as well as the GenericELF64bit host-simulated device.</p>
<p>The source code of the common infrastructure and the vendor-specific plugins is
in the <code class="docutils literal notranslate"><span class="pre">openmp/libomptarget/nextgen-plugins</span></code> directory in the LLVM project
repository. The plugin infrastructure aims at unifying the plugin code and logic
into a generic interface using object-oriented C++. There is a plugin interface
composed by multiple generic C++ classes which implement the common logic that
every vendor-specific plugin should provide. In turn, the specific plugins
inherit from those generic classes and implement the required functions that
depend on the specific vendor API. As an example, some generic classes that the
plugin interface define are for representing a device, a device image, an
efficient resource manager, etc.</p>
<p>With this common plugin infrastructure, several tasks have been simplified:
adding a new vendor-specific plugin, adding generic features or optimizations
to all plugins, debugging plugins, etc.</p>
<section id="id7">
<h3>Environment Variables<a class="headerlink" href="#id7" title="Link to this heading">¶</a></h3>
<p>There are several environment variables to change the behavior of the plugins:</p>
<ul class="simple">
<li><p><code class="docutils literal notranslate"><span class="pre">LIBOMPTARGET_SHARED_MEMORY_SIZE</span></code></p></li>
<li><p><code class="docutils literal notranslate"><span class="pre">LIBOMPTARGET_STACK_SIZE</span></code></p></li>
<li><p><code class="docutils literal notranslate"><span class="pre">LIBOMPTARGET_HEAP_SIZE</span></code></p></li>
<li><p><code class="docutils literal notranslate"><span class="pre">LIBOMPTARGET_NUM_INITIAL_STREAMS</span></code></p></li>
<li><p><code class="docutils literal notranslate"><span class="pre">LIBOMPTARGET_NUM_INITIAL_EVENTS</span></code></p></li>
<li><p><code class="docutils literal notranslate"><span class="pre">LIBOMPTARGET_LOCK_MAPPED_HOST_BUFFERS</span></code></p></li>
<li><p><code class="docutils literal notranslate"><span class="pre">LIBOMPTARGET_AMDGPU_NUM_HSA_QUEUES</span></code></p></li>
<li><p><code class="docutils literal notranslate"><span class="pre">LIBOMPTARGET_AMDGPU_HSA_QUEUE_SIZE</span></code></p></li>
<li><p><code class="docutils literal notranslate"><span class="pre">LIBOMPTARGET_AMDGPU_HSA_QUEUE_BUSY_TRACKING</span></code></p></li>
<li><p><code class="docutils literal notranslate"><span class="pre">LIBOMPTARGET_AMDGPU_TEAMS_PER_CU</span></code></p></li>
<li><p><code class="docutils literal notranslate"><span class="pre">LIBOMPTARGET_AMDGPU_MAX_ASYNC_COPY_BYTES</span></code></p></li>
<li><p><code class="docutils literal notranslate"><span class="pre">LIBOMPTARGET_AMDGPU_NUM_INITIAL_HSA_SIGNALS</span></code></p></li>
<li><p><code class="docutils literal notranslate"><span class="pre">LIBOMPTARGET_AMDGPU_STREAM_BUSYWAIT</span></code></p></li>
</ul>
<p>The environment variables <code class="docutils literal notranslate"><span class="pre">LIBOMPTARGET_SHARED_MEMORY_SIZE</span></code>,
<code class="docutils literal notranslate"><span class="pre">LIBOMPTARGET_STACK_SIZE</span></code> and <code class="docutils literal notranslate"><span class="pre">LIBOMPTARGET_HEAP_SIZE</span></code> are described in
<a class="reference internal" href="#libopenmptarget-environment-vars"><span class="std std-ref">Environment Variables</span></a>.</p>
<section id="libomptarget-num-initial-streams">
<h4>LIBOMPTARGET_NUM_INITIAL_STREAMS<a class="headerlink" href="#libomptarget-num-initial-streams" title="Link to this heading">¶</a></h4>
<p>This environment variable sets the number of pre-created streams in the plugin
(if supported) at initialization. More streams will be created dynamically
throughout the execution if needed. A stream is a queue of asynchronous
operations (e.g., kernel launches and memory copies) that are executed
sequentially. Parallelism is achieved by featuring multiple streams. The
<code class="docutils literal notranslate"><span class="pre">libomptarget</span></code> leverages streams to exploit parallelism between plugin
operations. The default value is <code class="docutils literal notranslate"><span class="pre">1</span></code>, more streams are created as needed.</p>
</section>
<section id="libomptarget-num-initial-events">
<h4>LIBOMPTARGET_NUM_INITIAL_EVENTS<a class="headerlink" href="#libomptarget-num-initial-events" title="Link to this heading">¶</a></h4>
<p>This environment variable sets the number of pre-created events in the
plugin (if supported) at initialization. More events will be created
dynamically throughout the execution if needed. An event is used to synchronize
a stream with another efficiently. The default value is <code class="docutils literal notranslate"><span class="pre">1</span></code>, more events are
created as needed.</p>
</section>
<section id="libomptarget-lock-mapped-host-buffers">
<h4>LIBOMPTARGET_LOCK_MAPPED_HOST_BUFFERS<a class="headerlink" href="#libomptarget-lock-mapped-host-buffers" title="Link to this heading">¶</a></h4>
<p>This environment variable indicates whether the host buffers mapped by the user
should be automatically locked/pinned by the plugin. Pinned host buffers allow
true asynchronous copies between the host and devices. Enabling this feature can
increase the performance of applications that are intensive in host-device
memory transfers. The default value is <code class="docutils literal notranslate"><span class="pre">false</span></code>.</p>
</section>
<section id="libomptarget-amdgpu-num-hsa-queues">
<h4>LIBOMPTARGET_AMDGPU_NUM_HSA_QUEUES<a class="headerlink" href="#libomptarget-amdgpu-num-hsa-queues" title="Link to this heading">¶</a></h4>
<p>This environment variable controls the number of HSA queues per device in the
AMDGPU plugin. An HSA queue is a runtime-allocated resource that contains an
AQL (Architected Queuing Language) packet buffer and is associated with an AQL
packet processor. HSA queues are used for inserting kernel packets to launching
kernel executions. A high number of HSA queues may degrade the performance. The
default value is <code class="docutils literal notranslate"><span class="pre">4</span></code>.</p>
</section>
<section id="libomptarget-amdgpu-hsa-queue-size">
<h4>LIBOMPTARGET_AMDGPU_HSA_QUEUE_SIZE<a class="headerlink" href="#libomptarget-amdgpu-hsa-queue-size" title="Link to this heading">¶</a></h4>
<p>This environment variable controls the size of each HSA queue in the AMDGPU
plugin. The size is the number of AQL packets an HSA queue is expected to hold.
It is also the number of AQL packets that can be pushed into each queue without
waiting the driver to process them. The default value is <code class="docutils literal notranslate"><span class="pre">512</span></code>.</p>
</section>
<section id="libomptarget-amdgpu-hsa-queue-busy-tracking">
<h4>LIBOMPTARGET_AMDGPU_HSA_QUEUE_BUSY_TRACKING<a class="headerlink" href="#libomptarget-amdgpu-hsa-queue-busy-tracking" title="Link to this heading">¶</a></h4>
<p>This environment variable controls if idle HSA queues will be preferentially
assigned to streams, for example when they are requested for a kernel launch.
Should all queues be considered busy, a new queue is initialized and returned,
until we reach the set maximum. Otherwise, we will select the least utilized
queue. If this is disabled, each time a stream is requested a new HSA queue
will be initialized, regardless of their utilization. Additionally, queues will
be selected using round robin selection. The default value is <code class="docutils literal notranslate"><span class="pre">true</span></code>.</p>
</section>
<section id="libomptarget-amdgpu-teams-per-cu">
<span id="id8"></span><h4>LIBOMPTARGET_AMDGPU_TEAMS_PER_CU<a class="headerlink" href="#libomptarget-amdgpu-teams-per-cu" title="Link to this heading">¶</a></h4>
<p>This environment variable controls the default number of teams relative to the
number of compute units (CUs) of the AMDGPU device. The default number of teams
is <code class="docutils literal notranslate"><span class="pre">#default_teams</span> <span class="pre">=</span> <span class="pre">#teams_per_CU</span> <span class="pre">*</span> <span class="pre">#CUs</span></code>. The default value of teams per CU
is <code class="docutils literal notranslate"><span class="pre">4</span></code>.</p>
</section>
<section id="libomptarget-amdgpu-max-async-copy-bytes">
<h4>LIBOMPTARGET_AMDGPU_MAX_ASYNC_COPY_BYTES<a class="headerlink" href="#libomptarget-amdgpu-max-async-copy-bytes" title="Link to this heading">¶</a></h4>
<p>This environment variable specifies the maximum size in bytes where the memory
copies are asynchronous operations in the AMDGPU plugin. Up to this transfer
size, the memory copies are asynchronous operations pushed to the corresponding
stream. For larger transfers, they are synchronous transfers. Memory copies
involving already locked/pinned host buffers are always asynchronous. The default
value is <code class="docutils literal notranslate"><span class="pre">1*1024*1024</span></code> bytes (1 MB).</p>
</section>
<section id="libomptarget-amdgpu-num-initial-hsa-signals">
<h4>LIBOMPTARGET_AMDGPU_NUM_INITIAL_HSA_SIGNALS<a class="headerlink" href="#libomptarget-amdgpu-num-initial-hsa-signals" title="Link to this heading">¶</a></h4>
<p>This environment variable controls the initial number of HSA signals per device
in the AMDGPU plugin. There is one resource manager of signals per device
managing several pre-created signals. These signals are mainly used by AMDGPU
streams. More HSA signals will be created dynamically throughout the execution
if needed. The default value is <code class="docutils literal notranslate"><span class="pre">64</span></code>.</p>
</section>
<section id="libomptarget-amdgpu-stream-busywait">
<h4>LIBOMPTARGET_AMDGPU_STREAM_BUSYWAIT<a class="headerlink" href="#libomptarget-amdgpu-stream-busywait" title="Link to this heading">¶</a></h4>
<p>This environment variable controls the timeout hint in microseconds for the
HSA wait state within the AMDGPU plugin. For the duration of this value
the HSA runtime may busy wait. This can reduce overall latency.
The default value is <code class="docutils literal notranslate"><span class="pre">2000000</span></code>.</p>
</section>
</section>
<section id="remote-offloading-plugin">
<span id="id9"></span><h3>Remote Offloading Plugin:<a class="headerlink" href="#remote-offloading-plugin" title="Link to this heading">¶</a></h3>
<p>The remote offloading plugin permits the execution of OpenMP target regions
on devices in remote hosts in addition to the devices connected to the local
host. All target devices on the remote host will be exposed to the
application as if they were local devices, that is, the remote host CPU or
its GPUs can be offloaded to with the appropriate device number. If the
server is running on the same host, each device may be identified twice:
once through the device plugins and once through the device plugins that the
server application has access to.</p>
<p>This plugin consists of <code class="docutils literal notranslate"><span class="pre">libomptarget.rtl.rpc.so</span></code> and
<code class="docutils literal notranslate"><span class="pre">openmp-offloading-server</span></code> which should be running on the (remote) host. The
server application does not have to be running on a remote host, and can
instead be used on the same host in order to debug memory mapping during offloading.
These are implemented via gRPC/protobuf so these libraries are required to
build and use this plugin. The server must also have access to the necessary
target-specific plugins in order to perform the offloading.</p>
<p>Due to the experimental nature of this plugin, the CMake variable
<code class="docutils literal notranslate"><span class="pre">LIBOMPTARGET_ENABLE_EXPERIMENTAL_REMOTE_PLUGIN</span></code> must be set in order to
build this plugin. For example, the rpc plugin is not designed to be
thread-safe, the server cannot concurrently handle offloading from multiple
applications at once (it is synchronous) and will terminate after a single
execution. Note that <code class="docutils literal notranslate"><span class="pre">openmp-offloading-server</span></code> is unable to
remote offload onto a remote host itself and will error out if this is attempted.</p>
<dl class="simple">
<dt>Remote offloading is configured via environment variables at runtime of the OpenMP application:</dt><dd><ul class="simple">
<li><p><code class="docutils literal notranslate"><span class="pre">LIBOMPTARGET_RPC_ADDRESS=&lt;Address&gt;:&lt;Port&gt;</span></code></p></li>
<li><p><code class="docutils literal notranslate"><span class="pre">LIBOMPTARGET_RPC_ALLOCATOR_MAX=&lt;NumBytes&gt;</span></code></p></li>
<li><p><code class="docutils literal notranslate"><span class="pre">LIBOMPTARGET_BLOCK_SIZE=&lt;NumBytes&gt;</span></code></p></li>
<li><p><code class="docutils literal notranslate"><span class="pre">LIBOMPTARGET_RPC_LATENCY=&lt;Seconds&gt;</span></code></p></li>
</ul>
</dd>
</dl>
<section id="libomptarget-rpc-address">
<h4>LIBOMPTARGET_RPC_ADDRESS<a class="headerlink" href="#libomptarget-rpc-address" title="Link to this heading">¶</a></h4>
<p>The address and port at which the server is running. This needs to be set for
the server and the application, the default is <code class="docutils literal notranslate"><span class="pre">0.0.0.0:50051</span></code>. A single
OpenMP executable can offload onto multiple remote hosts by setting this to
comma-separated values of the addresses.</p>
</section>
<section id="libomptarget-rpc-allocator-max">
<h4>LIBOMPTARGET_RPC_ALLOCATOR_MAX<a class="headerlink" href="#libomptarget-rpc-allocator-max" title="Link to this heading">¶</a></h4>
<p>After allocating this size, the protobuf allocator will clear. This can be set for both endpoints.</p>
</section>
<section id="libomptarget-block-size">
<h4>LIBOMPTARGET_BLOCK_SIZE<a class="headerlink" href="#libomptarget-block-size" title="Link to this heading">¶</a></h4>
<p>This is the maximum size of a single message while streaming data transfers between the two endpoints and can be set for both endpoints.</p>
</section>
<section id="libomptarget-rpc-latency">
<h4>LIBOMPTARGET_RPC_LATENCY<a class="headerlink" href="#libomptarget-rpc-latency" title="Link to this heading">¶</a></h4>
<p>This is the maximum amount of time the client will wait for a response from the server.</p>
</section>
</section>
<section id="llvm-openmp-support-for-c-library-routines">
<span id="libomptarget-libc"></span><h3>LLVM/OpenMP support for C library routines<a class="headerlink" href="#llvm-openmp-support-for-c-library-routines" title="Link to this heading">¶</a></h3>
<p>Support for calling standard C library routines on GPU targets is provided by
the <a class="reference external" href="https://libc.llvm.org/gpu/">LLVM C Library</a>. This project provides two
static libraries, <code class="docutils literal notranslate"><span class="pre">libcgpu.a</span></code> and <code class="docutils literal notranslate"><span class="pre">libllvmlibc_rpc_server.a</span></code>, which are used
by the OpenMP runtime to provide <code class="docutils literal notranslate"><span class="pre">libc</span></code> support. The <code class="docutils literal notranslate"><span class="pre">libcgpu.a</span></code> library
contains the GPU device code, while <code class="docutils literal notranslate"><span class="pre">libllvmlibc_rpc_server.a</span></code> provides the
interface to the RPC interface. More information on the RPC construction can be
found in the <a class="reference external" href="https://libc.llvm.org/gpu/rpc.html">associated documentation</a>.</p>
<p>To provide host services, we run an RPC server inside of the runtime. This
allows the host to respond to requests made from the GPU asynchronously. For
<code class="docutils literal notranslate"><span class="pre">libc</span></code> calls that require an RPC server, such as printing, an external handle
to the RPC client running on the GPU will be present in the GPU executable. If
we find this symbol, we will initialize a client and server and run it in the
background while the kernel is executing.</p>
<p>For example, consider the following simple OpenMP offloading code. Here we will
simply print a string to the user from the GPU.</p>
<div class="highlight-c++ notranslate"><div class="highlight"><pre><span></span><span class="cp">#include</span><span class="w"> </span><span class="cpf">&lt;stdio.h&gt;</span>

<span class="kt">int</span><span class="w"> </span><span class="nf">main</span><span class="p">()</span><span class="w"> </span><span class="p">{</span>
<span class="w"> </span><span class="cp">#pragma omp target</span>
<span class="w">   </span><span class="p">{</span><span class="w"> </span><span class="n">fputs</span><span class="p">(</span><span class="s">&quot;Hello World!</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span><span class="w"> </span><span class="n">stderr</span><span class="p">);</span><span class="w"> </span><span class="p">}</span>
<span class="p">}</span>
</pre></div>
</div>
<p>We can compile this using the <code class="docutils literal notranslate"><span class="pre">libcgpu.a</span></code> library to resolve the symbols.
Because this function requires RPC support, this will also pull in an externally
visible symbol called <code class="docutils literal notranslate"><span class="pre">__llvm_libc_rpc_client</span></code> into the device image. When
loading the device image, the runtime will check for this symbol and initialize
an RPC interface if it is found. The following example shows the RPC server
being used.</p>
<div class="highlight-console notranslate"><div class="highlight"><pre><span></span><span class="gp">$ </span>clang++<span class="w"> </span>hello.c<span class="w"> </span>-fopenmp<span class="w"> </span>--offload-arch<span class="o">=</span>gfx90a<span class="w"> </span>-lcgpu
<span class="gp">$ </span>env<span class="w"> </span><span class="nv">LIBOMPTARGET_DEBUG</span><span class="o">=</span><span class="m">1</span><span class="w"> </span>./a.out
<span class="go">PluginInterface --&gt; Running an RPC server on device 0</span>
<span class="go">...</span>
<span class="go">Hello World!</span>
</pre></div>
</div>
</section>
</section>
<section id="llvm-openmp-target-device-runtime-libomptarget-arch-subarch-bc">
<span id="libomptarget-device"></span><h2>LLVM/OpenMP Target Device Runtime (<code class="docutils literal notranslate"><span class="pre">libomptarget-ARCH-SUBARCH.bc</span></code>)<a class="headerlink" href="#llvm-openmp-target-device-runtime-libomptarget-arch-subarch-bc" title="Link to this heading">¶</a></h2>
<p>The target device runtime is an LLVM bitcode library that implements OpenMP
runtime functions on the target device. It is linked with the device code’s LLVM
IR during compilation.</p>
<section id="dynamic-shared-memory">
<span id="libomptarget-dynamic-shared"></span><h3>Dynamic Shared Memory<a class="headerlink" href="#dynamic-shared-memory" title="Link to this heading">¶</a></h3>
<p>The target device runtime contains a pointer to the dynamic shared memory
buffer. This pointer can be obtained using the
<code class="docutils literal notranslate"><span class="pre">llvm_omp_target_dynamic_shared_alloc</span></code> extension. If this function is called
from the host it will simply return a null pointer. In order to use this buffer
the kernel must be launched with an adequate amount of dynamic shared memory
allocated. This can be done using the <code class="docutils literal notranslate"><span class="pre">LIBOMPTARGET_SHARED_MEMORY_SIZE</span></code>
environment variable or the <code class="docutils literal notranslate"><span class="pre">ompx_dyn_cgroup_mem(&lt;N&gt;)</span></code> target directive
clause. Examples for both are given below.</p>
<div class="highlight-c++ notranslate"><div class="highlight"><pre><span></span><span class="kt">void</span><span class="w"> </span><span class="nf">foo</span><span class="p">()</span><span class="w"> </span><span class="p">{</span>
<span class="w">  </span><span class="kt">int</span><span class="w"> </span><span class="n">x</span><span class="p">;</span>
<span class="cp">#pragma omp target parallel map(from : x)</span>
<span class="w">  </span><span class="p">{</span>
<span class="w">    </span><span class="kt">int</span><span class="w"> </span><span class="o">*</span><span class="n">buf</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">llvm_omp_target_dynamic_shared_alloc</span><span class="p">();</span>
<span class="w">    </span><span class="k">if</span><span class="w"> </span><span class="p">(</span><span class="n">omp_get_thread_num</span><span class="p">()</span><span class="w"> </span><span class="o">==</span><span class="w"> </span><span class="mi">0</span><span class="p">)</span>
<span class="w">      </span><span class="o">*</span><span class="n">buf</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="mi">1</span><span class="p">;</span>
<span class="cp">#pragma omp barrier</span>
<span class="w">    </span><span class="k">if</span><span class="w"> </span><span class="p">(</span><span class="n">omp_get_thread_num</span><span class="p">()</span><span class="w"> </span><span class="o">==</span><span class="w"> </span><span class="mi">1</span><span class="p">)</span>
<span class="w">      </span><span class="n">x</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="o">*</span><span class="n">buf</span><span class="p">;</span>
<span class="w">  </span><span class="p">}</span>
<span class="w">  </span><span class="n">assert</span><span class="p">(</span><span class="n">x</span><span class="w"> </span><span class="o">==</span><span class="w"> </span><span class="mi">1</span><span class="p">);</span>
<span class="p">}</span>
</pre></div>
</div>
<div class="highlight-console notranslate"><div class="highlight"><pre><span></span><span class="gp">$ </span>clang++<span class="w"> </span>-fopenmp<span class="w"> </span>--offload-arch<span class="o">=</span>sm_80<span class="w"> </span>-O3<span class="w"> </span>shared.c
<span class="gp">$ </span>env<span class="w"> </span><span class="nv">LIBOMPTARGET_SHARED_MEMORY_SIZE</span><span class="o">=</span><span class="m">256</span><span class="w"> </span>./shared
</pre></div>
</div>
<div class="highlight-c++ notranslate"><div class="highlight"><pre><span></span><span class="kt">void</span><span class="w"> </span><span class="nf">foo</span><span class="p">(</span><span class="kt">int</span><span class="w"> </span><span class="n">N</span><span class="p">)</span><span class="w"> </span><span class="p">{</span>
<span class="w">  </span><span class="kt">int</span><span class="w"> </span><span class="n">x</span><span class="p">;</span>
<span class="cp">#pragma omp target parallel map(from : x) ompx_dyn_cgroup_mem(N * sizeof(int))</span>
<span class="w">  </span><span class="p">{</span>
<span class="w">    </span><span class="kt">int</span><span class="w"> </span><span class="o">*</span><span class="n">buf</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">llvm_omp_target_dynamic_shared_alloc</span><span class="p">();</span>
<span class="w">    </span><span class="k">if</span><span class="w"> </span><span class="p">(</span><span class="n">omp_get_thread_num</span><span class="p">()</span><span class="w"> </span><span class="o">==</span><span class="w"> </span><span class="mi">0</span><span class="p">)</span>
<span class="w">      </span><span class="n">buf</span><span class="p">[</span><span class="n">N</span><span class="w"> </span><span class="o">-</span><span class="w"> </span><span class="mi">1</span><span class="p">]</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="mi">1</span><span class="p">;</span>
<span class="cp">#pragma omp barrier</span>
<span class="w">    </span><span class="k">if</span><span class="w"> </span><span class="p">(</span><span class="n">omp_get_thread_num</span><span class="p">()</span><span class="w"> </span><span class="o">==</span><span class="w"> </span><span class="mi">1</span><span class="p">)</span>
<span class="w">      </span><span class="n">x</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">buf</span><span class="p">[</span><span class="n">N</span><span class="w"> </span><span class="o">-</span><span class="w"> </span><span class="mi">1</span><span class="p">];</span>
<span class="w">  </span><span class="p">}</span>
<span class="w">  </span><span class="n">assert</span><span class="p">(</span><span class="n">x</span><span class="w"> </span><span class="o">==</span><span class="w"> </span><span class="mi">1</span><span class="p">);</span>
<span class="p">}</span>
</pre></div>
</div>
<div class="highlight-console notranslate"><div class="highlight"><pre><span></span><span class="gp">$ </span>clang++<span class="w"> </span>-fopenmp<span class="w"> </span>--offload-arch<span class="o">=</span>gfx90a<span class="w"> </span>-O3<span class="w"> </span>shared.c
<span class="gp">$ </span>env<span class="w"> </span>./shared
</pre></div>
</div>
</section>
<section id="device-allocation">
<span id="libomptarget-device-allocator"></span><h3>Device Allocation<a class="headerlink" href="#device-allocation" title="Link to this heading">¶</a></h3>
<p>The device runtime supports basic runtime allocation via the <code class="docutils literal notranslate"><span class="pre">omp_alloc</span></code>
function. Currently, this allocates global memory for all default traits. Access
modifiers are currently not supported and return a null pointer.</p>
</section>
<section id="debugging">
<span id="libomptarget-device-debugging"></span><h3>Debugging<a class="headerlink" href="#debugging" title="Link to this heading">¶</a></h3>
<p>The device runtime supports debugging in the runtime itself. This is configured
at compile-time using the flag <code class="docutils literal notranslate"><span class="pre">-fopenmp-target-debug=&lt;N&gt;</span></code> rather than using a
separate debugging build. If debugging is not enabled, the debugging paths will
be considered trivially dead and removed by the compiler with zero overhead.
Debugging is enabled at runtime by running with the environment variable
<code class="docutils literal notranslate"><span class="pre">LIBOMPTARGET_DEVICE_RTL_DEBUG=&lt;N&gt;</span></code> set. The number set is a 32-bit field used
to selectively enable and disable different features.  Currently, the following
debugging features are supported.</p>
<blockquote>
<div><ul class="simple">
<li><p>Enable debugging assertions in the device. <code class="docutils literal notranslate"><span class="pre">0x01</span></code></p></li>
<li><p>Enable diagnosing common problems during offloading . <code class="docutils literal notranslate"><span class="pre">0x4</span></code></p></li>
<li><p>Enable device malloc statistics (amdgpu only). <code class="docutils literal notranslate"><span class="pre">0x8</span></code></p></li>
<li><p>Dump device PGO counters (only if PGO on GPU is enabled). <code class="docutils literal notranslate"><span class="pre">0x10</span></code></p></li>
</ul>
</div></blockquote>
</section>
</section>
</section>


            <div class="clearer"></div>
          </div>
        </div>
      </div>
        </div>
        <div class="sidebar">
          
          <h3>Table of Contents</h3>
          <ul>
<li class="toctree-l1"><a class="reference internal" href="../index.html">LLVM/OpenMP Documentation</a></li>
</ul>
<ul class="current">
<li class="toctree-l1 current"><a class="reference internal" href="Overview.html">OpenMP in LLVM — Design Overview</a><ul class="current">
<li class="toctree-l2 current"><a class="current reference internal" href="#">LLVM/OpenMP Runtimes</a></li>
<li class="toctree-l2"><a class="reference internal" href="Offloading.html">OpenMP in LLVM — Offloading Design</a></li>
</ul>
</li>
</ul>
<ul>
<li class="toctree-l1"><a class="reference internal" href="../openacc/Overview.html">OpenACC Support</a></li>
</ul>
<ul>
<li class="toctree-l1"><a class="reference internal" href="../optimizations/Overview.html">OpenMP Optimizations in LLVM</a></li>
</ul>
<ul>
<li class="toctree-l1"><a class="reference internal" href="../remarks/OptimizationRemarks.html">OpenMP Optimization Remarks</a></li>
</ul>
<ul>
<li class="toctree-l1"><a class="reference internal" href="../CommandLineArgumentReference.html">OpenMP Command-Line Argument Reference</a></li>
</ul>
<ul>
<li class="toctree-l1"><a class="reference internal" href="../SupportAndFAQ.html">Support, Getting Involved, and FAQ</a></li>
</ul>
<ul>
<li class="toctree-l1"><a class="reference internal" href="../ReleaseNotes.html">In-Progress ReleaseNotes</a></li>
</ul>

          <div role="search">
            <h3 style="margin-top: 1.5em;">Search</h3>
            <form class="search" action="../search.html" method="get">
                <input type="text" name="q" />
                <input type="submit" value="Go" />
            </form>
          </div>

        </div>
        <div class="clearer"></div>
      </div>
    </div>

    <div class="footer-wrapper">
      <div class="footer">
        <div class="left">
          <div role="navigation" aria-label="related navigaton">
            <a href="../index.html" title="LLVM OpenMP Documentation">HOME</a>
             |
            <a href="Overview.html" title="OpenMP in LLVM — Design Overview"
              >previous</a> |
            <a href="Offloading.html" title="OpenMP in LLVM — Offloading Design"
              >next</a> |
            <a href="../genindex.html" title="General Index"
              >index</a>
          </div>
          <div role="note" aria-label="source link">
          </div>
        </div>

        <div class="right">
          
    <div class="footer" role="contentinfo">
    &#169; Copyright 2013-2025, LLVM/OpenMP.
      Last updated on 2025-08-13.
      Created using <a href="https://www.sphinx-doc.org/">Sphinx</a> 7.2.6.
    </div>
        </div>
        <div class="clearer"></div>
      </div>
    </div>

  </body>
</html>