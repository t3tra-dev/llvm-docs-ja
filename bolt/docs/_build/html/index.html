<!DOCTYPE html>

<html lang="en" data-content_root="./">
  <head>
    <meta charset="utf-8" />
    <meta name="viewport" content="width=device-width, initial-scale=1.0" /><meta name="viewport" content="width=device-width, initial-scale=1" />

    <title>BOLT &#8212; BOLT  documentation</title>
    <link rel="stylesheet" type="text/css" href="_static/pygments.css?v=d75fae25" />
    <link rel="stylesheet" type="text/css" href="_static/haiku.css?v=e491ac2d" />
    <script src="_static/documentation_options.js?v=5929fcd5"></script>
    <script src="_static/doctools.js?v=888ff710"></script>
    <script src="_static/sphinx_highlight.js?v=dc90522c"></script>
    <link rel="icon" href="_static/favicon.ico"/>
    <link rel="index" title="Index" href="genindex.html" />
    <link rel="search" title="Search" href="search.html" /> 
  </head><body>
      <div class="header" role="banner"><h1 class="heading"><a href="#">
          <span>BOLT  documentation</span></a></h1>
        <h2 class="heading"><span>BOLT</span></h2>
      </div>
      <div class="topnav" role="navigation" aria-label="top navigation">
      
        <p>
        <a class="uplink" href="#">Contents</a>
        </p>

      </div>
      <div class="content" role="main">
        
        
  <section id="bolt">
<h1>BOLT<a class="headerlink" href="#bolt" title="Link to this heading">¶</a></h1>
<p>BOLT is a post-link optimizer developed to speed up large applications.
It achieves the improvements by optimizing application’s code layout
based on execution profile gathered by sampling profiler, such as Linux
<code class="docutils literal notranslate"><span class="pre">perf</span></code> tool. An overview of the ideas implemented in BOLT along with a
discussion of its potential and current results is available in <a class="reference external" href="https://research.fb.com/publications/bolt-a-practical-binary-optimizer-for-data-centers-and-beyond/">CGO’19
paper</a>.</p>
<section id="input-binary-requirements">
<h2>Input Binary Requirements<a class="headerlink" href="#input-binary-requirements" title="Link to this heading">¶</a></h2>
<p>BOLT operates on X86-64 and AArch64 ELF binaries. At the minimum, the
binaries should have an unstripped symbol table, and, to get maximum
performance gains, they should be linked with relocations
(<code class="docutils literal notranslate"><span class="pre">--emit-relocs</span></code> or <code class="docutils literal notranslate"><span class="pre">-q</span></code> linker flag).</p>
<p>BOLT disassembles functions and reconstructs the control flow graph
(CFG) before it runs optimizations. Since this is a nontrivial task,
especially when indirect branches are present, we rely on certain
heuristics to accomplish it. These heuristics have been tested on a code
generated with Clang and GCC compilers. The main requirement for C/C++
code is not to rely on code layout properties, such as function pointer
deltas. Assembly code can be processed too. Requirements for it include
a clear separation of code and data, with data objects being placed into
data sections/segments. If indirect jumps are used for intra-function
control transfer (e.g., jump tables), the code patterns should be
matching those generated by Clang/GCC.</p>
<p>NOTE: BOLT is currently incompatible with the
<code class="docutils literal notranslate"><span class="pre">-freorder-blocks-and-partition</span></code> compiler option. Since GCC8 enables
this option by default, you have to explicitly disable it by adding
<code class="docutils literal notranslate"><span class="pre">-fno-reorder-blocks-and-partition</span></code> flag if you are compiling with
GCC8 or above.</p>
<p>NOTE2: DWARF v5 is the new debugging format generated by the latest LLVM
and GCC compilers. It offers several benefits over the previous DWARF
v4. Currently, the support for v5 is a work in progress for BOLT. While
you will be able to optimize binaries produced by the latest compilers,
until the support is complete, you will not be able to update the debug
info with <code class="docutils literal notranslate"><span class="pre">-update-debug-sections</span></code>. To temporarily work around the
issue, we recommend compiling binaries with <code class="docutils literal notranslate"><span class="pre">-gdwarf-4</span></code> option that
forces DWARF v4 output.</p>
<p>PIE and .so support has been added recently. Please report bugs if you
encounter any issues.</p>
</section>
<section id="installation">
<h2>Installation<a class="headerlink" href="#installation" title="Link to this heading">¶</a></h2>
<section id="docker-image">
<h3>Docker Image<a class="headerlink" href="#docker-image" title="Link to this heading">¶</a></h3>
<p>You can build and use the docker image containing BOLT using our <a class="reference external" href="utils/docker/Dockerfile">docker
file</a>. Alternatively, you can build BOLT
manually using the steps below.</p>
</section>
<section id="manual-build">
<h3>Manual Build<a class="headerlink" href="#manual-build" title="Link to this heading">¶</a></h3>
<p>BOLT heavily uses LLVM libraries, and by design, it is built as one of
LLVM tools. The build process is not much different from a regular LLVM
build. The following instructions are assuming that you are running
under Linux.</p>
<p>Start with cloning LLVM repo:</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="o">&gt;</span> <span class="n">git</span> <span class="n">clone</span> <span class="n">https</span><span class="p">:</span><span class="o">//</span><span class="n">github</span><span class="o">.</span><span class="n">com</span><span class="o">/</span><span class="n">llvm</span><span class="o">/</span><span class="n">llvm</span><span class="o">-</span><span class="n">project</span><span class="o">.</span><span class="n">git</span>
<span class="o">&gt;</span> <span class="n">mkdir</span> <span class="n">build</span>
<span class="o">&gt;</span> <span class="n">cd</span> <span class="n">build</span>
<span class="o">&gt;</span> <span class="n">cmake</span> <span class="o">-</span><span class="n">G</span> <span class="n">Ninja</span> <span class="o">../</span><span class="n">llvm</span><span class="o">-</span><span class="n">project</span><span class="o">/</span><span class="n">llvm</span> <span class="o">-</span><span class="n">DLLVM_TARGETS_TO_BUILD</span><span class="o">=</span><span class="s2">&quot;X86;AArch64&quot;</span> <span class="o">-</span><span class="n">DCMAKE_BUILD_TYPE</span><span class="o">=</span><span class="n">Release</span> <span class="o">-</span><span class="n">DLLVM_ENABLE_ASSERTIONS</span><span class="o">=</span><span class="n">ON</span> <span class="o">-</span><span class="n">DLLVM_ENABLE_PROJECTS</span><span class="o">=</span><span class="s2">&quot;bolt&quot;</span>
<span class="o">&gt;</span> <span class="n">ninja</span> <span class="n">bolt</span>
</pre></div>
</div>
<p><code class="docutils literal notranslate"><span class="pre">llvm-bolt</span></code> will be available under <code class="docutils literal notranslate"><span class="pre">bin/</span></code>. Add this directory to
your path to ensure the rest of the commands in this tutorial work.</p>
</section>
</section>
<section id="optimizing-bolts-performance">
<h2>Optimizing BOLT’s Performance<a class="headerlink" href="#optimizing-bolts-performance" title="Link to this heading">¶</a></h2>
<p>BOLT runs many internal passes in parallel. If you foresee heavy usage
of BOLT, you can improve the processing time by linking against one of
memory allocation libraries with good support for concurrency. E.g. to
use jemalloc:</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="o">&gt;</span> <span class="n">sudo</span> <span class="n">yum</span> <span class="n">install</span> <span class="n">jemalloc</span><span class="o">-</span><span class="n">devel</span>
<span class="o">&gt;</span> <span class="n">LD_PRELOAD</span><span class="o">=/</span><span class="n">usr</span><span class="o">/</span><span class="n">lib64</span><span class="o">/</span><span class="n">libjemalloc</span><span class="o">.</span><span class="n">so</span> <span class="n">llvm</span><span class="o">-</span><span class="n">bolt</span> <span class="o">....</span>
</pre></div>
</div>
<p>Or if you rather use tcmalloc:</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="o">&gt;</span> <span class="n">sudo</span> <span class="n">yum</span> <span class="n">install</span> <span class="n">gperftools</span><span class="o">-</span><span class="n">devel</span>
<span class="o">&gt;</span> <span class="n">LD_PRELOAD</span><span class="o">=/</span><span class="n">usr</span><span class="o">/</span><span class="n">lib64</span><span class="o">/</span><span class="n">libtcmalloc_minimal</span><span class="o">.</span><span class="n">so</span> <span class="n">llvm</span><span class="o">-</span><span class="n">bolt</span> <span class="o">....</span>
</pre></div>
</div>
</section>
<section id="usage">
<h2>Usage<a class="headerlink" href="#usage" title="Link to this heading">¶</a></h2>
<p>For a complete practical guide of using BOLT see <a class="reference external" href="docs/OptimizingClang.md">Optimizing Clang with
BOLT</a>.</p>
<section id="step-0">
<h3>Step 0<a class="headerlink" href="#step-0" title="Link to this heading">¶</a></h3>
<p>In order to allow BOLT to re-arrange functions (in addition to
re-arranging code within functions) in your program, it needs a little
help from the linker. Add <code class="docutils literal notranslate"><span class="pre">--emit-relocs</span></code> to the final link step of
your application. You can verify the presence of relocations by checking
for <code class="docutils literal notranslate"><span class="pre">.rela.text</span></code> section in the binary. BOLT will also report if it
detects relocations while processing the binary.</p>
</section>
<section id="step-1-collect-profile">
<h3>Step 1: Collect Profile<a class="headerlink" href="#step-1-collect-profile" title="Link to this heading">¶</a></h3>
<p>This step is different for different kinds of executables. If you can
invoke your program to run on a representative input from a command
line, then check <strong>For Applications</strong> section below. If your program
typically runs as a server/service, then skip to <strong>For Services</strong>
section.</p>
<p>The version of <code class="docutils literal notranslate"><span class="pre">perf</span></code> command used for the following steps has to
support <code class="docutils literal notranslate"><span class="pre">-F</span> <span class="pre">brstack</span></code> option. We recommend using <code class="docutils literal notranslate"><span class="pre">perf</span></code> version 4.5
or later.</p>
<section id="for-applications">
<h4>For Applications<a class="headerlink" href="#for-applications" title="Link to this heading">¶</a></h4>
<p>This assumes you can run your program from a command line with a typical
input. In this case, simply prepend the command line invocation with
<code class="docutils literal notranslate"><span class="pre">perf</span></code>:</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span>$ perf record -e cycles:u -j any,u -o perf.data -- &lt;executable&gt; &lt;args&gt; ...
</pre></div>
</div>
</section>
<section id="for-services">
<h4>For Services<a class="headerlink" href="#for-services" title="Link to this heading">¶</a></h4>
<p>Once you get the service deployed and warmed-up, it is time to collect
perf data with LBR (branch information). The exact perf command to use
will depend on the service. E.g., to collect the data for all processes
running on the server for the next 3 minutes use:</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span>$ perf record -e cycles:u -j any,u -a -o perf.data -- sleep 180
</pre></div>
</div>
<p>Depending on the application, you may need more samples to be included
with your profile. It’s hard to tell upfront what would be a sweet spot
for your application. We recommend the profile to cover 1B instructions
as reported by BOLT <code class="docutils literal notranslate"><span class="pre">-dyno-stats</span></code> option. If you need to increase the
number of samples in the profile, you can either run the <code class="docutils literal notranslate"><span class="pre">sleep</span></code>
command for longer and use <code class="docutils literal notranslate"><span class="pre">-F&lt;N&gt;</span></code> option with <code class="docutils literal notranslate"><span class="pre">perf</span></code> to increase
sampling frequency.</p>
<p>Note that for profile collection we recommend using cycle events and not
<code class="docutils literal notranslate"><span class="pre">BR_INST_RETIRED.*</span></code>. Empirically we found it to produce better
results.</p>
<p>If the collection of a profile with branches is not available, e.g.,
when you run on a VM or on hardware that does not support it, then you
can use only sample events, such as cycles. In this case, the quality of
the profile information would not be as good, and performance gains with
BOLT are expected to be lower.</p>
</section>
<section id="with-instrumentation">
<h4>With instrumentation<a class="headerlink" href="#with-instrumentation" title="Link to this heading">¶</a></h4>
<p>If perf record is not available to you, you may collect profile by first
instrumenting the binary with BOLT and then running it.</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="n">llvm</span><span class="o">-</span><span class="n">bolt</span> <span class="o">&lt;</span><span class="n">executable</span><span class="o">&gt;</span> <span class="o">-</span><span class="n">instrument</span> <span class="o">-</span><span class="n">o</span> <span class="o">&lt;</span><span class="n">instrumented</span><span class="o">-</span><span class="n">executable</span><span class="o">&gt;</span>
</pre></div>
</div>
<p>After you run instrumented-executable with the desired workload, its
BOLT profile should be ready for you in <code class="docutils literal notranslate"><span class="pre">/tmp/prof.fdata</span></code> and you can
skip <strong>Step 2</strong>.</p>
<p>Run BOLT with the <code class="docutils literal notranslate"><span class="pre">-help</span></code> option and check the category “BOLT
instrumentation options” for a quick reference on instrumentation knobs.</p>
</section>
</section>
<section id="step-2-convert-profile-to-bolt-format">
<h3>Step 2: Convert Profile to BOLT Format<a class="headerlink" href="#step-2-convert-profile-to-bolt-format" title="Link to this heading">¶</a></h3>
<p>NOTE: you can skip this step and feed <code class="docutils literal notranslate"><span class="pre">perf.data</span></code> directly to BOLT
using experimental <code class="docutils literal notranslate"><span class="pre">-p</span> <span class="pre">perf.data</span></code> option.</p>
<p>For this step, you will need <code class="docutils literal notranslate"><span class="pre">perf.data</span></code> file collected from the
previous step and a copy of the binary that was running. The binary has
to be either unstripped, or should have a symbol table intact (i.e.,
running <code class="docutils literal notranslate"><span class="pre">strip</span> <span class="pre">-g</span></code> is okay).</p>
<p>Make sure <code class="docutils literal notranslate"><span class="pre">perf</span></code> is in your <code class="docutils literal notranslate"><span class="pre">PATH</span></code>, and execute <code class="docutils literal notranslate"><span class="pre">perf2bolt</span></code>:</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span>$ perf2bolt -p perf.data -o perf.fdata &lt;executable&gt;
</pre></div>
</div>
<p>This command will aggregate branch data from <code class="docutils literal notranslate"><span class="pre">perf.data</span></code> and store it
in a format that is both more compact and more resilient to binary
modifications.</p>
<p>If the profile was collected without LBRs, you will need to add <code class="docutils literal notranslate"><span class="pre">-nl</span></code>
flag to the command line above.</p>
</section>
<section id="step-3-optimize-with-bolt">
<h3>Step 3: Optimize with BOLT<a class="headerlink" href="#step-3-optimize-with-bolt" title="Link to this heading">¶</a></h3>
<p>Once you have <code class="docutils literal notranslate"><span class="pre">perf.fdata</span></code> ready, you can use it for optimizations
with BOLT. Assuming your environment is setup to include the right path,
execute <code class="docutils literal notranslate"><span class="pre">llvm-bolt</span></code>:</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span>$ llvm-bolt &lt;executable&gt; -o &lt;executable&gt;.bolt -data=perf.fdata -reorder-blocks=ext-tsp -reorder-functions=hfsort -split-functions -split-all-cold -split-eh -dyno-stats
</pre></div>
</div>
<p>If you do need an updated debug info, then add
<code class="docutils literal notranslate"><span class="pre">-update-debug-sections</span></code> option to the command above. The processing
time will be slightly longer.</p>
<p>For a full list of options see <code class="docutils literal notranslate"><span class="pre">-help</span></code>/<code class="docutils literal notranslate"><span class="pre">-help-hidden</span></code> output.</p>
<p>The input binary for this step does not have to 100% match the binary
used for profile collection in <strong>Step 1</strong>. This could happen when you
are doing active development, and the source code constantly changes,
yet you want to benefit from profile-guided optimizations. However,
since the binary is not precisely the same, the profile information
could become invalid or stale, and BOLT will report the number of
functions with a stale profile. The higher the number, the less
performance improvement should be expected. Thus, it is crucial to
update <code class="docutils literal notranslate"><span class="pre">.fdata</span></code> for release branches.</p>
</section>
</section>
<section id="multiple-profiles">
<h2>Multiple Profiles<a class="headerlink" href="#multiple-profiles" title="Link to this heading">¶</a></h2>
<p>Suppose your application can run in different modes, and you can
generate multiple profiles for each one of them. To generate a single
binary that can benefit all modes (assuming the profiles don’t
contradict each other) you can use <code class="docutils literal notranslate"><span class="pre">merge-fdata</span></code> tool:</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span>$ merge-fdata *.fdata &gt; combined.fdata
</pre></div>
</div>
<p>Use <code class="docutils literal notranslate"><span class="pre">combined.fdata</span></code> for <strong>Step 3</strong> above to generate a universally
optimized binary.</p>
</section>
<section id="license">
<h2>License<a class="headerlink" href="#license" title="Link to this heading">¶</a></h2>
<p>BOLT is licensed under the <a class="reference external" href="./LICENSE.TXT">Apache License v2.0 with LLVM
Exceptions</a>.</p>
</section>
</section>


      </div>
      <div class="bottomnav" role="navigation" aria-label="bottom navigation">
      
        <p>
        <a class="uplink" href="#">Contents</a>
        </p>

      </div>

    <div class="footer" role="contentinfo">
    &#169; Copyright 2015-2025, BOLT team.
      Last updated on 2025-08-13.
      Created using <a href="https://www.sphinx-doc.org/">Sphinx</a> 7.2.6.
    </div>
  </body>
</html>